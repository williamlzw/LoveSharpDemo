<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LoveSharp</name>
    </assembly>
    <members>
        <member name="F:Love.Color.r">
            <summary>
            get/set each color range (0-255)
            </summary>
        </member>
        <member name="F:Love.Color.g">
            <summary>
            get/set each color range (0-255)
            </summary>
        </member>
        <member name="F:Love.Color.b">
            <summary>
            get/set each color range (0-255)
            </summary>
        </member>
        <member name="F:Love.Color.a">
            <summary>
            get/set each color range (0-255)
            </summary>
        </member>
        <member name="P:Love.Color.Rf">
            <summary>
            get/set red component [0-1]
            </summary>
        </member>
        <member name="P:Love.Color.Gf">
            <summary>
            get/set green component [0-1]
            </summary>
        </member>
        <member name="P:Love.Color.Bf">
            <summary>
            get/set blue component [0-1]
            </summary>
        </member>
        <member name="P:Love.Color.Af">
            <summary>
            get/set alpha component [0-1]
            </summary>
        </member>
        <member name="P:Love.Color.UintValue">
            <summary>
            get as uint value
            </summary>
        </member>
        <member name="M:Love.Color.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Generate new Color and set each color component from 0.0 to 1.0
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Color.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Generate new Color and set each color component from 0 to 255
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Color.FromRGBA(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Generate new Color and set each color component from 0.0 to 1.0
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Color.FromRGBA(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Generate new Color and set each color component from 0 to 255
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Love.FPSCounter.GetFPS">
            <summary>
            Get the amount of frame from last one seconds.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Log">
            <summary>
            log about the love library
            </summary>
        </member>
        <member name="F:Love.Log.TargetType.Console">
            <summary>
            use Console.WriteLine to log
            </summary>
        </member>
        <member name="F:Love.Log.TargetType.DiagnosticsDubug">
            <summary>
            use System.Diagnostics.Debug.WriteLine to log
            </summary>
        </member>
        <member name="F:Love.Log.TargetType.DiagnosticsTrace">
            <summary>
            use System.Diagnostics.Trace.WriteLine to log
            </summary>
        </member>
        <member name="F:Love.MathUtil.ZeroTolerance">
            <summary>
            The value for which all absolute numbers smaller than are considered equal to zero.
            </summary>
        </member>
        <member name="F:Love.MathUtil.Pi">
            <summary>
            A value specifying the approximation of π which is 180 degrees.
            </summary>
        </member>
        <member name="F:Love.MathUtil.TwoPi">
            <summary>
            A value specifying the approximation of 2π which is 360 degrees.
            </summary>
        </member>
        <member name="F:Love.MathUtil.PiOverTwo">
            <summary>
            A value specifying the approximation of π/2 which is 90 degrees.
            </summary>
        </member>
        <member name="F:Love.MathUtil.PiOverFour">
            <summary>
            A value specifying the approximation of π/4 which is 45 degrees.
            </summary>
        </member>
        <member name="M:Love.MathUtil.NearEqual(System.Single,System.Single)">
            <summary>
            Checks if a and b are almost equals, taking into account the magnitude of floating point numbers (unlike <see cref="M:Love.MathUtil.WithinEpsilon(System.Single,System.Single,System.Single)"/> method). See Remarks.
            See remarks.
            </summary>
            <param name="a">The left value to compare.</param>
            <param name="b">The right value to compare.</param>
            <returns><c>true</c> if a almost equal to b, <c>false</c> otherwise</returns>
            <remarks>
            The code is using the technique described by Bruce Dawson in 
            <a href="http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">Comparing Floating point numbers 2012 edition</a>. 
            </remarks>
        </member>
        <member name="M:Love.MathUtil.IsZero(System.Single)">
            <summary>
            Determines whether the specified value is close to zero (0.0f).
            </summary>
            <param name="a">The floating value.</param>
            <returns><c>true</c> if the specified value is close to zero (0.0f); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Love.MathUtil.IsOne(System.Single)">
            <summary>
            Determines whether the specified value is close to one (1.0f).
            </summary>
            <param name="a">The floating value.</param>
            <returns><c>true</c> if the specified value is close to one (1.0f); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Love.MathUtil.WithinEpsilon(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a - b are almost equals within a float epsilon.
            </summary>
            <param name="a">The left value to compare.</param>
            <param name="b">The right value to compare.</param>
            <param name="epsilon">Epsilon value</param>
            <returns><c>true</c> if a almost equal to b within a float epsilon, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Love.MathUtil.RevolutionsToDegrees(System.Single)">
            <summary>
            Converts revolutions to degrees.
            </summary>
            <param name="revolution">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.RevolutionsToRadians(System.Single)">
            <summary>
            Converts revolutions to radians.
            </summary>
            <param name="revolution">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.RevolutionsToGradians(System.Single)">
            <summary>
            Converts revolutions to gradians.
            </summary>
            <param name="revolution">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.DegreesToRevolutions(System.Single)">
            <summary>
            Converts degrees to revolutions.
            </summary>
            <param name="degree">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.DegreesToRadians(System.Single)">
            <summary>
            Converts degrees to radians.
            </summary>
            <param name="degree">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.RadiansToRevolutions(System.Single)">
            <summary>
            Converts radians to revolutions.
            </summary>
            <param name="radian">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.RadiansToGradians(System.Single)">
            <summary>
            Converts radians to gradians.
            </summary>
            <param name="radian">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.GradiansToRevolutions(System.Single)">
            <summary>
            Converts gradians to revolutions.
            </summary>
            <param name="gradian">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.GradiansToDegrees(System.Single)">
            <summary>
            Converts gradians to degrees.
            </summary>
            <param name="gradian">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.GradiansToRadians(System.Single)">
            <summary>
            Converts gradians to radians.
            </summary>
            <param name="gradian">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.RadiansToDegrees(System.Single)">
            <summary>
            Converts radians to degrees.
            </summary>
            <param name="radian">The value to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Love.MathUtil.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamps the specified value.
            </summary>
            <param name="value">The value.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
            <returns>The result of clamping a value between min and max</returns>
        </member>
        <member name="M:Love.MathUtil.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamps the specified value.
            </summary>
            <param name="value">The value.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
            <returns>The result of clamping a value between min and max</returns>
        </member>
        <member name="M:Love.MathUtil.Lerp(System.Double,System.Double,System.Double)">
            <summary>
            Interpolates between two values using a linear function by a given amount.
            </summary>
            <remarks>
            See http://www.encyclopediaofmath.org/index.php/Linear_interpolation and
            http://fgiesen.wordpress.com/2012/08/15/linear-interpolation-past-present-and-future/
            </remarks>
            <param name="from">Value to interpolate from.</param>
            <param name="to">Value to interpolate to.</param>
            <param name="amount">Interpolation amount.</param>
            <returns>The result of linear interpolation of values based on the amount.</returns>
        </member>
        <member name="M:Love.MathUtil.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Interpolates between two values using a linear function by a given amount.
            </summary>
            <remarks>
            See http://www.encyclopediaofmath.org/index.php/Linear_interpolation and
            http://fgiesen.wordpress.com/2012/08/15/linear-interpolation-past-present-and-future/
            </remarks>
            <param name="from">Value to interpolate from.</param>
            <param name="to">Value to interpolate to.</param>
            <param name="amount">Interpolation amount.</param>
            <returns>The result of linear interpolation of values based on the amount.</returns>
        </member>
        <member name="M:Love.MathUtil.Lerp(System.Byte,System.Byte,System.Single)">
            <summary>
            Interpolates between two values using a linear function by a given amount.
            </summary>
            <remarks>
            See http://www.encyclopediaofmath.org/index.php/Linear_interpolation and
            http://fgiesen.wordpress.com/2012/08/15/linear-interpolation-past-present-and-future/
            </remarks>
            <param name="from">Value to interpolate from.</param>
            <param name="to">Value to interpolate to.</param>
            <param name="amount">Interpolation amount.</param>
            <returns>The result of linear interpolation of values based on the amount.</returns>
        </member>
        <member name="M:Love.MathUtil.SmoothStep(System.Single)">
            <summary>
            Performs smooth (cubic Hermite) interpolation between 0 and 1.
            </summary>
            <remarks>
            See https://en.wikipedia.org/wiki/Smoothstep
            </remarks>
            <param name="amount">Value between 0 and 1 indicating interpolation amount.</param>
        </member>
        <member name="M:Love.MathUtil.SmootherStep(System.Single)">
            <summary>
            Performs a smooth(er) interpolation between 0 and 1 with 1st and 2nd order derivatives of zero at endpoints.
            </summary>
            <remarks>
            See https://en.wikipedia.org/wiki/Smoothstep
            </remarks>
            <param name="amount">Value between 0 and 1 indicating interpolation amount.</param>
        </member>
        <member name="M:Love.MathUtil.Mod(System.Single,System.Single)">
            <summary>
            Calculates the modulo of the specified value.
            </summary>
            <param name="value">The value.</param>
            <param name="modulo">The modulo.</param>
            <returns>The result of the modulo applied to value</returns>
        </member>
        <member name="M:Love.MathUtil.Mod2PI(System.Single)">
            <summary>
            Calculates the modulo 2*PI of the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the modulo applied to value</returns>
        </member>
        <member name="M:Love.MathUtil.Wrap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Wraps the specified value into a range [min, max]
            </summary>
            <param name="value">The value to wrap.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
            <returns>Result of the wrapping.</returns>
            <exception cref="T:System.ArgumentException">Is thrown when <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
        </member>
        <member name="M:Love.MathUtil.Wrap(System.Single,System.Single,System.Single)">
            <summary>
            Wraps the specified value into a range [min, max[
            </summary>
            <param name="value">The value.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
            <returns>Result of the wrapping.</returns>
            <exception cref="T:System.ArgumentException">Is thrown when <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
        </member>
        <member name="M:Love.MathUtil.Gauss(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Gauss function.
            http://en.wikipedia.org/wiki/Gaussian_function#Two-dimensional_Gaussian_function
            </summary>
            <param name="amplitude">Curve amplitude.</param>
            <param name="x">Position X.</param>
            <param name="y">Position Y</param>
            <param name="centerX">Center X.</param>
            <param name="centerY">Center Y.</param>
            <param name="sigmaX">Curve sigma X.</param>
            <param name="sigmaY">Curve sigma Y.</param>
            <returns>The result of Gaussian function.</returns>
        </member>
        <member name="M:Love.MathUtil.Gauss(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Gauss function.
            http://en.wikipedia.org/wiki/Gaussian_function#Two-dimensional_Gaussian_function
            </summary>
            <param name="amplitude">Curve amplitude.</param>
            <param name="x">Position X.</param>
            <param name="y">Position Y</param>
            <param name="centerX">Center X.</param>
            <param name="centerY">Center Y.</param>
            <param name="sigmaX">Curve sigma X.</param>
            <param name="sigmaY">Curve sigma Y.</param>
            <returns>The result of Gaussian function.</returns>
        </member>
        <member name="T:Love.Matrix33">
            <summary>
            Represents a 3x3 Matrix ( contains only Scale and Rotation ).
            </summary>
        </member>
        <member name="F:Love.Matrix33.Zero">
            <summary>
            A <see cref="!:Matrix3x3"/> with all of its components set to zero.
            </summary>
        </member>
        <member name="F:Love.Matrix33.Identity">
            <summary>
            The identity <see cref="T:Love.Matrix33"/>.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M11">
            <summary>
            Value at row 1 column 1 of the Matrix3x3.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M12">
            <summary>
            Value at row 1 column 2 of the Matrix3x3.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M13">
            <summary>
            Value at row 1 column 3 of the Matrix3x3.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M21">
            <summary>
            Value at row 2 column 1 of the Matrix3x3.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M22">
            <summary>
            Value at row 2 column 2 of the Matrix3x3.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M23">
            <summary>
            Value at row 2 column 3 of the Matrix3x3.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M31">
            <summary>
            Value at row 3 column 1 of the Matrix3x3.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M32">
            <summary>
            Value at row 3 column 2 of the Matrix3x3.
            </summary>
        </member>
        <member name="F:Love.Matrix33.M33">
            <summary>
            Value at row 3 column 3 of the Matrix3x3.
            </summary>
        </member>
        <member name="M:Love.Matrix33.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Matrix33"/> struct.
            </summary>
            <param name="value">The value that will be assigned to all components.</param>
        </member>
        <member name="M:Love.Matrix33.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Matrix33"/> struct.
            </summary>
            <param name="M11">The value to assign at row 1 column 1 of the Matrix3x3.</param>
            <param name="M12">The value to assign at row 1 column 2 of the Matrix3x3.</param>
            <param name="M13">The value to assign at row 1 column 3 of the Matrix3x3.</param>
            <param name="M21">The value to assign at row 2 column 1 of the Matrix3x3.</param>
            <param name="M22">The value to assign at row 2 column 2 of the Matrix3x3.</param>
            <param name="M23">The value to assign at row 2 column 3 of the Matrix3x3.</param>
            <param name="M31">The value to assign at row 3 column 1 of the Matrix3x3.</param>
            <param name="M32">The value to assign at row 3 column 2 of the Matrix3x3.</param>
            <param name="M33">The value to assign at row 3 column 3 of the Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.#ctor(System.Single[])">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Matrix33"/> struct.
            </summary>
            <param name="values">The values to assign to the components of the Matrix3x3. This must be an array with sixteen elements.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than sixteen elements.</exception>
        </member>
        <member name="P:Love.Matrix33.Row1">
            <summary>
            Gets or sets the first row in the Matrix3x3; that is M11, M12, M13
            </summary>
        </member>
        <member name="P:Love.Matrix33.Row2">
            <summary>
            Gets or sets the second row in the Matrix3x3; that is M21, M22, M23
            </summary>
        </member>
        <member name="P:Love.Matrix33.Row3">
            <summary>
            Gets or sets the third row in the Matrix3x3; that is M31, M32, M33
            </summary>
        </member>
        <member name="P:Love.Matrix33.Column1">
            <summary>
            Gets or sets the first column in the Matrix3x3; that is M11, M21, M31
            </summary>
        </member>
        <member name="P:Love.Matrix33.Column2">
            <summary>
            Gets or sets the second column in the Matrix3x3; that is M12, M22, M32
            </summary>
        </member>
        <member name="P:Love.Matrix33.Column3">
            <summary>
            Gets or sets the third column in the Matrix3x3; that is M13, M23, M33
            </summary>
        </member>
        <member name="P:Love.Matrix33.ScaleVector">
            <summary>
            Gets or sets the scale of the Matrix3x3; that is M11, M22, and M33.
            </summary>
        </member>
        <member name="P:Love.Matrix33.IsIdentity">
            <summary>
            Gets a value indicating whether this instance is an identity Matrix3x3.
            </summary>
            <value>
            <c>true</c> if this instance is an identity Matrix3x3; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Love.Matrix33.Item(System.Int32)">
            <summary>
            Gets or sets the component at the specified index.
            </summary>
            <value>The value of the Matrix3x3 component, depending on the index.</value>
            <param name="index">The zero-based index of the component to access.</param>
            <returns>The value of the component at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 15].</exception>
        </member>
        <member name="P:Love.Matrix33.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the component at the specified index.
            </summary>
            <value>The value of the Matrix3x3 component, depending on the index.</value>
            <param name="row">The row of the Matrix3x3 to access.</param>
            <param name="column">The column of the Matrix3x3 to access.</param>
            <returns>The value of the component at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="row"/> or <paramref name="column"/>is out of the range [0, 3].</exception>
        </member>
        <member name="M:Love.Matrix33.Determinant">
            <summary>
            Calculates the determinant of the Matrix3x3.
            </summary>
            <returns>The determinant of the Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Invert">
            <summary>
            Inverts the Matrix3x3.
            </summary>
        </member>
        <member name="M:Love.Matrix33.Transpose">
            <summary>
            Transposes the Matrix3x3.
            </summary>
        </member>
        <member name="M:Love.Matrix33.Orthogonalize">
            <summary>
            Orthogonalizes the specified Matrix3x3.
            </summary>
            <remarks>
            <para>Orthogonalization is the process of making all rows orthogonal to each other. This
            means that any given row in the Matrix3x3 will be orthogonal to any other given row in the
            Matrix3x3.</para>
            <para>Because this method uses the modified Gram-Schmidt process, the resulting Matrix3x3
            tends to be numerically unstable. The numeric stability decreases according to the rows
            so that the first row is the most stable and the last row is the least stable.</para>
            <para>This operation is performed on the rows of the Matrix3x3 rather than the columns.
            If you wish for this operation to be performed on the columns, first transpose the
            input and than transpose the output.</para>
            </remarks>
        </member>
        <member name="M:Love.Matrix33.Orthonormalize">
            <summary>
            Orthonormalizes the specified Matrix3x3.
            </summary>
            <remarks>
            <para>Orthonormalization is the process of making all rows and columns orthogonal to each
            other and making all rows and columns of unit length. This means that any given row will
            be orthogonal to any other given row and any given column will be orthogonal to any other
            given column. Any given row will not be orthogonal to any given column. Every row and every
            column will be of unit length.</para>
            <para>Because this method uses the modified Gram-Schmidt process, the resulting Matrix3x3
            tends to be numerically unstable. The numeric stability decreases according to the rows
            so that the first row is the most stable and the last row is the least stable.</para>
            <para>This operation is performed on the rows of the Matrix3x3 rather than the columns.
            If you wish for this operation to be performed on the columns, first transpose the
            input and than transpose the output.</para>
            </remarks>
        </member>
        <member name="M:Love.Matrix33.DecomposeQR(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Decomposes a Matrix3x3 into an orthonormalized Matrix3x3 Q and a right triangular Matrix3x3 R.
            </summary>
            <param name="Q">When the method completes, contains the orthonormalized Matrix3x3 of the decomposition.</param>
            <param name="R">When the method completes, contains the right triangular Matrix3x3 of the decomposition.</param>
        </member>
        <member name="M:Love.Matrix33.DecomposeLQ(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Decomposes a Matrix3x3 into a lower triangular Matrix3x3 L and an orthonormalized Matrix3x3 Q.
            </summary>
            <param name="L">When the method completes, contains the lower triangular Matrix3x3 of the decomposition.</param>
            <param name="Q">When the method completes, contains the orthonormalized Matrix3x3 of the decomposition.</param>
        </member>
        <member name="M:Love.Matrix33.Decompose(Love.Vector3@,Love.Quaternion@)">
            <summary>
            Decomposes a Matrix3x3 into a scale, rotation, and translation.
            </summary>
            <param name="scale">When the method completes, contains the scaling component of the decomposed Matrix3x3.</param>
            <param name="rotation">When the method completes, contains the rotation component of the decomposed Matrix3x3.</param>
            <remarks>
            This method is designed to decompose an SRT transformation Matrix3x3 only.
            </remarks>
        </member>
        <member name="M:Love.Matrix33.DecomposeUniformScale(System.Single@,Love.Quaternion@)">
            <summary>
            Decomposes a uniform scale matrix into a scale, rotation, and translation.
            A uniform scale matrix has the same scale in every axis.
            </summary>
            <param name="scale">When the method completes, contains the scaling component of the decomposed matrix.</param>
            <param name="rotation">When the method completes, contains the rotation component of the decomposed matrix.</param>
            <remarks>
            This method is designed to decompose only an SRT transformation matrix that has the same scale in every axis.
            </remarks>
        </member>
        <member name="M:Love.Matrix33.ExchangeRows(System.Int32,System.Int32)">
            <summary>
            Exchanges two rows in the Matrix3x3.
            </summary>
            <param name="firstRow">The first row to exchange. This is an index of the row starting at zero.</param>
            <param name="secondRow">The second row to exchange. This is an index of the row starting at zero.</param>
        </member>
        <member name="M:Love.Matrix33.ExchangeColumns(System.Int32,System.Int32)">
            <summary>
            Exchanges two columns in the Matrix3x3.
            </summary>
            <param name="firstColumn">The first column to exchange. This is an index of the column starting at zero.</param>
            <param name="secondColumn">The second column to exchange. This is an index of the column starting at zero.</param>
        </member>
        <member name="M:Love.Matrix33.ToArray">
            <summary>
            Creates an array containing the elements of the Matrix3x3.
            </summary>
            <returns>A 9-element array containing the components of the Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Add(Love.Matrix33@,Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Determines the sum of two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to add.</param>
            <param name="right">The second Matrix3x3 to add.</param>
            <param name="result">When the method completes, contains the sum of the two matrices.</param>
        </member>
        <member name="M:Love.Matrix33.Add(Love.Matrix33,Love.Matrix33)">
            <summary>
            Determines the sum of two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to add.</param>
            <param name="right">The second Matrix3x3 to add.</param>
            <returns>The sum of the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.Subtract(Love.Matrix33@,Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Determines the difference between two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to subtract.</param>
            <param name="right">The second Matrix3x3 to subtract.</param>
            <param name="result">When the method completes, contains the difference between the two matrices.</param>
        </member>
        <member name="M:Love.Matrix33.Subtract(Love.Matrix33,Love.Matrix33)">
            <summary>
            Determines the difference between two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to subtract.</param>
            <param name="right">The second Matrix3x3 to subtract.</param>
            <returns>The difference between the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.Multiply(Love.Matrix33@,System.Single,Love.Matrix33@)">
            <summary>
            Scales a Matrix3x3 by the given value.
            </summary>
            <param name="left">The Matrix3x3 to scale.</param>
            <param name="right">The amount by which to scale.</param>
            <param name="result">When the method completes, contains the scaled Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.Multiply(Love.Matrix33,System.Single)">
            <summary>
            Scales a Matrix3x3 by the given value.
            </summary>
            <param name="left">The Matrix3x3 to scale.</param>
            <param name="right">The amount by which to scale.</param>
            <returns>The scaled Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Multiply(Love.Matrix33@,Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Determines the product of two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to multiply.</param>
            <param name="right">The second Matrix3x3 to multiply.</param>
            <param name="result">The product of the two matrices.</param>
        </member>
        <member name="M:Love.Matrix33.Multiply(Love.Matrix33,Love.Matrix33)">
            <summary>
            Determines the product of two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to multiply.</param>
            <param name="right">The second Matrix3x3 to multiply.</param>
            <returns>The product of the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.Divide(Love.Matrix33@,System.Single,Love.Matrix33@)">
            <summary>
            Scales a Matrix3x3 by the given value.
            </summary>
            <param name="left">The Matrix3x3 to scale.</param>
            <param name="right">The amount by which to scale.</param>
            <param name="result">When the method completes, contains the scaled Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.Divide(Love.Matrix33,System.Single)">
            <summary>
            Scales a Matrix3x3 by the given value.
            </summary>
            <param name="left">The Matrix3x3 to scale.</param>
            <param name="right">The amount by which to scale.</param>
            <returns>The scaled Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Divide(Love.Matrix33@,Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Determines the quotient of two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to divide.</param>
            <param name="right">The second Matrix3x3 to divide.</param>
            <param name="result">When the method completes, contains the quotient of the two matrices.</param>
        </member>
        <member name="M:Love.Matrix33.Divide(Love.Matrix33,Love.Matrix33)">
            <summary>
            Determines the quotient of two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to divide.</param>
            <param name="right">The second Matrix3x3 to divide.</param>
            <returns>The quotient of the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.Exponent(Love.Matrix33@,System.Int32,Love.Matrix33@)">
            <summary>
            Performs the exponential operation on a Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to perform the operation on.</param>
            <param name="exponent">The exponent to raise the Matrix3x3 to.</param>
            <param name="result">When the method completes, contains the exponential Matrix3x3.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="exponent"/> is negative.</exception>
        </member>
        <member name="M:Love.Matrix33.Exponent(Love.Matrix33,System.Int32)">
            <summary>
            Performs the exponential operation on a Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to perform the operation on.</param>
            <param name="exponent">The exponent to raise the Matrix3x3 to.</param>
            <returns>The exponential Matrix3x3.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="exponent"/> is negative.</exception>
        </member>
        <member name="M:Love.Matrix33.Negate(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Negates a Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to be negated.</param>
            <param name="result">When the method completes, contains the negated Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.Negate(Love.Matrix33)">
            <summary>
            Negates a Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to be negated.</param>
            <returns>The negated Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Lerp(Love.Matrix33@,Love.Matrix33@,System.Single,Love.Matrix33@)">
            <summary>
            Performs a linear interpolation between two matrices.
            </summary>
            <param name="start">Start Matrix3x3.</param>
            <param name="end">End Matrix3x3.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
            <param name="result">When the method completes, contains the linear interpolation of the two matrices.</param>
            <remarks>
            Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned.
            </remarks>
        </member>
        <member name="M:Love.Matrix33.Lerp(Love.Matrix33,Love.Matrix33,System.Single)">
            <summary>
            Performs a linear interpolation between two matrices.
            </summary>
            <param name="start">Start Matrix3x3.</param>
            <param name="end">End Matrix3x3.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
            <returns>The linear interpolation of the two matrices.</returns>
            <remarks>
            Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned.
            </remarks>
        </member>
        <member name="M:Love.Matrix33.SmoothStep(Love.Matrix33@,Love.Matrix33@,System.Single,Love.Matrix33@)">
            <summary>
            Performs a cubic interpolation between two matrices.
            </summary>
            <param name="start">Start Matrix3x3.</param>
            <param name="end">End Matrix3x3.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
            <param name="result">When the method completes, contains the cubic interpolation of the two matrices.</param>
        </member>
        <member name="M:Love.Matrix33.SmoothStep(Love.Matrix33,Love.Matrix33,System.Single)">
            <summary>
            Performs a cubic interpolation between two matrices.
            </summary>
            <param name="start">Start Matrix3x3.</param>
            <param name="end">End Matrix3x3.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
            <returns>The cubic interpolation of the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.Transpose(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Calculates the transpose of the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 whose transpose is to be calculated.</param>
            <param name="result">When the method completes, contains the transpose of the specified Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.TransposeByRef(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Calculates the transpose of the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 whose transpose is to be calculated.</param>
            <param name="result">When the method completes, contains the transpose of the specified Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.Transpose(Love.Matrix33)">
            <summary>
            Calculates the transpose of the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 whose transpose is to be calculated.</param>
            <returns>The transpose of the specified Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Invert(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Calculates the inverse of the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 whose inverse is to be calculated.</param>
            <param name="result">When the method completes, contains the inverse of the specified Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.Invert(Love.Matrix33)">
            <summary>
            Calculates the inverse of the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 whose inverse is to be calculated.</param>
            <returns>The inverse of the specified Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Orthogonalize(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Orthogonalizes the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to orthogonalize.</param>
            <param name="result">When the method completes, contains the orthogonalized Matrix3x3.</param>
            <remarks>
            <para>Orthogonalization is the process of making all rows orthogonal to each other. This
            means that any given row in the Matrix3x3 will be orthogonal to any other given row in the
            Matrix3x3.</para>
            <para>Because this method uses the modified Gram-Schmidt process, the resulting Matrix3x3
            tends to be numerically unstable. The numeric stability decreases according to the rows
            so that the first row is the most stable and the last row is the least stable.</para>
            <para>This operation is performed on the rows of the Matrix3x3 rather than the columns.
            If you wish for this operation to be performed on the columns, first transpose the
            input and than transpose the output.</para>
            </remarks>
        </member>
        <member name="M:Love.Matrix33.Orthogonalize(Love.Matrix33)">
            <summary>
            Orthogonalizes the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to orthogonalize.</param>
            <returns>The orthogonalized Matrix3x3.</returns>
            <remarks>
            <para>Orthogonalization is the process of making all rows orthogonal to each other. This
            means that any given row in the Matrix3x3 will be orthogonal to any other given row in the
            Matrix3x3.</para>
            <para>Because this method uses the modified Gram-Schmidt process, the resulting Matrix3x3
            tends to be numerically unstable. The numeric stability decreases according to the rows
            so that the first row is the most stable and the last row is the least stable.</para>
            <para>This operation is performed on the rows of the Matrix3x3 rather than the columns.
            If you wish for this operation to be performed on the columns, first transpose the
            input and than transpose the output.</para>
            </remarks>
        </member>
        <member name="M:Love.Matrix33.Orthonormalize(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Orthonormalizes the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to orthonormalize.</param>
            <param name="result">When the method completes, contains the orthonormalized Matrix3x3.</param>
            <remarks>
            <para>Orthonormalization is the process of making all rows and columns orthogonal to each
            other and making all rows and columns of unit length. This means that any given row will
            be orthogonal to any other given row and any given column will be orthogonal to any other
            given column. Any given row will not be orthogonal to any given column. Every row and every
            column will be of unit length.</para>
            <para>Because this method uses the modified Gram-Schmidt process, the resulting Matrix3x3
            tends to be numerically unstable. The numeric stability decreases according to the rows
            so that the first row is the most stable and the last row is the least stable.</para>
            <para>This operation is performed on the rows of the Matrix3x3 rather than the columns.
            If you wish for this operation to be performed on the columns, first transpose the
            input and than transpose the output.</para>
            </remarks>
        </member>
        <member name="M:Love.Matrix33.Orthonormalize(Love.Matrix33)">
            <summary>
            Orthonormalizes the specified Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to orthonormalize.</param>
            <returns>The orthonormalized Matrix3x3.</returns>
            <remarks>
            <para>Orthonormalization is the process of making all rows and columns orthogonal to each
            other and making all rows and columns of unit length. This means that any given row will
            be orthogonal to any other given row and any given column will be orthogonal to any other
            given column. Any given row will not be orthogonal to any given column. Every row and every
            column will be of unit length.</para>
            <para>Because this method uses the modified Gram-Schmidt process, the resulting Matrix3x3
            tends to be numerically unstable. The numeric stability decreases according to the rows
            so that the first row is the most stable and the last row is the least stable.</para>
            <para>This operation is performed on the rows of the Matrix3x3 rather than the columns.
            If you wish for this operation to be performed on the columns, first transpose the
            input and than transpose the output.</para>
            </remarks>
        </member>
        <member name="M:Love.Matrix33.UpperTriangularForm(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Brings the Matrix3x3 into upper triangular form using elementary row operations.
            </summary>
            <param name="value">The Matrix3x3 to put into upper triangular form.</param>
            <param name="result">When the method completes, contains the upper triangular Matrix3x3.</param>
            <remarks>
            If the Matrix3x3 is not invertible (i.e. its determinant is zero) than the result of this
            method may produce Single.Nan and Single.Inf values. When the Matrix3x3 represents a system
            of linear equations, than this often means that either no solution exists or an infinite
            number of solutions exist.
            </remarks>
        </member>
        <member name="M:Love.Matrix33.UpperTriangularForm(Love.Matrix33)">
            <summary>
            Brings the Matrix3x3 into upper triangular form using elementary row operations.
            </summary>
            <param name="value">The Matrix3x3 to put into upper triangular form.</param>
            <returns>The upper triangular Matrix3x3.</returns>
            <remarks>
            If the Matrix3x3 is not invertible (i.e. its determinant is zero) than the result of this
            method may produce Single.Nan and Single.Inf values. When the Matrix3x3 represents a system
            of linear equations, than this often means that either no solution exists or an infinite
            number of solutions exist.
            </remarks>
        </member>
        <member name="M:Love.Matrix33.LowerTriangularForm(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Brings the Matrix3x3 into lower triangular form using elementary row operations.
            </summary>
            <param name="value">The Matrix3x3 to put into lower triangular form.</param>
            <param name="result">When the method completes, contains the lower triangular Matrix3x3.</param>
            <remarks>
            If the Matrix3x3 is not invertible (i.e. its determinant is zero) than the result of this
            method may produce Single.Nan and Single.Inf values. When the Matrix3x3 represents a system
            of linear equations, than this often means that either no solution exists or an infinite
            number of solutions exist.
            </remarks>
        </member>
        <member name="M:Love.Matrix33.LowerTriangularForm(Love.Matrix33)">
            <summary>
            Brings the Matrix3x3 into lower triangular form using elementary row operations.
            </summary>
            <param name="value">The Matrix3x3 to put into lower triangular form.</param>
            <returns>The lower triangular Matrix3x3.</returns>
            <remarks>
            If the Matrix3x3 is not invertible (i.e. its determinant is zero) than the result of this
            method may produce Single.Nan and Single.Inf values. When the Matrix3x3 represents a system
            of linear equations, than this often means that either no solution exists or an infinite
            number of solutions exist.
            </remarks>
        </member>
        <member name="M:Love.Matrix33.RowEchelonForm(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Brings the Matrix3x3 into row echelon form using elementary row operations;
            </summary>
            <param name="value">The Matrix3x3 to put into row echelon form.</param>
            <param name="result">When the method completes, contains the row echelon form of the Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.RowEchelonForm(Love.Matrix33)">
            <summary>
            Brings the Matrix3x3 into row echelon form using elementary row operations;
            </summary>
            <param name="value">The Matrix3x3 to put into row echelon form.</param>
            <returns>When the method completes, contains the row echelon form of the Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.BillboardLH(Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Matrix33@)">
            <summary>
            Creates a left-handed spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <param name="result">When the method completes, contains the created billboard Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.BillboardLH(Love.Vector3,Love.Vector3,Love.Vector3,Love.Vector3)">
            <summary>
            Creates a left-handed spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <returns>The created billboard Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.BillboardRH(Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Matrix33@)">
            <summary>
            Creates a right-handed spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <param name="result">When the method completes, contains the created billboard Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.BillboardRH(Love.Vector3,Love.Vector3,Love.Vector3,Love.Vector3)">
            <summary>
            Creates a right-handed spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <returns>The created billboard Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.LookAtLH(Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Matrix33@)">
            <summary>
            Creates a left-handed, look-at Matrix3x3.
            </summary>
            <param name="eye">The position of the viewer's eye.</param>
            <param name="target">The camera look-at target.</param>
            <param name="up">The camera's up vector.</param>
            <param name="result">When the method completes, contains the created look-at Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.LookAtLH(Love.Vector3,Love.Vector3,Love.Vector3)">
            <summary>
            Creates a left-handed, look-at Matrix3x3.
            </summary>
            <param name="eye">The position of the viewer's eye.</param>
            <param name="target">The camera look-at target.</param>
            <param name="up">The camera's up vector.</param>
            <returns>The created look-at Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.LookAtRH(Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Matrix33@)">
            <summary>
            Creates a right-handed, look-at Matrix3x3.
            </summary>
            <param name="eye">The position of the viewer's eye.</param>
            <param name="target">The camera look-at target.</param>
            <param name="up">The camera's up vector.</param>
            <param name="result">When the method completes, contains the created look-at Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.LookAtRH(Love.Vector3,Love.Vector3,Love.Vector3)">
            <summary>
            Creates a right-handed, look-at Matrix3x3.
            </summary>
            <param name="eye">The position of the viewer's eye.</param>
            <param name="target">The camera look-at target.</param>
            <param name="up">The camera's up vector.</param>
            <returns>The created look-at Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Scaling(Love.Vector3@,Love.Matrix33@)">
            <summary>
            Creates a Matrix3x3 that scales along the x-axis, y-axis, and y-axis.
            </summary>
            <param name="scale">Scaling factor for all three axes.</param>
            <param name="result">When the method completes, contains the created scaling Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.Scaling(Love.Vector3)">
            <summary>
            Creates a Matrix3x3 that scales along the x-axis, y-axis, and y-axis.
            </summary>
            <param name="scale">Scaling factor for all three axes.</param>
            <returns>The created scaling Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Scaling(System.Single,System.Single,System.Single,Love.Matrix33@)">
            <summary>
            Creates a Matrix3x3 that scales along the x-axis, y-axis, and y-axis.
            </summary>
            <param name="x">Scaling factor that is applied along the x-axis.</param>
            <param name="y">Scaling factor that is applied along the y-axis.</param>
            <param name="z">Scaling factor that is applied along the z-axis.</param>
            <param name="result">When the method completes, contains the created scaling Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.Scaling(System.Single,System.Single,System.Single)">
            <summary>
            Creates a Matrix3x3 that scales along the x-axis, y-axis, and y-axis.
            </summary>
            <param name="x">Scaling factor that is applied along the x-axis.</param>
            <param name="y">Scaling factor that is applied along the y-axis.</param>
            <param name="z">Scaling factor that is applied along the z-axis.</param>
            <returns>The created scaling Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.Scaling(System.Single,Love.Matrix33@)">
            <summary>
            Creates a Matrix3x3 that uniformly scales along all three axis.
            </summary>
            <param name="scale">The uniform scale that is applied along all axis.</param>
            <param name="result">When the method completes, contains the created scaling Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.Scaling(System.Single)">
            <summary>
            Creates a Matrix3x3 that uniformly scales along all three axis.
            </summary>
            <param name="scale">The uniform scale that is applied along all axis.</param>
            <returns>The created scaling Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.RotationX(System.Single,Love.Matrix33@)">
            <summary>
            Creates a Matrix3x3 that rotates around the x-axis.
            </summary>
            <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
            <param name="result">When the method completes, contains the created rotation Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.RotationX(System.Single)">
            <summary>
            Creates a Matrix3x3 that rotates around the x-axis.
            </summary>
            <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
            <returns>The created rotation Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.RotationY(System.Single,Love.Matrix33@)">
            <summary>
            Creates a Matrix3x3 that rotates around the y-axis.
            </summary>
            <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
            <param name="result">When the method completes, contains the created rotation Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.RotationY(System.Single)">
            <summary>
            Creates a Matrix3x3 that rotates around the y-axis.
            </summary>
            <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
            <returns>The created rotation Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.RotationZ(System.Single,Love.Matrix33@)">
            <summary>
            Creates a Matrix3x3 that rotates around the z-axis.
            </summary>
            <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
            <param name="result">When the method completes, contains the created rotation Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.RotationZ(System.Single)">
            <summary>
            Creates a Matrix3x3 that rotates around the z-axis.
            </summary>
            <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
            <returns>The created rotation Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.RotationAxis(Love.Vector3@,System.Single,Love.Matrix33@)">
            <summary>
            Creates a Matrix3x3 that rotates around an arbitrary axis.
            </summary>
            <param name="axis">The axis around which to rotate. This parameter is assumed to be normalized.</param>
            <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
            <param name="result">When the method completes, contains the created rotation Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.RotationAxis(Love.Vector3,System.Single)">
            <summary>
            Creates a Matrix3x3 that rotates around an arbitrary axis.
            </summary>
            <param name="axis">The axis around which to rotate. This parameter is assumed to be normalized.</param>
            <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
            <returns>The created rotation Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.RotationQuaternion(Love.Quaternion@,Love.Matrix33@)">
            <summary>
            Creates a rotation Matrix3x3 from a quaternion.
            </summary>
            <param name="rotation">The quaternion to use to build the Matrix3x3.</param>
            <param name="result">The created rotation Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.RotationQuaternion(Love.Quaternion)">
            <summary>
            Creates a rotation Matrix3x3 from a quaternion.
            </summary>
            <param name="rotation">The quaternion to use to build the Matrix3x3.</param>
            <returns>The created rotation Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.RotationYawPitchRoll(System.Single,System.Single,System.Single,Love.Matrix33@)">
            <summary>
            Creates a rotation Matrix3x3 with a specified yaw, pitch, and roll.
            </summary>
            <param name="yaw">Yaw around the y-axis, in radians.</param>
            <param name="pitch">Pitch around the x-axis, in radians.</param>
            <param name="roll">Roll around the z-axis, in radians.</param>
            <param name="result">When the method completes, contains the created rotation Matrix3x3.</param>
        </member>
        <member name="M:Love.Matrix33.RotationYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            Creates a rotation Matrix3x3 with a specified yaw, pitch, and roll.
            </summary>
            <param name="yaw">Yaw around the y-axis, in radians.</param>
            <param name="pitch">Pitch around the x-axis, in radians.</param>
            <param name="roll">Roll around the z-axis, in radians.</param>
            <returns>The created rotation Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Addition(Love.Matrix33,Love.Matrix33)">
            <summary>
            Adds two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to add.</param>
            <param name="right">The second Matrix3x3 to add.</param>
            <returns>The sum of the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.op_UnaryPlus(Love.Matrix33)">
            <summary>
            Assert a Matrix3x3 (return it unchanged).
            </summary>
            <param name="value">The Matrix3x3 to assert (unchanged).</param>
            <returns>The asserted (unchanged) Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Subtraction(Love.Matrix33,Love.Matrix33)">
            <summary>
            Subtracts two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to subtract.</param>
            <param name="right">The second Matrix3x3 to subtract.</param>
            <returns>The difference between the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.op_UnaryNegation(Love.Matrix33)">
            <summary>
            Negates a Matrix3x3.
            </summary>
            <param name="value">The Matrix3x3 to negate.</param>
            <returns>The negated Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Multiply(System.Single,Love.Matrix33)">
            <summary>
            Scales a Matrix3x3 by a given value.
            </summary>
            <param name="right">The Matrix3x3 to scale.</param>
            <param name="left">The amount by which to scale.</param>
            <returns>The scaled Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Multiply(Love.Matrix33,System.Single)">
            <summary>
            Scales a Matrix3x3 by a given value.
            </summary>
            <param name="left">The Matrix3x3 to scale.</param>
            <param name="right">The amount by which to scale.</param>
            <returns>The scaled Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Multiply(Love.Matrix33,Love.Matrix33)">
            <summary>
            Multiplies two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to multiply.</param>
            <param name="right">The second Matrix3x3 to multiply.</param>
            <returns>The product of the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Division(Love.Matrix33,System.Single)">
            <summary>
            Scales a Matrix3x3 by a given value.
            </summary>
            <param name="left">The Matrix3x3 to scale.</param>
            <param name="right">The amount by which to scale.</param>
            <returns>The scaled Matrix3x3.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Division(Love.Matrix33,Love.Matrix33)">
            <summary>
            Divides two matrices.
            </summary>
            <param name="left">The first Matrix3x3 to divide.</param>
            <param name="right">The second Matrix3x3 to divide.</param>
            <returns>The quotient of the two matrices.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Equality(Love.Matrix33,Love.Matrix33)">
            <summary>
            Tests for equality between two objects.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Inequality(Love.Matrix33,Love.Matrix33)">
            <summary>
            Tests for inequality between two objects.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Love.Matrix33.op_Explicit(Love.Matrix33)~Love.Matrix44">
            <summary>
            Convert the 3x3 Matrix to a 4x4 Matrix.
            </summary>
            <returns>A 4x4 Matrix with zero translation and M44=1</returns>
        </member>
        <member name="M:Love.Matrix33.op_Explicit(Love.Matrix44)~Love.Matrix33">
            <summary>
            Convert the 4x4 Matrix to a 3x3 Matrix.
            </summary>
            <returns>A 3x3 Matrix</returns>
        </member>
        <member name="M:Love.Matrix33.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Love.Matrix33.ToString(System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="format">The format.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Love.Matrix33.ToString(System.IFormatProvider)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="formatProvider">The format provider.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Love.Matrix33.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="format">The format.</param>
            <param name="formatProvider">The format provider.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Love.Matrix33.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:Love.Matrix33.Equals(Love.Matrix33@)">
            <summary>
            Determines whether the specified <see cref="T:Love.Matrix33"/> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:Love.Matrix33"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:Love.Matrix33"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Love.Matrix33.Equals(Love.Matrix33)">
            <summary>
            Determines whether the specified <see cref="T:Love.Matrix33"/> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:Love.Matrix33"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:Love.Matrix33"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Love.Matrix33.Equals(Love.Matrix33@,Love.Matrix33@)">
            <summary>
            Determines whether the specified <see cref="T:Love.Matrix33"/> are equal.
            </summary>
        </member>
        <member name="M:Love.Matrix33.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Love.Matrix44.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor for 4x4 Matrix
            </summary>
            <param name="m11">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m12">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m13">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m14">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m21">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m22">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m23">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m24">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m31">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m32">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m33">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m34">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m41">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m42">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m43">
            A <see cref="T:System.Single"/>
            </param>
            <param name="m44">
            A <see cref="T:System.Single"/>
            </param>
        </member>
        <member name="M:Love.Matrix44.Add(Love.Matrix44,Love.Matrix44)">
            <summary>
            Adds second matrix to the first.
            </summary>
            <param name="matrix1">
            A <see cref="T:Love.Matrix44"/>
            </param>
            <param name="matrix2">
            A <see cref="T:Love.Matrix44"/>
            </param>
            <returns>
            A <see cref="T:Love.Matrix44"/>
            </returns>
        </member>
        <member name="M:Love.Matrix44.Add(Love.Matrix44@,Love.Matrix44@,Love.Matrix44@)">
            <summary>
            Adds two Matrix and save to the result Matrix
            </summary>
            <param name="matrix1">
            A <see cref="T:Love.Matrix44"/>
            </param>
            <param name="matrix2">
            A <see cref="T:Love.Matrix44"/>
            </param>
            <param name="result">
            A <see cref="T:Love.Matrix44"/>
            </param>
        </member>
        <member name="M:Love.Matrix44.Invert(Love.Matrix44,Love.Matrix44@)">
            <summary>
            Attempts to calculate the inverse of the given matrix. If successful, result will contain the inverted matrix.
            </summary>
            <param name="matrix">The source matrix to invert.</param>
            <param name="result">If successful, contains the inverted matrix.</param>
            <returns>True if the source matrix could be inverted; False otherwise.</returns>
        </member>
        <member name="P:Love.Misc.FPSGraph.Position">
            <summary>
            set or get graph position
            </summary>
        </member>
        <member name="P:Love.Misc.FPSGraph.Size">
            <summary>
            set or get graph size
            </summary>
        </member>
        <member name="P:Love.Misc.FPSGraph.Rect">
            <summary>
            set or get graph rect
            </summary>
        </member>
        <member name="M:Love.Misc.FPSGraph.Update(System.Single)">
            <summary>
            update graph
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:Love.Misc.FPSGraph.Draw">
            <summary>
            draw graph
            </summary>
        </member>
        <member name="T:Love.Misc.MeshUtils.Vertex">
            <summary>
            for Mesh function
            </summary>
        </member>
        <member name="F:Love.Misc.MeshUtils.Vertex.x">
            <summary>
            The position of the vertex .
            </summary>
        </member>
        <member name="F:Love.Misc.MeshUtils.Vertex.y">
            <summary>
            The position of the vertex .
            </summary>
        </member>
        <member name="F:Love.Misc.MeshUtils.Vertex.u">
            <summary>
            The u and v texture coordinate of the vertex. Texture coordinates are normally in the range of [0, 1], but can be greater or less (see WrapMode.)
            </summary>
        </member>
        <member name="F:Love.Misc.MeshUtils.Vertex.v">
            <summary>
            The u and v texture coordinate of the vertex. Texture coordinates are normally in the range of [0, 1], but can be greater or less (see WrapMode.)
            </summary>
        </member>
        <member name="F:Love.Misc.MeshUtils.Vertex.r">
            <summary>
            The vertex color.
            </summary>
        </member>
        <member name="F:Love.Misc.MeshUtils.Vertex.g">
            <summary>
            The vertex color.
            </summary>
        </member>
        <member name="F:Love.Misc.MeshUtils.Vertex.b">
            <summary>
            The vertex color.
            </summary>
        </member>
        <member name="F:Love.Misc.MeshUtils.Vertex.a">
            <summary>
            The vertex color.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Love.Misc.MeshUtils.Vertex.#ctor(System.Single,System.Single,System.Single,System.Single,System.Byte,System.Byte,System.Byte,System.Byte)" -->
        <member name="F:Love.Misc.MeshUtils.StandardVertexDescribe">
            <summary>
            MeshFormatDescribe info of Vertex
            </summary>
        </member>
        <member name="M:Love.Misc.MeshUtils.Parse``1">
            <summary>
            throw exception when parse to an empty MeshAttribFormat
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Love.Misc.Moonshine">
            <summary>
            Postprocessing effect repository for LÖVE.
            <para> adapt from https://github.com/vrld/moonshine .</para>
            <para> more resource https://www.love2d.org/forums/viewtopic.php?t=3733 .</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.Effect.Enable">
            <summary>
            this effect is enabled
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.DoubleBufferCanvas.Front">
            <summary>
            The destination it should render into.
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.DoubleBufferCanvas.Back">
            <summary>
            The previous result
            </summary>
        </member>
        <member name="M:Love.Misc.Moonshine.DoubleBufferCanvas.Swap">
            <summary>
            Swap Front and Back. (Back, Front = Front, Back)
            </summary>
        </member>
        <member name="M:Love.Misc.Moonshine.DoubleBufferCanvas.Swap(Love.Shader)">
            <summary>
            Swap Front and Back with shader. (Back, Front = Front, Back)
            </summary>
        </member>
        <member name="M:Love.Misc.Moonshine.DrawWithShader(Love.Canvas,Love.Canvas,Love.Shader)">
            <summary>
            this function uses shader to draw the Source buffer to the Dest buffer with given Shader.
            </summary>
            <param name="dest">Canvas that ready to draw as target</param>
            <param name="source">Canvas to draw</param>
            <param name="shader">Shader used when draw source canvas to dest canvas</param>
        </member>
        <member name="M:Love.Misc.Moonshine.China(Love.Misc.Moonshine.Effect)">
            <summary>
            Create MoonShine
            </summary>
            <param name="w"></param>
            <param name="h"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Misc.Moonshine.Create(System.Int32,System.Int32,Love.Misc.Moonshine.Effect)">
            <summary>
            Create MoonShine With width and height
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:Love.Misc.Moonshine.BoxBlur">
            <summary>
             simple blurring
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.BoxBlur.Default">
            <summary>
            default BoxBlur
            </summary>
        </member>
        <member name="M:Love.Misc.Moonshine.BoxBlur.#ctor">
            <summary>
            default BoxBlur constructor
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Chromasep">
            <summary>
            cheap/fake chromatic aberration
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Chromasep.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.ColorGradeSimple">
            <summary>
            weighting of color channels
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.ColorGradeSimple.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.CRT">
            <summary>
            crt/barrel distortion
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.CRT.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Desaturate">
            <summary>
            desaturation and tinting
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Desaturate.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.DMG">
            <summary>
            Gameboy and other four color palettes
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.DMG.GameBoyPalette.Default">
            <summary>
            Default color palette. Source: http://en.wikipedia.org/wiki/List_of_video_game_console_palettes#Original_Game_Boy
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.DMG.GameBoyPalette.DarkYellow">
            <summary>
            Hardcore color profiles. Source: http://www.hardcoregaming101.net/gbdebate/gbcolours.htm
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.DMG.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.FastGaussianBlur">
            <summary>
            faster Gaussian blurring
            <para>Bilinear Gaussian blur filter as detailed here: http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</para>
            <para>Produces near identical results to a standard Gaussian blur by using sub-pixel sampling, this allows us to do ~1/2 the number of pixel lookups.</para>
            <para>unroll convolution loop</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.FastGaussianBlur.Taps">
            <summary>
            Number of effective samples to take per pass. e.g. 3-tap is the current pixel and the neighbors each side.
            <para>More taps = larger blur, but slower.</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.FastGaussianBlur.Offset">
            <summary>
            <para>Offset of each tap.</para>
            <para>For highest quality this should be &lt;= 1 but if the image has low entropy we can approximate the blur with a number &gt; 1 and less taps, for better performance.</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.FastGaussianBlur.Type">
            <summary>
            <para>Offset type, either 'weighted' or 'center'.</para>
            <para>'weighted' gives a more accurate gaussian decay but can introduce modulation for high frequency details.</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.FastGaussianBlur.Sigma">
            <summary>
            <para>Sigma value for gaussian distribution. You don't normally need to set this.</para>
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.FilmGrain">
            <summary>
            image noise
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.GaussianBlur">
            <summary>
            gaussian blur
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Glow">
            <summary>
            aka (light bloom)
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Godsray">
            <summary>
            aka light scattering
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Pixelate">
            <summary>
            sub-sampling (for that indie look)
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Posterize">
            <summary>
            restrict number of colors
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Scanlines">
            <summary>
            horizontal lines
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Sketch">
            <summary>
            simulate pencil drawings
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Vignette">
            <summary>
            shadow in the corners
            </summary>
        </member>
        <member name="M:Love.Misc.TransformStack.Clear">
            <summary>
            remove all transform
            </summary>
        </member>
        <member name="M:Love.Misc.TransformStack.Vector2Transform(Love.Vector2@,Love.Matrix44@,Love.Vector2@)">
            <summary>
            Creates a new <see cref="T:Love.Vector2"/> that contains a transformation of 2d-vector by the specified <see cref="!:Matrix"/>.
            </summary>
            <param name="position">Source <see cref="T:Love.Vector2"/>.</param>
            <param name="matrix">The transformation <see cref="!:Matrix"/>.</param>
            <param name="result">Transformed <see cref="T:Love.Vector2"/> as an output parameter.</param>
        </member>
        <member name="T:Love.RectangBoost">
            <summary>
            the extend class of RectangleF
            </summary>
        </member>
        <member name="M:Love.RectangBoost.DefVerticalCenter(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new vertical center
            </summary>
            <param name="r"></param>
            <param name="verticalCenter">the new vertical center</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefHorizontalCenter(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new horizontal center
            </summary>
            <param name="r"></param>
            <param name="horizontalCenter">the new horizontal center</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefCenter(Love.RectangleF,Love.Vector2)">
            <summary>
            Generate a new RectangleF with new center
            </summary>
            <param name="r"></param>
            <param name="pos">the center</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefCenter(Love.RectangleF,System.Single,System.Single)">
            <summary>
            Generate a new RectangleF with new center
            </summary>
            <param name="r"></param>
            <param name="vertical">vertical of the center</param>
            <param name="horizontal">horizontal of the center</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefLocation(Love.RectangleF,Love.Vector2)">
            <summary>
            Generate a new RectangleF with new Location
            </summary>
            <param name="r"></param>
            <param name="pos">Location of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefLocation(Love.RectangleF,System.Single,System.Single)">
            <summary>
            Generate a new RectangleF with new Location
            </summary>
            <param name="r"></param>
            <param name="x">the x of the Location of the new RectangleF</param>
            <param name="y">the y of the Location of the new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.Center(Love.RectangleF)">
            <summary>
            get the center of the RectangleF
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefLeft(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new left
            </summary>
            <param name="r"></param>
            <param name="left">left of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefRight(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new right
            </summary>
            <param name="r"></param>
            <param name="right">right of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefWidthLeft(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new width on the left part of old rectangle
            </summary>
            <param name="r"></param>
            <param name="width">width of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefWidthRight(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new width on the right part of old rectangle
            </summary>
            <param name="r"></param>
            <param name="width">width of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefHeightTop(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new hgithon the top part of old rectangle
            </summary>
            <param name="r"></param>
            <param name="height">hgith of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefHeightBottom(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new height the bottom part of old rectangle
            </summary>
            <param name="r"></param>
            <param name="height">hgith of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefTop(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new top
            </summary>
            <param name="r"></param>
            <param name="top">top of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefBottom(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with new bottom
            </summary>
            <param name="r"></param>
            <param name="bottom">bottom of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DefPadding(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with padding
            </summary>
            <param name="r"></param>
            <param name="padding">padding of new RectangleF</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.Padding(Love.RectangleF,System.Single,System.Single)">
            <summary>
            Generate a new RectangleF with precent padding
            </summary>
            <param name="r"></param>
            <param name="paddingScaleX">the x of precent padding of new RectangleF to use</param>
            <param name="paddingScaleY">the y of precent padding of new RectangleF to use</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.Padding(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with precent padding
            </summary>
            <param name="r"></param>
            <param name="paddingScale">precent padding of new RectangleF to use</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.Top(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with top part of the original rect.
            </summary>
            <param name="r"></param>
            <param name="precent">precent to use</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.Bottom(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with bottom part of the original rect.
            </summary>
            <param name="r"></param>
            <param name="precent">precent to use</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.Left(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with left part of the original rect.
            </summary>
            <param name="r"></param>
            <param name="precent">precent to use</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.Right(Love.RectangleF,System.Single)">
            <summary>
            Generate a new RectangleF with right part of the original rect.
            </summary>
            <param name="r"></param>
            <param name="precent">precent to use</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.SplitX(Love.RectangleF,System.Int32,System.Int32)">
            <summary>
            Splits a RectangleF horizontally into the specified number of sub-rects, and returns a sub-rect for the specified index.
            </summary>
            <param name="r"></param>
            <param name="count">The amount of subrects the RectangleF should be split into.</param>
            <param name="index">The index for the subrect. Includes 0, and excludes count.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.SplitY(Love.RectangleF,System.Int32,System.Int32)">
            <summary>
            Splits a RectangleF vertically into the specified number of sub-rects, and returns a sub-rect for the specified index.
            </summary>
            <param name="r"></param>
            <param name="count">The amount of subrects the RectangleF should be split into.</param>
            <param name="index">The index for the subrect. Includes 0, and excludes count.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.SplitCenter(Love.RectangleF,System.Single,System.Single)">
            <summary>
            Generate a new RectangleF with center part of the original rect.
            </summary>
            <param name="r"></param>
            <param name="horizontal">the horizontal part of original rect</param>
            <param name="vertical">the vertical part of original rect</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.Grid(Love.RectangleF,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Splits a RectangleF into a grid from left to right and then down.
            </summary>
            <param name="r"></param>
            <param name="widthCount"> The width of a grid cell.</param>
            <param name="heightCount"> The height of a grid cell.</param>
            <param name="column">The x of the grid cell.</param>
            <param name="row">The y of the grid cell.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.ExtendRight(Love.RectangleF,System.Single)">
            <summary>
            Returns a RectangleF that has been expanded by the specified amount.
            </summary>
            <param name="r"></param>
            <param name="scale">The desired prcent of expansion on the right.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.ExtendLeft(Love.RectangleF,System.Single)">
            <summary>
            Returns a RectangleF that has been expanded by the specified amount.
            </summary>
            <param name="r"></param>
            <param name="scale">The desired prcent of expansion on the left.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.ExtendTop(Love.RectangleF,System.Single)">
            <summary>
            Returns a RectangleF that has been expanded by the specified amount.
            </summary>
            <param name="r"></param>
            <param name="scale">The desired prcent of expansion on the top.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.ExtendBottom(Love.RectangleF,System.Single)">
            <summary>
            Returns a RectangleF that has been expanded by the specified amount.
            </summary>
            <param name="r"></param>
            <param name="scale">The desired prcent of expansion on the bottom.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.ExtendHorizontal(Love.RectangleF,System.Single)">
            <summary>
            Returns a RectangleF that has been expanded by the specified amount.
            </summary>
            <param name="r"></param>
            <param name="scale">The desired prcent of expansion on the horizontal.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.ExtendVertical(Love.RectangleF,System.Single)">
            <summary>
            Returns a RectangleF that has been expanded by the specified amount.
            </summary>
            <param name="r"></param>
            <param name="scale">The desired prcent of expansion on the vertical.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.DiagonalLength(Love.RectangleF)">
            <summary>
            get the diagonal length of the RectangleF
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.FloorToRectangle(Love.RectangleF)">
            <summary>
            Returns a Rectangle that Floor each part of RectangleF.
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.CeilToRectangle(Love.RectangleF)">
            <summary>
            Returns a Rectangle that Ceil each part of RectangleF.
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Love.RectangBoost.RoundToRectangle(Love.RectangleF)">
            <summary>
            Returns a Rectangle that Round each part of RectangleF.
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="T:Love.Event">
            <summary>
            <para>Manages events, like keypresses.</para>
            </summary>
        </member>
        <member name="M:Love.Event.Quit(System.Int32)">
            <summary>
            Direct exits the LÖVE program.
            <para>Adds the quit event to the queue.</para>
            <para>The quit event is a signal for the event handler to close LÖVE. It's possible to abort the exit process with the love.quit callback.</para>
            </summary>
            <param name="exitStatus">The program exit status to use when closing the application.</param>
        </member>
        <member name="M:Love.Event.Poll(Love.Event.EventQueueBox)">
            <summary>
            Handle event queue.
            </summary>
            <param name="scene">event handler</param>
            <returns></returns>
        </member>
        <member name="M:Love.Event.Wait(Love.Event.EventQueueBox)">
            <summary>
            Like <see cref="M:Love.Event.Poll(Love.Event.EventQueueBox)"/>, but blocks until there is an event in the queue.
            </summary>
            <param name="scene">event handler</param>
            <returns></returns>
        </member>
        <member name="M:Love.Event.PollOrWaitReal(Love.Event.EventQueueBox,System.Boolean)">
            <summary>
            poll or wait a event
            </summary>
            <param name="poll_or_wait">True: poll event; False: wait event</param>
            <returns></returns>
        </member>
        <member name="T:Love.Keyboard">
            <summary>
            Provides an interface to the user's keyboard.
            </summary>
        </member>
        <member name="M:Love.Keyboard.Init">
            <summary>
            Initialization module
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Keyboard.SetKeyRepeat(System.Boolean)">
            <summary>
            Enables or disables key repeat for love.keypressed. It is disabled by default.
            <para>The interval between repeats depends on the user's system settings. This function doesn't affect whether <see cref="M:Love.Scene.TextInput(System.String)"/> is called multiple times while a key is held down</para>
            </summary>
            <param name="enable">Whether repeat keypress events should be enabled when a key is held down.</param>
        </member>
        <member name="M:Love.Keyboard.HasKeyRepeat">
            <summary>
            Gets whether key repeat is enabled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Keyboard.IsDown(Love.KeyConstant)">
            <summary>
            Checks whether a certain <see cref="T:Love.KeyConstant"/> is down. Not to be confused with <see cref="M:Love.Scene.KeyPressed(Love.KeyConstant,Love.Scancode,System.Boolean)"/> or <see cref="M:Love.Scene.KeyReleased(Love.KeyConstant,Love.Scancode)"/>.
            </summary>
            <param name="key">The key to check.</param>
            <returns>True if the key is down, false if not.</returns>
        </member>
        <member name="M:Love.Keyboard.IsScancodeDown(Love.Scancode)">
            <summary>
            Checks whether a certain <see cref="T:Love.Scancode"/> is down. Not to be confused with <see cref="M:Love.Scene.KeyPressed(Love.KeyConstant,Love.Scancode,System.Boolean)"/> or <see cref="M:Love.Scene.KeyReleased(Love.KeyConstant,Love.Scancode)"/>.
            <para>Unlike regular KeyConstants, Scancodes are keyboard layout-independent. The scancode "w" is used if the key in the same place as the "w" key on an American keyboard is pressed, no matter what the key is labelled or what the user's operating system settings are.</para>
            </summary>
            <param name="scancode"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Keyboard.GetScancodeFromKey(Love.KeyConstant)">
            <summary>
            Gets the hardware scancode corresponding to the given key.
            <para>Unlike <see cref="T:Love.KeyConstant"/>, <see cref="T:Love.Scancode"/> are keyboard layout-independent. For example the scancode "w" will be generated if the key in the same place as the "w" key on an American keyboard is pressed, no matter what the key is labelled or what the user's operating system settings are.</para>
            <para><see cref="T:Love.Scancode"/> are useful for creating default controls that have the same physical locations on on all systems.</para>
            </summary>
            <param name="key">The key to get the scancode from.</param>
            <returns>The scancode corresponding to the given key, or "unknown" if the given key has no known physical representation on the current system.</returns>
        </member>
        <member name="M:Love.Keyboard.GetKeyFromScancode(Love.Scancode)">
            <summary>
            <para>Gets the key corresponding to the given hardware scancode.</para>
            <para>Unlike <see cref="T:Love.KeyConstant"/>, <see cref="T:Love.Scancode"/> are keyboard layout-independent. For example the scancode "w" will be generated if the key in the same place as the "w" key on an American keyboard is pressed, no matter what the key is labelled or what the user's operating system settings are.</para>
            <para><see cref="T:Love.Scancode"/> are useful for creating default controls that have the same physical locations on on all systems.</para>
            </summary>
            <param name="scancode">The scancode to get the key from.</param>
            <returns>The key corresponding to the given <see cref="T:Love.Scancode"/> , or "unknown" if the <see cref="T:Love.Scancode"/> doesn't map to a KeyConstant on the current system.</returns>
        </member>
        <member name="M:Love.Keyboard.SetTextInput(System.Boolean)">
            <summary>
            <para>Enables or disables text input events. It is enabled by default on Windows, Mac, and Linux, and disabled by default on iOS and Android.</para>
            <para>On touch devices, this shows the system's native on-screen keyboard when it's enabled.</para>
            </summary>
            <param name="enable">Whether text input events should be enabled.</param>
        </member>
        <member name="M:Love.Keyboard.SetTextInput(System.Boolean,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            <para>Enables or disables text input events. It is enabled by default on Windows, Mac, and Linux, and disabled by default on iOS and Android.</para>
            <para>On iOS and Android this variant tells the OS that the specified rectangle is where text will show up in the game, which prevents the system on-screen keyboard from covering the text.</para>
            <para>On touch devices, this shows the system's native on-screen keyboard when it's enabled.</para>
            </summary>
            <param name="enable">Whether text input events should be enabled.</param>
            <param name="x">Text rectangle x position.</param>
            <param name="y">Text rectangle y position.</param>
            <param name="w">Text rectangle width.</param>
            <param name="h">Text rectangle height.</param>
        </member>
        <member name="M:Love.Keyboard.HasTextInput">
            <summary>
            Gets whether key repeat is enabled.
            </summary>
            <returns>Whether key repeat is enabled.</returns>
        </member>
        <member name="M:Love.Keyboard.Step">
            <summary>
            Internal clled when call Boot.Run() for <see cref="M:Love.Keyboard.IsPressed(Love.KeyConstant)"/> and <see cref="M:Love.Keyboard.IsReleased(Love.KeyConstant)"/> .......
            </summary>
        </member>
        <member name="M:Love.Keyboard.IsPressed(Love.KeyConstant)">
            <summary>
            Checks whether a certain key is pressed.
            </summary>
            <param name="key">The key to check.</param>
        </member>
        <member name="M:Love.Keyboard.IsReleased(Love.KeyConstant)">
            <summary>
            Checks whether a certain key is released.
            </summary>
            <param name="key">The key to check.</param>
        </member>
        <member name="M:Love.KeyboardHelper.IsPressed(Love.KeyConstant)">
            <summary>
            Checks whether a certain key is pressed.
            </summary>
            <param name="key">The key to check.</param>
        </member>
        <member name="M:Love.KeyboardHelper.IsReleased(Love.KeyConstant)">
            <summary>
            Checks whether a certain key is released.
            </summary>
            <param name="key">The key to check.</param>
        </member>
        <member name="T:Love.Lua">
            <summary>
            Provides an interface to lua script.
            </summary>
        </member>
        <member name="M:Love.Lua.RegisterFunction(System.Object,System.String,System.String)">
            <summary>
            register c# function on object, for example Lua.RegisterFunction(typeof(Math), "Cos", "cos"), 
            the you can do  `print(love.sharp.cos(3.14))` in lua code
            </summary>
            <param name="target"></param>
            <param name="functionName"></param>
            <param name="luaName">luaName to use</param>
            <returns></returns>
        </member>
        <member name="P:Love.Lua.IsInit">
            <summary>
            is lua module already init ?
            </summary>
        </member>
        <member name="M:Love.Lua.Load(System.String)">
            <summary>
            init lua moduel automatically, then do the lua file.
            </summary>
            <param name="filepath">file to execute</param>
        </member>
        <member name="M:Love.Lua.LoadFromString(System.String)">
            <summary>
            init lua moduel automatically, then do the lua code.
            </summary>
            <param name="luaCode">code to execute</param>
        </member>
        <member name="M:Love.Lua.Init">
            <summary>
            manual init lua module
            </summary>
        </member>
        <member name="M:Love.Lua.InitInternal(System.IntPtr)">
            <summary>
            initiate lua module
            </summary>
            <param name="luaState">Assigning to internal Lua state, will be injected love function. if it is IntPtr.Zero, lua state will create automatic</param>
        </member>
        <member name="M:Love.Lua.DoString(System.String[])">
            <summary>
            execuate lua code.
            </summary>
            <param name="luaCode">lua code to execuate</param>
        </member>
        <member name="M:Love.Lua.DoString(System.String)">
            <summary>
            execuate lua code.
            </summary>
            <param name="luaCode">lua code to execuate</param>
        </member>
        <member name="M:Love.Lua.DoFile(System.String)">
            <summary>
            execuate lua code with given file path.
            </summary>
            <param name="luaCode">file path to execuate</param>
        </member>
        <member name="M:Love.Lua.Update(System.Single)">
            <summary>
            call love.update(dt)
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:Love.Lua.Draw">
            <summary>
            call love.draw()
            </summary>
        </member>
        <member name="T:Love.Mouse">
            <summary>
            Provides an interface to the user's mouse.
            </summary>
        </member>
        <member name="F:Love.Mouse.LeftButton">
            <summary>
            The mouse left button
            </summary>
        </member>
        <member name="F:Love.Mouse.RightButton">
            <summary>
            The mouse right button
            </summary>
        </member>
        <member name="F:Love.Mouse.MiddleButton">
            <summary>
            The mouse middle button
            </summary>
        </member>
        <member name="F:Love.Mouse.ExtendedButton1">
            <summary>
            The first extended button
            </summary>
        </member>
        <member name="F:Love.Mouse.ExtendedButton2">
            <summary>
            The second extended button
            </summary>
        </member>
        <member name="F:Love.Mouse.ExtendedButton3">
            <summary>
            The third extended button
            </summary>
        </member>
        <member name="F:Love.Mouse.ExtendedButton4">
            <summary>
            The Fourth extended button
            </summary>
        </member>
        <member name="F:Love.Mouse.ExtendedButton5">
            <summary>
            The Fifth extended button
            </summary>
        </member>
        <member name="M:Love.Mouse.NewCursor(Love.ImageData,System.Int32,System.Int32)">
            <summary>
            <para>Creates a new hardware Cursor object from an image file or ImageData.</para>
            <para>Hardware cursors are framerate-independent and work the same way as normal operating system cursors. Unlike drawing an image at the mouse's current coordinates, hardware cursors never have visible lag between when the mouse is moved and when the cursor position updates, even at low framerates.</para>
            <para>The hot spot is the point the operating system uses to determine what was clicked and at what position the mouse cursor is. For example, the normal arrow pointer normally has its hot spot at the top left of the image, but a crosshair cursor might have it in the middle.</para>
            </summary>
            <param name="imageData">The ImageData to use for the new Cursor.</param>
            <param name="hotX">The x-coordinate in the image of the cursor's hot spot.</param>
            <param name="hotY">The y-coordinate in the image of the cursor's hot spot.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetSystemCursor(Love.SystemCursor)">
            <summary>
            <para> Gets a Cursor object representing a system-native hardware cursor. </para>
            <para>Hardware cursors are framerate-independent and work the same way as normal operating system cursors. Unlike drawing an image at the mouse's current coordinates, hardware cursors never have visible lag between when the mouse is moved and when the cursor position updates, even at low framerates.</para>
            </summary>
            <param name="sysctype"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.SetCursor(Love.Cursor)">
            <summary>
            Sets the current mouse cursor. null to set as default cursor.
            </summary>
            <param name="cursor"></param>
        </member>
        <member name="M:Love.Mouse.GetCursor">
            <summary>
            Gets the current Cursor.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.IsCursorSupported">
            <summary>
            Gets whether cursor functionality is supported.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetXDouble">
            <summary>
            Returns the current x-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetYDouble">
            <summary>
            Returns the current y-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetX">
            <summary>
            Returns the current x-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetY">
            <summary>
            Returns the current y-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetPosition(System.Double@,System.Double@)">
            <summary>
            Returns the current x/y-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.SetX(System.Double)">
            <summary>
            Sets the current X position of the mouse.
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Love.Mouse.SetY(System.Double)">
            <summary>
            Sets the current Y position of the mouse.
            </summary>
            <param name="y"></param>
        </member>
        <member name="M:Love.Mouse.SetPosition(System.Double,System.Double)">
            <summary>
            Sets the current X/Y position of the mouse.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Love.Mouse.IsDown(System.Int32)" -->
        <member name="M:Love.Mouse.SetVisible(System.Boolean)">
            <summary>
            Sets the current visibility of the cursor.
            </summary>
            <param name="visible"></param>
        </member>
        <member name="M:Love.Mouse.IsVisible">
            <summary>
            Checks if the cursor is visible.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.SetGrabbed(System.Boolean)">
            <summary>
            Grabs the mouse and confines it to the window.
            </summary>
            <param name="grabbed"></param>
        </member>
        <member name="M:Love.Mouse.IsGrabbed">
            <summary>
            Checks if the mouse is grabbed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.SetRelativeMode(System.Boolean)">
            <summary>
            <para>WARNNING: THIS API NOT STABLE, IT WILL CRASHED! </para>
            <para>Sets whether relative mode is enabled for the mouse. </para>
            <para>When relative mode is enabled, the cursor is hidden and doesn't move when the mouse does, but relative mouse motion events are still generated via love.mousemoved. This lets the mouse move in any direction indefinitely without the cursor getting stuck at the edges of the screen.</para>
            <para>The reported position of the mouse may not be updated while relative mode is enabled, even when relative mouse motion events are generated.</para>
            </summary>
            <param name="enable">True to enable relative mode, false to disable it.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetRelativeMode">
            <summary>
            Gets whether relative mode is enabled for the mouse.
            </summary>
            <returns>True if relative mode is enabled, false if it's disabled.</returns>
        </member>
        <member name="M:Love.Mouse.SetCursor(Love.SystemCursor)">
            <summary>
            Sets the current mouse cursor to system cursor.
            </summary>
            <param name="systemCursor"></param>
        </member>
        <member name="M:Love.Mouse.NewCursor(System.String,System.Int32,System.Int32)">
            <summary>
            <para>Creates a new hardware Cursor object from an image file or ImageData.</para>
            <para>Hardware cursors are framerate-independent and work the same way as normal operating system cursors. Unlike drawing an image at the mouse's current coordinates, hardware cursors never have visible lag between when the mouse is moved and when the cursor position updates, even at low framerates.</para>
            <para>The hot spot is the point the operating system uses to determine what was clicked and at what position the mouse cursor is. For example, the normal arrow pointer normally has its hot spot at the top left of the image, but a crosshair cursor might have it in the middle.</para>
            </summary>
            <param name="filename">Path to the image to use for the new Cursor.</param>
            <param name="hotX">The x-coordinate in the image of the cursor's hot spot.</param>
            <param name="hotY">The y-coordinate in the image of the cursor's hot spot.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetPosition">
            <summary>
            Returns the current position of the mouse.
            </summary>
            <returns>The position of the mouse.</returns>
        </member>
        <member name="T:Love.PowerState">
            <summary>
            The basic state of the system's power supply.
            </summary>
        </member>
        <member name="F:Love.PowerState.Unknow">
            <summary>
            Cannot determine power status.
            </summary>
        </member>
        <member name="F:Love.PowerState.Battery">
            <summary>
            Not plugged in, running on a battery.
            </summary>
        </member>
        <member name="F:Love.PowerState.NoBattery">
            <summary>
            Plugged in, no battery available.
            </summary>
        </member>
        <member name="F:Love.PowerState.Charging">
            <summary>
            Plugged in, charging battery.
            </summary>
        </member>
        <member name="F:Love.PowerState.Charged">
            <summary>
            Plugged in, battery is fully charged.
            </summary>
        </member>
        <member name="F:Love.PowerState.MaxEnum">
            <summary>
            invalid enum
            </summary>
        </member>
        <member name="T:Love.Special">
            <summary>
            Provides access to information about the user's system.
            </summary>
        </member>
        <member name="M:Love.Special.Init">
            <summary>
            Initialization module
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Special.GetOS">
            <summary>
            Gets the current operating system. In general, LÖVE abstracts away the need to know the current operating system, but there are a few cases where it can be useful (especially in combination with os.execute.)
            </summary>
        </member>
        <member name="M:Love.Special.GetProcessorCount">
            <summary>
            Gets the amount of logical processor in the system.
            </summary>
        </member>
        <member name="M:Love.Special.SetClipboardText(System.String)">
            <summary>
            Puts text in the clipboard.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Special.GetClipboardText">
            <summary>
            Gets text from the clipboard.
            </summary>
        </member>
        <member name="M:Love.Special.GetPowerInfo(Love.PowerState@,System.Int32@,System.Int32@)">
            <summary>
            Gets information about the system's power supply.
            </summary>
            <param name="state">The basic state of the power supply.</param>
            <param name="percent">Percentage of battery life left, between 0 and 100. nil if the value can't be determined or there's no battery.</param>
            <param name="seconds">Seconds of battery life left. nil if the value can't be determined or there's no battery.</param>
        </member>
        <member name="M:Love.Special.OpenURL(System.String)">
            <summary>
            Opens a URL with the user's web or file browser.
            </summary>
            <param name="url">The URL to open. Must be formatted as a proper URL.</param>
            <returns>Whether the URL was opened successfully.</returns>
        </member>
        <member name="M:Love.Special.GetWin32Handle">
            <summary>
            Get win32 HANDLE on windows platform
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Point">
            <summary>
               Represents an ordered pair of x and y coordinates that
               define a point in a two-dimensional plane.
            </summary>
        </member>
        <member name="F:Love.Point.Empty">
            <summary>
               Creates a new instance of the <see cref='T:Love.Point'/> class
               with member data left uninitialized.
            </summary>
        </member>
        <member name="M:Love.Point.#ctor(System.Int32,System.Int32)">
            <summary>
               Initializes a new instance of the <see cref='T:Love.Point'/> class
               with the specified coordinates.
            </summary>
        </member>
        <member name="M:Love.Point.#ctor(Love.Size)">
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.Point'/> class
                  from a <see cref='T:System.Drawing.Size'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.#ctor(System.Int32)">
            <summary>
               Initializes a new instance of the Point class using
               coordinates specified by an integer value.
            </summary>
        </member>
        <member name="P:Love.Point.IsEmpty">
            <summary>
               <para>
                  Gets a value indicating whether this <see cref='T:Love.Point'/> is empty.
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.op_Implicit(Love.Point)~Love.Vector2">
            <summary>
               <para>
                  Creates a <see cref='T:Love.Vector2'/> with the coordinates of the specified
               <see cref='T:Love.Point'/> 
            </para>
            </summary>
        </member>
        <member name="M:Love.Point.op_Explicit(Love.Point)~Love.Size">
            <summary>
               <para>
                  Creates a <see cref='T:Love.Size'/> with the coordinates of the specified <see cref='T:Love.Point'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.op_Addition(Love.Point,Love.Size)">
            <summary>
               <para>
                  Translates a <see cref='T:Love.Point'/> by a given <see cref='T:Love.Point'/> .
               </para>
            </summary>        
        </member>
        <member name="M:Love.Point.op_Subtraction(Love.Point,Love.Size)">
            <summary>
               <para>
                  Translates a <see cref='T:Love.Point'/> by the negative of a given <see cref='T:Love.Point'/> .
               </para>
            </summary>        
        </member>
        <member name="M:Love.Point.op_Equality(Love.Point,Love.Point)">
            <summary>
               <para>
                  Compares two <see cref='T:Love.Point'/> objects. The result specifies
                  whether the values of the <see cref='F:Love.Point.X'/> and <see cref='F:Love.Point.Y'/> properties of the two <see cref='T:Love.Point'/>
                  objects are equal.
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.op_Inequality(Love.Point,Love.Point)">
            <summary>
               <para>
                  Compares two <see cref='T:Love.Point'/> objects. The result specifies whether the values
                  of the <see cref='F:Love.Point.X'/> or <see cref='F:Love.Point.Y'/> properties of the two
               <see cref='T:Love.Point'/> 
               objects are unequal.
            </para>
            </summary>
        </member>
        <member name="M:Love.Point.Add(Love.Point,Love.Size)">
            <summary>
               <para>
                  Translates a <see cref='T:Love.Point'/> by a given <see cref='T:Love.Point'/> .
               </para>
            </summary>        
        </member>
        <member name="M:Love.Point.Subtract(Love.Point,Love.Size)">
            <summary>
               <para>
                  Translates a <see cref='T:Love.Point'/> by the negative of a given <see cref='T:Love.Point'/> .
               </para>
            </summary>        
        </member>
        <member name="M:Love.Point.Ceiling(Love.Vector2)">
            <summary>
              Converts a PointF to a Point by performing a ceiling operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Point.Truncate(Love.Vector2)">
            <summary>
              Converts a PointF to a Point by performing a truncate operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Point.Round(Love.Vector2)">
            <summary>
              Converts a PointF to a Point by performing a round operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Point.Equals(System.Object)">
            <summary>
               <para>
                  Specifies whether this <see cref='T:Love.Point'/> contains
                  the same coordinates as the specified <see cref='T:System.Object'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.GetHashCode">
            <summary>
               <para>
                  Returns a hash code.
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.Offset(System.Int32,System.Int32)">
            <summary>
               Translates this <see cref='T:Love.Point'/> by the specified amount.
            </summary>
        </member>
        <member name="M:Love.Point.Offset(Love.Point)">
            <summary>
               Translates this <see cref='T:Love.Point'/> by the specified amount.
            </summary>
        </member>
        <member name="M:Love.Point.ToString">
            <summary>
               <para>
                  Converts this <see cref='T:Love.Point'/>
                  to a human readable
                  string.
               </para>
            </summary>
        </member>
        <member name="T:Love.Quaternion">
            <summary>
            Represents a four dimensional mathematical quaternion.
            </summary>
        </member>
        <member name="F:Love.Quaternion.Zero">
            <summary>
            A <see cref="T:Love.Quaternion"/> with all of its components set to zero.
            </summary>
        </member>
        <member name="F:Love.Quaternion.One">
            <summary>
            A <see cref="T:Love.Quaternion"/> with all of its components set to one.
            </summary>
        </member>
        <member name="F:Love.Quaternion.Identity">
            <summary>
            The identity <see cref="T:Love.Quaternion"/> (0, 0, 0, 1).
            </summary>
        </member>
        <member name="F:Love.Quaternion.X">
            <summary>
            The X component of the quaternion.
            </summary>
        </member>
        <member name="F:Love.Quaternion.Y">
            <summary>
            The Y component of the quaternion.
            </summary>
        </member>
        <member name="F:Love.Quaternion.Z">
            <summary>
            The Z component of the quaternion.
            </summary>
        </member>
        <member name="F:Love.Quaternion.W">
            <summary>
            The W component of the quaternion.
            </summary>
        </member>
        <member name="M:Love.Quaternion.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Quaternion"/> struct.
            </summary>
            <param name="value">The value that will be assigned to all components.</param>
        </member>
        <member name="M:Love.Quaternion.#ctor(Love.Vector4)">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Quaternion"/> struct.
            </summary>
            <param name="value">A vector containing the values with which to initialize the components.</param>
        </member>
        <member name="M:Love.Quaternion.#ctor(Love.Vector3,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Quaternion"/> struct.
            </summary>
            <param name="value">A vector containing the values with which to initialize the X, Y, and Z components.</param>
            <param name="w">Initial value for the W component of the quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.#ctor(Love.Vector2,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Quaternion"/> struct.
            </summary>
            <param name="value">A vector containing the values with which to initialize the X and Y components.</param>
            <param name="z">Initial value for the Z component of the quaternion.</param>
            <param name="w">Initial value for the W component of the quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Quaternion"/> struct.
            </summary>
            <param name="x">Initial value for the X component of the quaternion.</param>
            <param name="y">Initial value for the Y component of the quaternion.</param>
            <param name="z">Initial value for the Z component of the quaternion.</param>
            <param name="w">Initial value for the W component of the quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.#ctor(System.Single[])">
            <summary>
            Initializes a new instance of the <see cref="T:Love.Quaternion"/> struct.
            </summary>
            <param name="values">The values to assign to the X, Y, Z, and W components of the quaternion. This must be an array with four elements.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than four elements.</exception>
        </member>
        <member name="P:Love.Quaternion.IsIdentity">
            <summary>
            Gets a value indicating whether this instance is equivalent to the identity quaternion.
            </summary>
            <value>
            <c>true</c> if this instance is an identity quaternion; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Love.Quaternion.IsNormalized">
            <summary>
            Gets a value indicting whether this instance is normalized.
            </summary>
        </member>
        <member name="P:Love.Quaternion.Angle">
            <summary>
            Gets the angle of the quaternion.
            </summary>
            <value>The quaternion's angle.</value>
        </member>
        <member name="P:Love.Quaternion.Axis">
            <summary>
            Gets the axis components of the quaternion.
            </summary>
            <value>The axis components of the quaternion.</value>
        </member>
        <member name="P:Love.Quaternion.Item(System.Int32)">
            <summary>
            Gets or sets the component at the specified index.
            </summary>
            <value>The value of the X, Y, Z, or W component, depending on the index.</value>
            <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, 2 for the Z component, and 3 for the W component.</param>
            <returns>The value of the component at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 3].</exception>
        </member>
        <member name="M:Love.Quaternion.Conjugate">
            <summary>
            Conjugates the quaternion.
            </summary>
        </member>
        <member name="M:Love.Quaternion.Invert">
            <summary>
            Conjugates and renormalizes the quaternion.
            </summary>
        </member>
        <member name="M:Love.Quaternion.Length">
            <summary>
            Calculates the length of the quaternion.
            </summary>
            <returns>The length of the quaternion.</returns>
            <remarks>
            <see cref="M:Love.Quaternion.LengthSquared"/> may be preferred when only the relative length is needed
            and speed is of the essence.
            </remarks>
        </member>
        <member name="M:Love.Quaternion.LengthSquared">
            <summary>
            Calculates the squared length of the quaternion.
            </summary>
            <returns>The squared length of the quaternion.</returns>
            <remarks>
            This method may be preferred to <see cref="M:Love.Quaternion.Length"/> when only a relative length is needed
            and speed is of the essence.
            </remarks>
        </member>
        <member name="M:Love.Quaternion.Normalize">
            <summary>
            Converts the quaternion into a unit quaternion.
            </summary>
        </member>
        <member name="M:Love.Quaternion.ToArray">
            <summary>
            Creates an array containing the elements of the quaternion.
            </summary>
            <returns>A four-element array containing the components of the quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.Add(Love.Quaternion@,Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Adds two quaternions.
            </summary>
            <param name="left">The first quaternion to add.</param>
            <param name="right">The second quaternion to add.</param>
            <param name="result">When the method completes, contains the sum of the two quaternions.</param>
        </member>
        <member name="M:Love.Quaternion.Add(Love.Quaternion,Love.Quaternion)">
            <summary>
            Adds two quaternions.
            </summary>
            <param name="left">The first quaternion to add.</param>
            <param name="right">The second quaternion to add.</param>
            <returns>The sum of the two quaternions.</returns>
        </member>
        <member name="M:Love.Quaternion.Subtract(Love.Quaternion@,Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Subtracts two quaternions.
            </summary>
            <param name="left">The first quaternion to subtract.</param>
            <param name="right">The second quaternion to subtract.</param>
            <param name="result">When the method completes, contains the difference of the two quaternions.</param>
        </member>
        <member name="M:Love.Quaternion.Subtract(Love.Quaternion,Love.Quaternion)">
            <summary>
            Subtracts two quaternions.
            </summary>
            <param name="left">The first quaternion to subtract.</param>
            <param name="right">The second quaternion to subtract.</param>
            <returns>The difference of the two quaternions.</returns>
        </member>
        <member name="M:Love.Quaternion.Multiply(Love.Quaternion@,System.Single,Love.Quaternion@)">
            <summary>
            Scales a quaternion by the given value.
            </summary>
            <param name="value">The quaternion to scale.</param>
            <param name="scale">The amount by which to scale the quaternion.</param>
            <param name="result">When the method completes, contains the scaled quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.Multiply(Love.Quaternion,System.Single)">
            <summary>
            Scales a quaternion by the given value.
            </summary>
            <param name="value">The quaternion to scale.</param>
            <param name="scale">The amount by which to scale the quaternion.</param>
            <returns>The scaled quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.Multiply(Love.Quaternion@,Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Multiplies a quaternion by another.
            </summary>
            <param name="left">The first quaternion to multiply.</param>
            <param name="right">The second quaternion to multiply.</param>
            <param name="result">When the method completes, contains the multiplied quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.Multiply(Love.Quaternion,Love.Quaternion)">
            <summary>
            Multiplies a quaternion by another.
            </summary>
            <param name="left">The first quaternion to multiply.</param>
            <param name="right">The second quaternion to multiply.</param>
            <returns>The multiplied quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.Negate(Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Reverses the direction of a given quaternion.
            </summary>
            <param name="value">The quaternion to negate.</param>
            <param name="result">When the method completes, contains a quaternion facing in the opposite direction.</param>
        </member>
        <member name="M:Love.Quaternion.Negate(Love.Quaternion)">
            <summary>
            Reverses the direction of a given quaternion.
            </summary>
            <param name="value">The quaternion to negate.</param>
            <returns>A quaternion facing in the opposite direction.</returns>
        </member>
        <member name="M:Love.Quaternion.Barycentric(Love.Quaternion@,Love.Quaternion@,Love.Quaternion@,System.Single,System.Single,Love.Quaternion@)">
            <summary>
            Returns a <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 2D triangle.
            </summary>
            <param name="value1">A <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
            <param name="value2">A <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
            <param name="value3">A <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
            <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
            <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
            <param name="result">When the method completes, contains a new <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of the specified point.</param>
        </member>
        <member name="M:Love.Quaternion.Barycentric(Love.Quaternion,Love.Quaternion,Love.Quaternion,System.Single,System.Single)">
            <summary>
            Returns a <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 2D triangle.
            </summary>
            <param name="value1">A <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
            <param name="value2">A <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
            <param name="value3">A <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
            <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
            <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
            <returns>A new <see cref="T:Love.Quaternion"/> containing the 4D Cartesian coordinates of the specified point.</returns>
        </member>
        <member name="M:Love.Quaternion.Conjugate(Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Conjugates a quaternion.
            </summary>
            <param name="value">The quaternion to conjugate.</param>
            <param name="result">When the method completes, contains the conjugated quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.Conjugate(Love.Quaternion)">
            <summary>
            Conjugates a quaternion.
            </summary>
            <param name="value">The quaternion to conjugate.</param>
            <returns>The conjugated quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.Dot(Love.Quaternion@,Love.Quaternion@,System.Single@)">
            <summary>
            Calculates the dot product of two quaternions.
            </summary>
            <param name="left">First source quaternion.</param>
            <param name="right">Second source quaternion.</param>
            <param name="result">When the method completes, contains the dot product of the two quaternions.</param>
        </member>
        <member name="M:Love.Quaternion.Dot(Love.Quaternion,Love.Quaternion)">
            <summary>
            Calculates the dot product of two quaternions.
            </summary>
            <param name="left">First source quaternion.</param>
            <param name="right">Second source quaternion.</param>
            <returns>The dot product of the two quaternions.</returns>
        </member>
        <member name="M:Love.Quaternion.Exponential(Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Exponentiates a quaternion.
            </summary>
            <param name="value">The quaternion to exponentiate.</param>
            <param name="result">When the method completes, contains the exponentiated quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.Exponential(Love.Quaternion)">
            <summary>
            Exponentiates a quaternion.
            </summary>
            <param name="value">The quaternion to exponentiate.</param>
            <returns>The exponentiated quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.Invert(Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Conjugates and renormalizes the quaternion.
            </summary>
            <param name="value">The quaternion to conjugate and renormalize.</param>
            <param name="result">When the method completes, contains the conjugated and renormalized quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.Invert(Love.Quaternion)">
            <summary>
            Conjugates and renormalizes the quaternion.
            </summary>
            <param name="value">The quaternion to conjugate and renormalize.</param>
            <returns>The conjugated and renormalized quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.Lerp(Love.Quaternion@,Love.Quaternion@,System.Single,Love.Quaternion@)">
            <summary>
            Performs a linear interpolation between two quaternions.
            </summary>
            <param name="start">Start quaternion.</param>
            <param name="end">End quaternion.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
            <param name="result">When the method completes, contains the linear interpolation of the two quaternions.</param>
            <remarks>
            This method performs the linear interpolation based on the following formula.
            <code>start + (end - start) * amount</code>
            Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
            </remarks>
        </member>
        <member name="M:Love.Quaternion.Lerp(Love.Quaternion,Love.Quaternion,System.Single)">
            <summary>
            Performs a linear interpolation between two quaternion.
            </summary>
            <param name="start">Start quaternion.</param>
            <param name="end">End quaternion.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
            <returns>The linear interpolation of the two quaternions.</returns>
            <remarks>
            This method performs the linear interpolation based on the following formula.
            <code>start + (end - start) * amount</code>
            Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
            </remarks>
        </member>
        <member name="M:Love.Quaternion.Logarithm(Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Calculates the natural logarithm of the specified quaternion.
            </summary>
            <param name="value">The quaternion whose logarithm will be calculated.</param>
            <param name="result">When the method completes, contains the natural logarithm of the quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.Logarithm(Love.Quaternion)">
            <summary>
            Calculates the natural logarithm of the specified quaternion.
            </summary>
            <param name="value">The quaternion whose logarithm will be calculated.</param>
            <returns>The natural logarithm of the quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.Normalize(Love.Quaternion@,Love.Quaternion@)">
            <summary>
            Converts the quaternion into a unit quaternion.
            </summary>
            <param name="value">The quaternion to normalize.</param>
            <param name="result">When the method completes, contains the normalized quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.Normalize(Love.Quaternion)">
            <summary>
            Converts the quaternion into a unit quaternion.
            </summary>
            <param name="value">The quaternion to normalize.</param>
            <returns>The normalized quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.RotationAxis(Love.Vector3@,System.Single,Love.Quaternion@)">
            <summary>
            Creates a quaternion given a rotation and an axis.
            </summary>
            <param name="axis">The axis of rotation.</param>
            <param name="angle">The angle of rotation.</param>
            <param name="result">When the method completes, contains the newly created quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.RotationAxis(Love.Vector3,System.Single)">
            <summary>
            Creates a quaternion given a rotation and an axis.
            </summary>
            <param name="axis">The axis of rotation.</param>
            <param name="angle">The angle of rotation.</param>
            <returns>The newly created quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.RotationMatrix(Love.Matrix44@,Love.Quaternion@)">
            <summary>
            Creates a quaternion given a rotation matrix.
            </summary>
            <param name="matrix">The rotation matrix.</param>
            <param name="result">When the method completes, contains the newly created quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.RotationMatrix(Love.Matrix33@,Love.Quaternion@)">
            <summary>
            Creates a quaternion given a rotation matrix.
            </summary>
            <param name="matrix">The rotation matrix.</param>
            <param name="result">When the method completes, contains the newly created quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.LookAtLH(Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Quaternion@)">
            <summary>
            Creates a left-handed, look-at quaternion.
            </summary>
            <param name="eye">The position of the viewer's eye.</param>
            <param name="target">The camera look-at target.</param>
            <param name="up">The camera's up vector.</param>
            <param name="result">When the method completes, contains the created look-at quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.LookAtLH(Love.Vector3,Love.Vector3,Love.Vector3)">
            <summary>
            Creates a left-handed, look-at quaternion.
            </summary>
            <param name="eye">The position of the viewer's eye.</param>
            <param name="target">The camera look-at target.</param>
            <param name="up">The camera's up vector.</param>
            <returns>The created look-at quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.RotationLookAtLH(Love.Vector3@,Love.Vector3@,Love.Quaternion@)">
            <summary>
            Creates a left-handed, look-at quaternion.
            </summary>
            <param name="forward">The camera's forward direction.</param>
            <param name="up">The camera's up vector.</param>
            <param name="result">When the method completes, contains the created look-at quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.RotationLookAtLH(Love.Vector3,Love.Vector3)">
            <summary>
            Creates a left-handed, look-at quaternion.
            </summary>
            <param name="forward">The camera's forward direction.</param>
            <param name="up">The camera's up vector.</param>
            <returns>The created look-at quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.LookAtRH(Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Quaternion@)">
            <summary>
            Creates a right-handed, look-at quaternion.
            </summary>
            <param name="eye">The position of the viewer's eye.</param>
            <param name="target">The camera look-at target.</param>
            <param name="up">The camera's up vector.</param>
            <param name="result">When the method completes, contains the created look-at quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.LookAtRH(Love.Vector3,Love.Vector3,Love.Vector3)">
            <summary>
            Creates a right-handed, look-at quaternion.
            </summary>
            <param name="eye">The position of the viewer's eye.</param>
            <param name="target">The camera look-at target.</param>
            <param name="up">The camera's up vector.</param>
            <returns>The created look-at quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.RotationLookAtRH(Love.Vector3@,Love.Vector3@,Love.Quaternion@)">
            <summary>
            Creates a right-handed, look-at quaternion.
            </summary>
            <param name="forward">The camera's forward direction.</param>
            <param name="up">The camera's up vector.</param>
            <param name="result">When the method completes, contains the created look-at quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.RotationLookAtRH(Love.Vector3,Love.Vector3)">
            <summary>
            Creates a right-handed, look-at quaternion.
            </summary>
            <param name="forward">The camera's forward direction.</param>
            <param name="up">The camera's up vector.</param>
            <returns>The created look-at quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.BillboardLH(Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Quaternion@)">
            <summary>
            Creates a left-handed spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <param name="result">When the method completes, contains the created billboard quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.BillboardLH(Love.Vector3,Love.Vector3,Love.Vector3,Love.Vector3)">
            <summary>
            Creates a left-handed spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <returns>The created billboard quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.BillboardRH(Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Vector3@,Love.Quaternion@)">
            <summary>
            Creates a right-handed spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <param name="result">When the method completes, contains the created billboard quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.BillboardRH(Love.Vector3,Love.Vector3,Love.Vector3,Love.Vector3)">
            <summary>
            Creates a right-handed spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <returns>The created billboard quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.RotationMatrix(Love.Matrix44)">
            <summary>
            Creates a quaternion given a rotation matrix.
            </summary>
            <param name="matrix">The rotation matrix.</param>
            <returns>The newly created quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.RotationYawPitchRoll(System.Single,System.Single,System.Single,Love.Quaternion@)">
            <summary>
            Creates a quaternion given a yaw, pitch, and roll value.
            </summary>
            <param name="yaw">The yaw of rotation.</param>
            <param name="pitch">The pitch of rotation.</param>
            <param name="roll">The roll of rotation.</param>
            <param name="result">When the method completes, contains the newly created quaternion.</param>
        </member>
        <member name="M:Love.Quaternion.RotationYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            Creates a quaternion given a yaw, pitch, and roll value.
            </summary>
            <param name="yaw">The yaw of rotation.</param>
            <param name="pitch">The pitch of rotation.</param>
            <param name="roll">The roll of rotation.</param>
            <returns>The newly created quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.Slerp(Love.Quaternion@,Love.Quaternion@,System.Single,Love.Quaternion@)">
            <summary>
            Interpolates between two quaternions, using spherical linear interpolation.
            </summary>
            <param name="start">Start quaternion.</param>
            <param name="end">End quaternion.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
            <param name="result">When the method completes, contains the spherical linear interpolation of the two quaternions.</param>
        </member>
        <member name="M:Love.Quaternion.Slerp(Love.Quaternion,Love.Quaternion,System.Single)">
            <summary>
            Interpolates between two quaternions, using spherical linear interpolation.
            </summary>
            <param name="start">Start quaternion.</param>
            <param name="end">End quaternion.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
            <returns>The spherical linear interpolation of the two quaternions.</returns>
        </member>
        <member name="M:Love.Quaternion.Squad(Love.Quaternion@,Love.Quaternion@,Love.Quaternion@,Love.Quaternion@,System.Single,Love.Quaternion@)">
            <summary>
            Interpolates between quaternions, using spherical quadrangle interpolation.
            </summary>
            <param name="value1">First source quaternion.</param>
            <param name="value2">Second source quaternion.</param>
            <param name="value3">Third source quaternion.</param>
            <param name="value4">Fourth source quaternion.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of interpolation.</param>
            <param name="result">When the method completes, contains the spherical quadrangle interpolation of the quaternions.</param>
        </member>
        <member name="M:Love.Quaternion.Squad(Love.Quaternion,Love.Quaternion,Love.Quaternion,Love.Quaternion,System.Single)">
            <summary>
            Interpolates between quaternions, using spherical quadrangle interpolation.
            </summary>
            <param name="value1">First source quaternion.</param>
            <param name="value2">Second source quaternion.</param>
            <param name="value3">Third source quaternion.</param>
            <param name="value4">Fourth source quaternion.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of interpolation.</param>
            <returns>The spherical quadrangle interpolation of the quaternions.</returns>
        </member>
        <member name="M:Love.Quaternion.SquadSetup(Love.Quaternion,Love.Quaternion,Love.Quaternion,Love.Quaternion)">
            <summary>
            Sets up control points for spherical quadrangle interpolation.
            </summary>
            <param name="value1">First source quaternion.</param>
            <param name="value2">Second source quaternion.</param>
            <param name="value3">Third source quaternion.</param>
            <param name="value4">Fourth source quaternion.</param>
            <returns>An array of three quaternions that represent control points for spherical quadrangle interpolation.</returns>
        </member>
        <member name="M:Love.Quaternion.op_Addition(Love.Quaternion,Love.Quaternion)">
            <summary>
            Adds two quaternions.
            </summary>
            <param name="left">The first quaternion to add.</param>
            <param name="right">The second quaternion to add.</param>
            <returns>The sum of the two quaternions.</returns>
        </member>
        <member name="M:Love.Quaternion.op_Subtraction(Love.Quaternion,Love.Quaternion)">
            <summary>
            Subtracts two quaternions.
            </summary>
            <param name="left">The first quaternion to subtract.</param>
            <param name="right">The second quaternion to subtract.</param>
            <returns>The difference of the two quaternions.</returns>
        </member>
        <member name="M:Love.Quaternion.op_UnaryNegation(Love.Quaternion)">
            <summary>
            Reverses the direction of a given quaternion.
            </summary>
            <param name="value">The quaternion to negate.</param>
            <returns>A quaternion facing in the opposite direction.</returns>
        </member>
        <member name="M:Love.Quaternion.op_Multiply(System.Single,Love.Quaternion)">
            <summary>
            Scales a quaternion by the given value.
            </summary>
            <param name="value">The quaternion to scale.</param>
            <param name="scale">The amount by which to scale the quaternion.</param>
            <returns>The scaled quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.op_Multiply(Love.Quaternion,System.Single)">
            <summary>
            Scales a quaternion by the given value.
            </summary>
            <param name="value">The quaternion to scale.</param>
            <param name="scale">The amount by which to scale the quaternion.</param>
            <returns>The scaled quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.op_Multiply(Love.Quaternion,Love.Quaternion)">
            <summary>
            Multiplies a quaternion by another.
            </summary>
            <param name="left">The first quaternion to multiply.</param>
            <param name="right">The second quaternion to multiply.</param>
            <returns>The multiplied quaternion.</returns>
        </member>
        <member name="M:Love.Quaternion.op_Equality(Love.Quaternion,Love.Quaternion)">
            <summary>
            Tests for equality between two objects.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Love.Quaternion.op_Inequality(Love.Quaternion,Love.Quaternion)">
            <summary>
            Tests for inequality between two objects.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Love.Quaternion.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Love.Quaternion.ToString(System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="format">The format.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Love.Quaternion.ToString(System.IFormatProvider)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="formatProvider">The format provider.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Love.Quaternion.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="format">The format.</param>
            <param name="formatProvider">The format provider.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Love.Quaternion.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Love.Quaternion.Equals(Love.Quaternion@)">
            <summary>
            Determines whether the specified <see cref="T:Love.Quaternion"/> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:Love.Quaternion"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:Love.Quaternion"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Love.Quaternion.Equals(Love.Quaternion)">
            <summary>
            Determines whether the specified <see cref="T:Love.Quaternion"/> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:Love.Quaternion"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:Love.Quaternion"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Love.Quaternion.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Love.Ray2D.Intersects(Love.Ray2D,Love.RectangleF,Love.Vector2@)">
            <summary>
            Raycast for intersection of rectangle and ray, if any return true.
            <para> modify form this file : https://github.com/erich666/GraphicsGems/blob/master/gems/RayBox.c </para>
            <para> https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms </para>
            <para> https://tavianator.com/fast-branchless-raybounding-box-intersections/ </para>
            </summary>
            <param name="rect">the input rect</param>
            <param name="ray">the ray to raycast</param>
            <param name="result">Intersection of rectangle and ray</param>
            <returns></returns>
        </member>
        <member name="M:Love.Ray2D.Intersects(Love.RectangleF,Love.Vector2@)">
            <summary>
            Raycast for intersection of rectangle and ray, if any return true.
            </summary>
            <param name="rect">the rectangle to test</param>
            <param name="result">the intersection(if any)</param>
            <returns></returns>
        </member>
        <member name="T:Love.Rectangle">
            <summary>
               <para>
                  Stores the location and size of a rectangular region. 
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.Rectangle'/>
                  class with the specified location and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.#ctor(Love.Point,Love.Size)">
            <summary>
               <para>
                  Initializes a new instance of the Rectangle class with the specified location
                  and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.FromLTRB(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
               Creates a new <see cref='T:Love.Rectangle'/> with
               the specified location and size.
            </summary>
        </member>
        <member name="P:Love.Rectangle.Center">
            <summary>
               <para>
                  Gets or sets the center of the rectangle
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Location">
            <summary>
               <para>
                  Gets or sets the coordinates of the
                  upper-left corner of the rectangular region represented by this <see cref='T:Love.Rectangle'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Size">
            <summary>
               Gets or sets the size of this <see cref='T:Love.Rectangle'/>.
            </summary>
        </member>
        <member name="P:Love.Rectangle.Left">
            <summary>
               <para>
                  Gets the x-coordinate of the upper-left corner of the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Top">
            <summary>
               <para>
                  Gets the y-coordinate of the upper-left corner of the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Right">
            <summary>
               <para>
                  Gets the x-coordinate of the lower-right corner of the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Bottom">
            <summary>
               <para>
                  Gets the y-coordinate of the lower-right corner of the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.IsEmpty">
            <summary>
               <para>
                  Tests whether this <see cref='T:Love.Rectangle'/> has a <see cref='F:Love.Rectangle.Width'/>
                  or a <see cref='F:Love.Rectangle.Height'/> of 0.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Equals(System.Object)">
            <summary>
               <para>
                  Tests whether <paramref name="obj"/> is a <see cref='T:Love.Rectangle'/> with
                  the same location and size of this Rectangle.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.op_Equality(Love.Rectangle,Love.Rectangle)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.Rectangle'/>
                  objects have equal location and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.op_Inequality(Love.Rectangle,Love.Rectangle)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.Rectangle'/>
                  objects differ in location or size.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Ceiling(Love.RectangleF)">
            <summary>
              Converts a RectangleF to a Rectangle by performing a ceiling operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Truncate(Love.RectangleF)">
            <summary>
              Converts a RectangleF to a Rectangle by performing a truncate operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Round(Love.RectangleF)">
            <summary>
              Converts a RectangleF to a Rectangle by performing a round operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Contains(System.Int32,System.Int32)">
            <summary>
               <para>
                  Determines if the specified point is contained within the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Contains(Love.Point)">
            <summary>
               <para>
                  Determines if the specified point is contained within the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Contains(Love.Rectangle)">
            <summary>
               <para>
                  Determines if the rectangular region represented by
               <paramref name="rect"/> is entirely contained within the rectangular region represented by 
                  this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Inflate(System.Int32,System.Int32)">
            <summary>
               <para>
                  Inflates this <see cref='T:Love.Rectangle'/>
                  by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Inflate(Love.Size)">
            <summary>
               Inflates this <see cref='T:Love.Rectangle'/> by the specified amount.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Inflate(Love.Rectangle,System.Int32,System.Int32)">
            <summary>
               <para>
                  Creates a <see cref='T:Love.Rectangle'/>
                  that is inflated by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Intersect(Love.Rectangle)">
            <summary>
            Lead this rectangle intersection with other rectangle.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Intersect(Love.Rectangle,Love.Rectangle)">
            <summary>
               Creates a rectangle that represents the intersection between a and
               b. If there is no intersection, null is returned.
            </summary>
        </member>
        <member name="M:Love.Rectangle.IntersectsWith(Love.Rectangle)">
            <summary>
                Determines if this rectangle intersects with rect.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Union(Love.Rectangle,Love.Rectangle)">
            <summary>
               <para>
                  Creates a rectangle that represents the union between a and
                  b.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Offset(Love.Point)">
            <summary>
               <para>
                  Adjusts the location of this rectangle by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Offset(System.Int32,System.Int32)">
            <summary>
               Adjusts the location of this rectangle by the specified amount.
            </summary>
        </member>
        <member name="M:Love.Rectangle.ToString">
            <summary>
               <para>
                  Converts the attributes of this <see cref='T:Love.Rectangle'/> to a
                  human readable string.
               </para>
            </summary>
        </member>
        <member name="T:Love.RectangleF">
            <summary>
               <para>
                  Stores the location and size of a rectangular region.
               </para>
            </summary>
        </member>
        <member name="F:Love.RectangleF.Empty">
            <summary>
               Initializes a new instance of the <see cref='T:Love.RectangleF'/>
               class.
            </summary>
        </member>
        <member name="M:Love.RectangleF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.RectangleF'/>
                  class with the specified location and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.#ctor(Love.Vector2,Love.SizeF)">
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.RectangleF'/>
                  class with the specified location
                  and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.FromLTRB(System.Single,System.Single,System.Single,System.Single)">
            <summary>
               <para>
                  Creates a new <see cref='T:Love.RectangleF'/> with
                  the specified location and size.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Center">
            <summary>
               <para>
                  Gets or sets the center of the rectangle
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Location">
            <summary>
               <para>
                  Gets or sets the coordinates of the upper-left corner of
                  the rectangular region represented by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Size">
            <summary>
               <para>
                  Gets or sets the size of this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Left">
            <summary>
               <para>
                  Gets the x-coordinate of the upper-left corner of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/> .
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Top">
            <summary>
               <para>
                  Gets the y-coordinate of the upper-left corner of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Right">
            <summary>
               <para>
                  Gets the x-coordinate of the lower-right corner of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Bottom">
            <summary>
               <para>
                  Gets the y-coordinate of the lower-right corner of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.IsEmpty">
            <summary>
               <para>
                  Tests whether this <see cref='T:Love.RectangleF'/> has a <see cref='F:Love.RectangleF.Width'/> or a <see cref='F:Love.RectangleF.Height'/> of 0.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Equals(System.Object)">
            <summary>
               <para>
                  Tests whether <paramref name="obj"/> is a <see cref='T:Love.RectangleF'/> with the same location and size of this
               <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.op_Equality(Love.RectangleF,Love.RectangleF)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.RectangleF'/>
                  objects have equal location and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.op_Inequality(Love.RectangleF,Love.RectangleF)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.RectangleF'/>
                  objects differ in location or size.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Contains(System.Single,System.Single)">
            <summary>
               <para>
                  Determines if the specified point is contained within the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Contains(Love.Vector2)">
            <summary>
               <para>
                  Determines if the specified point is contained within the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Contains(Love.RectangleF)">
            <summary>
               <para>
                  Determines if the rectangular region represented by
               <paramref name="rect"/> is entirely contained within the rectangular region represented by 
                  this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.GetHashCode">
            <summary>
               Gets the hash code for this <see cref='T:Love.RectangleF'/>.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Inflate(System.Single,System.Single)">
            <summary>
               <para>
                  Inflates this <see cref='T:Love.Rectangle'/>
                  by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Inflate(Love.SizeF)">
            <summary>
               Inflates this <see cref='T:Love.Rectangle'/> by the specified amount.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Inflate(Love.RectangleF,System.Single,System.Single)">
            <summary>
               <para>
                  Creates a <see cref='T:Love.Rectangle'/>
                  that is inflated by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Intersect(Love.RectangleF)">
            <summary>
            Lead this rectangle intersection with other rectangle.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Intersect(Love.RectangleF,Love.RectangleF)">
            <summary>
               Creates a rectangle that represents the intersection between a and
               b. If there is no intersection, null is returned.
            </summary>
        </member>
        <member name="M:Love.RectangleF.IntersectsWith(Love.RectangleF)">
            <summary>
               Determines if this rectangle intersects with rect.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Union(Love.RectangleF,Love.RectangleF)">
            <summary>
               Creates a rectangle that represents the union between a and
               b.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Offset(Love.Vector2)">
            <summary>
               Adjusts the location of this rectangle by the specified amount.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Offset(System.Single,System.Single)">
            <summary>
               Adjusts the location of this rectangle by the specified amount.
            </summary>
        </member>
        <member name="M:Love.RectangleF.op_Implicit(Love.Rectangle)~Love.RectangleF">
            <summary>
               Converts the specified <see cref='T:Love.Rectangle'/> to a
            <see cref='T:Love.RectangleF'/>.
            </summary>
        </member>
        <member name="M:Love.RectangleF.ToString">
            <summary>
               Converts the <see cref='P:Love.RectangleF.Location'/> and <see cref='P:Love.RectangleF.Size'/> of this <see cref='T:Love.RectangleF'/> to a
               human-readable string.
            </summary>
        </member>
        <member name="T:Love.FileSystem">
            <summary>
            <para>Provides an interface to the user's filesystem.</para>
            <para>This module provides access to files in specific places:</para>
            <para>1. The root folder of the source directory archive / 2. The root folder of the game's save directory.</para>
            <para>Files that are opened for write or append will always be created in the save directory. The same goes for other operations that involve writing to the filesystem, like <see cref="M:Love.FileSystem.CreateDirectory(System.String)"/>.</para>
            <para>It is recommended to set your game's identity first.  You can set it with <see cref="M:Love.FileSystem.SetIdentity(System.String,System.Boolean)"/> as well.</para>
            </summary>
        </member>
        <member name="M:Love.FileSystem.NewFile(System.String,Love.FileMode)">
            <summary>
             File which is created when a user drags and drops an actual file onto the
             LOVE game. Uses C's stdio. Filenames are system-dependent full paths.
            </summary>
            <param name="filename">The filename of the file.</param>
            <param name="fmode_type">The mode to open the file in.</param>
        </member>
        <member name="M:Love.FileSystem.NewDroppedFile(System.String,Love.FileMode)">
            <summary>
             File which is created when a user drags and drops an actual file onto the
             LOVE game. Uses C's stdio. Filenames are system-dependent full paths.
            </summary>
            <param name="filename">The filename of the file.</param>
            <param name="fmode_type">The mode to open the file in.</param>
        </member>
        <member name="M:Love.FileSystem.NewFileData(System.Byte[],System.String)">
            <summary>
            Creates a new FileData object.
            </summary>
            <param name="contents">The contents of the file.</param>
            <param name="filename">The name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.NewFileData(System.String,System.String)">
            <summary>
            Creates a new UTF8 text FileData object. 
            </summary>
            <param name="contents">The contents of the file.</param>
            <param name="filename">The name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.NewFileData(System.String)">
            <summary>
            Creates a new FileData object.
            </summary>
            <param name="filename">The name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.NewFileData(Love.File)">
            <summary>
            Creates a new FileData object.
            </summary>
            <param name="file">The file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Init(System.String)">
            <summary>
            Initializes FileSystem, will be called internally, so should not be used explictly.
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.SetIdentity(System.String,System.Boolean)">
            <summary>
            Sets the write directory for your game. Note that you can only set the name of the folder to store your files in, not the location.
            </summary>
            <param name="path">The new identity that will be used as write directory.</param>
            <param name="append">Whether the identity directory will be searched when reading a filepath before or after the game's source directory and any currently.
            TRUE: results in searching source before searching save directory; FALSE: results in searching game save directory before searching source directorymounted archives.</param>
        </member>
        <member name="M:Love.FileSystem.GetIdentity">
            <summary>
            Gets the write directory name for your game. Note that this only returns the name of the folder to store your files in, not the full path.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.SetSource(System.String)">
            <summary>
            Sets the source of the game, where the code is present. This function can only be called once, and is normally automatically done by LÖVE.
            </summary>
            <param name="path">Absolute path to the game's source folder.</param>
        </member>
        <member name="M:Love.FileSystem.GetSource">
            <summary>
            <para>initially it was .exe folder </para>
            lua version: Returns the full path to the the .love file or directory. If the game is fused to the LÖVE executable, then the executable is returned.
            </summary>
            <returns>The full platform-dependent path of the .love file or directory.</returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.NewFile(System.String,Love.FileMode)">
            <summary>
            Creates a new File object. It needs to be opened before it can be accessed.
            </summary>
            <param name="filename">The filename of the file.</param>
            <param name="fmode_type">The mode to open the file in.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.IsFused">
            <summary>
            <para>Gets whether the game is in fused mode or not.</para>
            <para>If a game is in fused mode, its save directory will be directly in the Appdata directory instead of Appdata/LOVE/. The game will also be able to load C Lua dynamic libraries which are located in the save directory.</para>
            <para>A game is in fused mode if the source .love has been fused to the executable (see Game Distribution), or if "--fused" has been given as a command-line argument when starting the game.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.Mount(System.String,System.String,System.Boolean)">
            <summary>
            Mounts a zip file or folder in the game's save directory for reading. It is also possible to mount love.filesystem.getSourceBaseDirectory if the game is in fused mode.
            </summary>
            <param name="archive">The folder or zip file in the game's save directory to mount.</param>
            <param name="mountpoint">The new path the archive will be mounted to.</param>
            <param name="appendToPath">Whether the archive will be searched when reading a filepath before or after already-mounted archives. This includes the game's source and save directories.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.Unmount(System.String)">
            <summary>
            Unmounts a zip file or folder previously mounted for reading with <see cref="M:Love.FileSystem.PhysicsFS.Mount(System.String,System.String,System.Boolean)"/>.
            </summary>
            <param name="archive">The folder or zip file in the game's save directory which is currently mounted.</param>
            <returns>True if the archive was successfully unmounted, false otherwise.</returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.GetWorkingDirectory">
            <summary>
            Gets the current working directory.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.GetRealDirectory(System.String)">
            <summary>
            <para>Gets the platform-specific absolute path of the directory containing a filepath.</para>
            </summary>
            <param name="filename">The filepath to get the directory of.</param>
            <returns>The platform-specific full path of the directory containing the filepath.</returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.GetInfo(System.String)">
            <summary>
            Gets information about the specified file or directory.
            </summary>
            <param name="path">The file or directory path to check.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.CreateDirectory(System.String)">
            <summary>
            <para>Recursively creates a directory.</para>
            <para>When called with "a/b" it creates both "a" and "a/b", if they don't exist already.</para>
            </summary>
            <param name="name">The directory to create. </param>
            <returns>True if the directory was created, false if not.</returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.Remove(System.String)">
            <summary>
            Removes a file or empty directory.
            </summary>
            <param name="path">The file or directory to remove.</param>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.Read(System.String,System.Int64)">
            <summary>
            Read the contents of a file.
            </summary>
            <param name="filename">The name (and path) of the file. </param>
            <param name="len">How many bytes to read. (-1 means all)</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.Write(System.String,System.Byte[])">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="filename">The name (and path) of the file.(UTF-8 byte need)</param>
            <param name="input">The data to write to the file.</param>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.Append(System.String,System.Byte[])">
            <summary>
            Append data to an existing file.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="input">The data to append to the file.</param>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.GetDirectoryItems(System.String)">
            <summary>
            <para>Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.</para>
            <para>If the path passed to the function exists in the game and the save directory, it will list the files and directories from both places.</para>
            </summary>
            <param name="dir">The directory.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS.AreSymlinksEnabled">
            <summary>
            Gets whether love.filesystem follows symbolic links.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS._GetSourceBaseDirectory">
            <summary>
            <para>no need for C# version</para>
            Returns the full path to the directory containing the .love file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS._GetRequirePath">
            <summary>
            <para>no need for C# version</para>
            Gets the filesystem paths that will be searched when require is called.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.PhysicsFS._SetRequirePath(System.String)">
            <summary>
            <para>no need for C# version</para>
            <para>Sets the filesystem paths that will be searched when require is called.</para>
            <para>The paths string given to this function is a sequence of path templates separated by semicolons. The argument passed to require will be inserted in place of any question mark ("?") character in each template (after the dot characters in the argument passed to require are replaced by directory separators.)</para>
            <para>The paths are relative to the game's source and save directories, as well as any paths mounted with love.filesystem.mount.</para>
            </summary>
            <param name="paths"></param>
        </member>
        <member name="M:Love.FileSystem.GetUserDirectory">
            <summary>
            Returns the path of the user's directory
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetAppdataDirectory">
            <summary>
            Returns the application data directory (could be the same as getUserDirectory)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetSaveDirectory">
            <summary>
            Gets the full path to the designated save directory. This can be useful if you want to use the standard io library (or something else) to read or write in the save directory.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetExecutablePath">
            <summary>
            will be called internally, so should not be used explictly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Append(System.String,System.Byte[])">
            <summary>
            Append data to an existing file.
            </summary>
            <param name="path">The name (and path) of the file.</param>
            <param name="byteArray">The data to append to the file.</param>
        </member>
        <member name="M:Love.FileSystem.Append(System.String,System.String)">
            <summary>
            Append data to an existing file.
            </summary>
            <param name="path">The name (and path) of the file.</param>
            <param name="content">The string to append to the file.</param>
        </member>
        <member name="M:Love.FileSystem.Append(System.String,System.String,System.Text.Encoding)">
            <summary>
            Append data to an existing file.
            </summary>
            <param name="path">The name (and path) of the file.</param>
            <param name="content">The string to append to the file.</param>
            <param name="encoding">string encoding.</param>
        </member>
        <member name="M:Love.FileSystem.CreateDirectory(System.String)">
            <summary>
            <para>Recursively creates a directory.</para>
            <para>When called with "a/b" it creates both "a" and "a/b", if they don't exist already.</para>
            </summary>
            <param name="pathString">The directory to create.</param>
            <returns>True if the directory was created, false if not.</returns>
        </member>
        <member name="M:Love.FileSystem.GetDirectoryItems(System.String)">
            <summary>
            <para>Returns a table with the names of files and subdirectories in the specified path. The array is not sorted in any way; the order is undefined.</para>
            <para>If the path passed to the function exists in the game and the save directory, it will list the files and directories from both places.</para>
            </summary>
            <param name="path">The directory.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetInfo(System.String)">
            <summary>
            Gets information about the specified file or directory.
            </summary>
            <param name="path">The file or directory path to check.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Lines(System.Action{System.String},System.String)">
            <summary>
            Iterate over the lines in a file.
            </summary>
            <param name="lineFunction"></param>
            <param name="path"></param>
        </member>
        <member name="M:Love.FileSystem.Read(System.String)">
            <summary>
            Read the all contents of a file.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Read(System.String,System.Int32)">
            <summary>
            Read the all contents of a file.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="len">How many bytes to read.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Remove(System.String)">
            <summary>
            Removes a file (or directory).
            </summary>
            <param name="path">The file or directory to remove.</param>
        </member>
        <member name="M:Love.FileSystem.Write(System.String,System.Byte[])">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="path">The name (and path) of the file.</param>
            <param name="bytes">The data to write to the file.</param>
        </member>
        <member name="M:Love.FileSystem.Write(System.String,System.String)">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="contents">The string data to write to the file.</param>
        </member>
        <member name="M:Love.FileSystem.Write(System.String,System.String,System.Text.Encoding)">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="contents">The string data to write to the file.</param>
            <param name="encoding">string encodeing</param>
        </member>
        <member name="T:Love.Resource">
            <summary>
            This module will create resource through starndard C# IO,
            this means you can read a png file from path like C:/love-logo.png
            </summary>
        </member>
        <member name="M:Love.Resource.SaveData(System.String,System.Object)">
            <summary>
            Save data to file, object will serialize as binary file.
            </summary>
            <param name="path">path to save</param>
            <param name="obj">object to save</param>
        </member>
        <member name="M:Love.Resource.LoadData``1(System.String)">
            <summary>
            Load data from a file as specify type.
            </summary>
            <typeparam name="T">the data type you want convert</typeparam>
            <param name="path">the path you want to load</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.EncodeToFile(System.String,Love.ImageData,Love.ImageFormat)">
            <summary>
            Encodes the ImageData and writes it to the path.
            </summary>
            <param name="path">The filename to write the file to.</param>
            <param name="imageData">The imageData to write the file to. </param>
            <param name="format">The format to encode the image as.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.EncodeToFile(System.String,Love.Canvas,Love.ImageFormat)">
            <summary>
            Encodes the ImageData and writes it to the path.
            </summary>
            <param name="path">The filename to write the file to.</param>
            <param name="canvas">The canvas to write the file to. </param>
            <param name="format">The format to encode the image as.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.ToImageData(Love.Image)">
            <summary>
            convert image to imageData, it render canvas to `new canvase`, and get the image data form the `new canvas`
            </summary>
        </member>
        <member name="M:Love.Resource.ToImageData(Love.Canvas)">
            <summary>
            convert canvas to imageData, it render canvas to `new canvase`, and get the image data form the `new canvas`
            </summary>
        </member>
        <member name="T:Love.Size">
            Represents a dimension in 2D coordinate space
            <summary>
               Represents the size of a rectangular region
               with an ordered pair of width and height.
            </summary>
        </member>
        <member name="F:Love.Size.Empty">
            <summary>
               Initializes a new instance of the <see cref='T:Love.Size'/> class.
            </summary>
        </member>
        <member name="M:Love.Size.#ctor(Love.Point)">
            Create a new Size object from a point
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.Size'/> class from
                  the specified <see cref='T:System.Drawing.Point'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.#ctor(System.Int32,System.Int32)">
            Create a new Size object of the specified dimension
            <summary>
               Initializes a new instance of the <see cref='T:Love.Size'/> class from
               the specified dimensions.
            </summary>
        </member>
        <member name="M:Love.Size.op_Implicit(Love.Size)~Love.SizeF">
            <summary>
               Converts the specified <see cref='T:Love.Size'/> to a
            <see cref='T:Love.SizeF'/>.
            </summary>
        </member>
        <member name="M:Love.Size.op_Addition(Love.Size,Love.Size)">
            <summary>
               <para>
                  Performs vector addition of two <see cref='T:Love.Size'/> objects.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.op_Subtraction(Love.Size,Love.Size)">
            <summary>
               <para>
                  Contracts a <see cref='T:Love.Size'/> by another <see cref='T:Love.Size'/>
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.op_Multiply(System.Int32,Love.Size)">
            <summary>
            Multiplies a <see cref="T:Love.Size"/> by an <see cref="T:System.Int32"/> producing <see cref="T:Love.Size"/>.
            </summary>
            <param name="left">Multiplier of type <see cref="T:System.Int32"/>.</param>
            <param name="right">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <returns>Product of type <see cref="T:Love.Size"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Multiply(Love.Size,System.Int32)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by an <see cref="T:System.Int32"/> producing <see cref="T:Love.Size"/>.
            </summary>
            <param name="left">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <param name="right">Multiplier of type <see cref="T:System.Int32"/>.</param>
            <returns>Product of type <see cref="T:Love.Size"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Division(Love.Size,System.Int32)">
            <summary>
            Divides <see cref="T:Love.Size"/> by an <see cref="T:System.Int32"/> producing <see cref="T:Love.Size"/>.
            </summary>
            <param name="left">Dividend of type <see cref="T:Love.Size"/>.</param>
            <param name="right">Divisor of type <see cref="T:System.Int32"/>.</param>
            <returns>Result of type <see cref="T:Love.Size"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Multiply(System.Single,Love.Size)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Multiplier of type <see cref="T:System.Single"/>.</param>
            <param name="right">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <returns>Product of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Multiply(Love.Size,System.Single)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <param name="right">Multiplier of type <see cref="T:System.Single"/>.</param>
            <returns>Product of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Division(Love.Size,System.Single)">
            <summary>
            Divides <see cref="T:Love.Size"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Dividend of type <see cref="T:Love.Size"/>.</param>
            <param name="right">Divisor of type <see cref="T:System.Int32"/>.</param>
            <returns>Result of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Equality(Love.Size,Love.Size)">
            <summary>
               Tests whether two <see cref='T:Love.Size'/> objects
               are identical.
            </summary>
        </member>
        <member name="M:Love.Size.op_Inequality(Love.Size,Love.Size)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.Size'/> objects are different.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.op_Explicit(Love.Size)~Love.Point">
            <summary>
               Converts the specified <see cref='T:Love.Size'/> to a
            <see cref='T:System.Drawing.Point'/>.
            </summary>
        </member>
        <member name="P:Love.Size.IsEmpty">
            <summary>
               Tests whether this <see cref='T:Love.Size'/> has zero
               width and height.
            </summary>
        </member>
        <member name="M:Love.Size.Add(Love.Size,Love.Size)">
            Horizontal dimension
            <summary>
               <para>
                  Performs vector addition of two <see cref='T:Love.Size'/> objects.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.Ceiling(Love.SizeF)">
            <summary>
              Converts a SizeF to a Size by performing a ceiling operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Size.Subtract(Love.Size,Love.Size)">
            <summary>
               <para>
                  Contracts a <see cref='T:Love.Size'/> by another <see cref='T:Love.Size'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.Truncate(Love.SizeF)">
            <summary>
              Converts a SizeF to a Size by performing a truncate operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Size.Round(Love.SizeF)">
            <summary>
              Converts a SizeF to a Size by performing a round operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Size.Equals(System.Object)">
            <summary>
               <para>
                  Tests to see whether the specified object is a
               <see cref='T:Love.Size'/> 
               with the same dimensions as this <see cref='T:Love.Size'/>.
            </para>
            </summary>
        </member>
        <member name="M:Love.Size.GetHashCode">
            <summary>
               <para>
                  Returns a hash code.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.ToString">
            <summary>
               <para>
                  Creates a human-readable string that represents this
               <see cref='T:Love.Size'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.Multiply(Love.Size,System.Int32)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by an <see cref="T:System.Int32"/> producing <see cref="T:Love.Size"/>.
            </summary>
            <param name="size">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <param name="multiplier">Multiplier of type <see cref='T:System.Int32'/>.</param>
            <returns>Product of type <see cref="T:Love.Size"/>.</returns>
        </member>
        <member name="M:Love.Size.Multiply(Love.Size,System.Single)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="size">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <param name="multiplier">Multiplier of type <see cref="T:System.Single"/>.</param>
            <returns>Product of type SizeF.</returns>
        </member>
        <member name="T:Love.SizeF">
            Represents a dimension in 2D coordinate space
            <summary>
               <para>
                  Represents the size of a rectangular region
                  with an ordered pair of width and height.
               </para>
            </summary>
        </member>
        <member name="F:Love.SizeF.Empty">
            <summary>
               Initializes a new instance of the <see cref='T:Love.SizeF'/> class.
            </summary>
        </member>
        <member name="M:Love.SizeF.#ctor(Love.SizeF)">
            Create a new SizeF object from another size object
            <summary>
               Initializes a new instance of the <see cref='T:Love.SizeF'/> class
               from the specified existing <see cref='T:Love.SizeF'/>.
            </summary>
        </member>
        <member name="M:Love.SizeF.#ctor(Love.Vector2)">
            Create a new SizeF object from a point
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.SizeF'/> class from
                  the specified <see cref='T:System.Drawing.PointF'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.#ctor(System.Single,System.Single)">
            Create a new SizeF object of the specified dimension
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.SizeF'/> class from
                  the specified dimensions.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.op_Addition(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Performs vector addition of two <see cref='T:Love.SizeF'/> objects.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.op_Subtraction(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Contracts a <see cref='T:Love.SizeF'/> by another <see cref='T:Love.SizeF'/>
               </para>
            </summary>        
        </member>
        <member name="M:Love.SizeF.op_Multiply(System.Single,Love.SizeF)">
            <summary>
            Multiplies <see cref="T:Love.SizeF"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Multiplier of type <see cref="T:System.Single"/>.</param>
            <param name="right">Multiplicand of type <see cref="T:Love.SizeF"/>.</param>
            <returns>Product of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.SizeF.op_Multiply(Love.SizeF,System.Single)">
            <summary>
            Multiplies <see cref="T:Love.SizeF"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Multiplicand of type <see cref="T:Love.SizeF"/>.</param>
            <param name="right">Multiplier of type <see cref="T:System.Single"/>.</param>
            <returns>Product of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.SizeF.op_Division(Love.SizeF,System.Single)">
            <summary>
            Divides <see cref="T:Love.SizeF"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Dividend of type <see cref="T:Love.SizeF"/>.</param>
            <param name="right">Divisor of type <see cref="T:System.Int32"/>.</param>
            <returns>Result of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.SizeF.op_Equality(Love.SizeF,Love.SizeF)">
            <summary>
               Tests whether two <see cref='T:Love.SizeF'/> objects
               are identical.
            </summary>
        </member>
        <member name="M:Love.SizeF.op_Inequality(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.SizeF'/> objects are different.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.op_Explicit(Love.SizeF)~Love.Vector2">
            <summary>
               <para>
                  Converts the specified <see cref='T:Love.SizeF'/> to a
               <see cref='T:System.Drawing.PointF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.SizeF.IsEmpty">
            <summary>
               <para>
                  Tests whether this <see cref='T:Love.SizeF'/> has zero
                  width and height.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.Add(Love.SizeF,Love.SizeF)">
            Horizontal dimension
            <summary>
               <para>
                  Performs vector addition of two <see cref='T:Love.SizeF'/> objects.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.Subtract(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Contracts a <see cref='T:Love.SizeF'/> by another <see cref='T:Love.SizeF'/>
                  .
               </para>
            </summary>        
        </member>
        <member name="M:Love.SizeF.Equals(System.Object)">
            <summary>
               <para>
                  Tests to see whether the specified object is a
               <see cref='T:Love.SizeF'/> 
               with the same dimensions as this <see cref='T:Love.SizeF'/>.
            </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.ToString">
            <summary>
               <para>
                  Creates a human-readable string that represents this
               <see cref='T:Love.SizeF'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.Multiply(Love.SizeF,System.Single)">
            <summary>
            Multiplies <see cref="T:Love.SizeF"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="size">Multiplicand of type <see cref="T:Love.SizeF"/>.</param>
            <param name="multiplier">Multiplier of type <see cref="T:System.Single"/>.</param>
            <returns>Product of type SizeF.</returns>
        </member>
        <member name="F:Love.FileInfo.Size">
            <summary>
            Numbers will be -1 if they cannot be determined.
            </summary>
        </member>
        <member name="F:Love.FileInfo.ModifyTime">
            <summary>
            The file's last modification time in seconds since the unix epoch, or nil if it can't be determined.
            </summary>
        </member>
        <member name="F:Love.FileInfo.Type">
            <summary>
            The type of the object at the path (file, directory, symlink, etc.)
            </summary>
        </member>
        <member name="T:Love.WindowSettings">
            <summary>
            窗口属性
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Fullscreen">
            <summary>
            Fullscreen (true), or windowed (false).
            </summary>
        </member>
        <member name="P:Love.WindowSettings.FullscreenType">
            <summary>
            Choose between "DeskTop" fullscreen or "Exclusive" fullscreen mode 
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Vsync">
            <summary>
            True if LÖVE should wait for vsync, false otherwise.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.MSAA">
            <summary>
            The number of antialiasing samples.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Stencil">
            <summary>
            Whether a stencil buffer should be allocated. If true, the stencil buffer will have 8 bits.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Depth">
            <summary>
            The number of bits in the depth buffer.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Resizable">
            <summary>
            Let the window be user-resizable
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Borderless">
            <summary>
            Remove all border visuals from the window
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Centered">
            <summary>
            True if the window should be centered.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Display">
            <summary>
            The index of the display to show the window in, if multiple monitors are available.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.HighDpi">
            <summary>
            True if high-dpi mode should be used on Retina displays in macOS and iOS. Does nothing on non-Retina displays. Added in 0.9.1.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.MinWidth">
            <summary>
            The minimum width of the window, if it's resizable. Cannot be less than 1.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.MinHeight">
            <summary>
            The minimum height of the window, if it's resizable. Cannot be less than 1.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.UsePosition">
            <summary>
            True if use the position params, false otherwise.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.X">
            <summary>
            The x-coordinate of the window's position in the specified display. Added in 0.9.2.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Refreshrate">
            <summary>
            We don't explicitly set the refresh rate, it's "read-only".
            <para>The refresh rate of the screen's current display mode, in Hz. May be 0 if the value can't be determined. Added in 0.9.2.</para>
            </summary>
        </member>
        <member name="T:Love.MeshAttributeNameAttribute">
            <summary>
            A Mesh must have a "VertexPosition" attribute in order to be drawn, but it can be attached from a different Mesh via Mesh:attachAttribute. checkout: https://love2d.org/wiki/love.graphics.newMesh
            </summary>
        </member>
        <member name="F:Love.MeshAttributeNameAttribute.name">
            <summary>
            Custom named attributes can be accessed in a vertex shader by declaring them as attribute vec4 MyCustomAttributeName; 
            at the top-level of the vertex shader code. The name must match what was specified in the Mesh's vertex format 
            and in the name argument of Mesh:attachAttribute.
            </summary>
        </member>
        <member name="T:Love.MeshFormatDescribe">
            <summary>
            <para>create it by MeshFormatDescribe.New / MeshFormatDescribe.New&lt;T&gt; / MeshFormatDescribe&lt;T&gt;.New </para>
            <para>Each vertex attribute component is initialized to 0 if its data type is "float", or 1 if its data type is "byte". Mesh:setVertices or Mesh:setVertex and Mesh:setDrawRange can be used to specify vertex information once the Mesh is created.</para>
            <para> If the data type of an attribute is "float", components can be in the range 1 to 4, if the data type is "byte" it must be 4. </para>
            <para> If a custom vertex attribute uses the name "VertexPosition", "VertexTexCoord", or "VertexColor", then the vertex data for that vertex attribute will be used for the standard vertex positions, texture coordinates, or vertex colors respectively, when drawing the Mesh.Otherwise a Vertex Shader is required in order to make use of the vertex attribute when the Mesh is drawn. </para>
            </summary>
        </member>
        <member name="M:Love.MeshFormatDescribe.New(System.Collections.Generic.IEnumerable{Love.MeshFormatDescribe.Entry})">
            <summary>
            A Mesh must have a "VertexPosition" attribute in order to be drawn, but it can be attached from a different Mesh via Mesh:attachAttribute. checkout: https://love2d.org/wiki/love.graphics.newMesh
            <para>Custom named attributes can be accessed in a vertex shader by declaring them as attribute vec4 MyCustomAttributeName; at the top-level of the vertex shader code. The name must match what was specified in the Mesh's vertex format and in the name argument of Mesh:attachAttribute.</para>
            </summary>
        </member>
        <member name="M:Love.MeshFormatDescribe.New(Love.MeshFormatDescribe.Entry[])">
            <summary>
            A Mesh must have a "VertexPosition" attribute in order to be drawn, but it can be attached from a different Mesh via Mesh:attachAttribute. checkout: https://love2d.org/wiki/love.graphics.newMesh
            <para>Custom named attributes can be accessed in a vertex shader by declaring them as attribute vec4 MyCustomAttributeName; at the top-level of the vertex shader code. The name must match what was specified in the Mesh's vertex format and in the name argument of Mesh:attachAttribute.</para>
            </summary>
        </member>
        <member name="M:Love.MeshFormatDescribe.New``1">
            <summary>
            A Mesh must have a "VertexPosition" attribute in order to be drawn, but it can be attached from a different Mesh via Mesh:attachAttribute. checkout: https://love2d.org/wiki/love.graphics.newMesh
            <para>use MeshAttributeNameAttribute auto parse MeshFormatDescribe on specified type</para>
            </summary>
        </member>
        <member name="T:Love.MeshFormatDescribe`1">
            <summary>
            describe of custom mesh format, require MeshAttributeNameAttribute
            <para>A Mesh must have a "VertexPosition" attribute in order to be drawn, but it can be attached from a different Mesh via Mesh:attachAttribute. checkout: https://love2d.org/wiki/love.graphics.newMesh</para>
            </summary>
        </member>
        <member name="M:Love.MeshFormatDescribe`1.New">
            <summary>
            A Mesh must have a "VertexPosition" attribute in order to be drawn, but it can be attached from a different Mesh via Mesh:attachAttribute. checkout: https://love2d.org/wiki/love.graphics.newMesh
            <para>use MeshAttributeNameAttribute auto parse MeshFormatDescribe on specified type</para>
            </summary>
        </member>
        <member name="P:Love.MeshFormatDescribe`1.Entries">
            <summary>
            readonly entry array
            </summary>
        </member>
        <member name="P:Love.MeshFormatDescribe`1.ByteCount">
            <summary>
            each btyes in object
            </summary>
        </member>
        <member name="M:Love.MeshFormatDescribe`1.TransToByte(`0[])">
            <summary>
            trans object array to bytes
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Love.MeshFormatDescribe`1.TransToObject(System.Byte[])">
            <summary>
            trans byte array  to  object
            </summary>
        </member>
        <member name="M:Love.MeshFormatDescribe`1.TransToObject(System.Byte[],System.Int32)">
            <summary>
            trans byte array  to  object
            </summary>
        </member>
        <member name="M:Love.MeshFormatDescribe`1.TransToObject(System.Byte[],System.Int32,System.Int32)">
            <summary>
            trans byte array  to  object
            </summary>
        </member>
        <member name="M:Love.RenderTarget.FromCanvas(Love.Canvas,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="canvas"></param>
            <param name="slice">For cubemaps this is the cube face index to render to (between 1 and 6). For Array textures this is the array layer. For volume textures this is the depth slice. 2D canvases should use a value of 1.</param>
            <param name="mipmap">The mipmap level to render to, for Canvases with mipmaps.</param>
            <returns></returns>
        </member>
        <member name="F:Love.RenderTargetInfo.tempDepthFlag">
            <summary>
            for enabling internal depth and stencil buffers if 'depthstencil' isn't used.
            </summary>
        </member>
        <member name="F:Love.RenderTargetInfo.tempStencilFlag">
            <summary>
            for enabling internal depth and stencil buffers if 'depthstencil' isn't used.
            </summary>
        </member>
        <member name="M:Love.UserDataLoveObject.GetUserData``1(``0@)">
            <summary>
            Get data by type. Each type can has one data.
            </summary>
            <typeparam name="T">the key</typeparam>
            <param name="data">The data to get.</param>
            <returns></returns>
        </member>
        <member name="M:Love.UserDataLoveObject.HasUserData``1">
            <summary>
            Query exist data by type. Each type can has one data.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Love.UserDataLoveObject.SetUserData``1(``0)">
            <summary>
            Set user data by type, each type can has one data.
            </summary>
            <typeparam name="T">the key</typeparam>
            <param name="data">The data to set.</param>
        </member>
        <member name="M:Love.UserDataLoveObject.RemoveUserData``1">
            <summary>
            Remove user data by type, each type can has one data.
            </summary>
            <typeparam name="T">the key</typeparam>
        </member>
        <member name="M:Love.UserDataLoveObject.ClearUserData">
            <summary>
            Clear all user data.
            </summary>
        </member>
        <member name="M:Love.UserDataLoveObject.GetUserDataAll">
            <summary>
            Get all exists data.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Body.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Contact.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Fixture.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Shape.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Joint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.World.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Physics.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Physics.NewWorld(System.Single,System.Single,System.Boolean)">
            <summary>
            创建世界
            </summary>
            <param name="gx">水平加速度</param>
            <param name="gy">垂直加速度</param>
            <param name="sleep">是否休眠</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewBody(Love.World,System.Single,System.Single,Love.BodyType)">
            <summary>
            创建物体
            </summary>
            <param name="world">世界对象</param>
            <param name="x">横坐标</param>
            <param name="y">纵坐标</param>
            <param name="bodyType">物体类型</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewFixture(Love.Body,Love.Shape,System.Single)">
            <summary>
            创建夹具
            </summary>
            <param name="body">物体对象</param>
            <param name="shape">形状</param>
            <param name="density">密度</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewCircleShape(System.Single)">
            <summary>
            创建圆形形状
            </summary>
            <param name="radius">半径</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewRectangleShape(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            创建矩形形状
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="w"></param>
            <param name="h"></param>
            <param name="angle">圆角度</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewRectangleShape(System.Single,System.Single)">
            <summary>
            创建矩形形状
            </summary>
            <param name="w"></param>
            <param name="h"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewEdgeShape(Love.Vector2,Love.Vector2)">
            <summary>
            创建边界形状
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewEdgeShape(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewDistanceJoint(Love.Body,Love.Body,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            创建距离关节
            </summary>
            <param name="body1">形状1对象</param>
            <param name="body2">形状2对象</param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="collideConnected">指定两个实体是否应该相互碰撞</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewMouseJoint(Love.Body,System.Single,System.Single)">
            <summary>
            创建鼠标关节
            </summary>
            <param name="body"></param>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewRevoluteJoint(Love.Body,Love.Body,Love.Vector2,System.Boolean)">
            <summary>
            创建旋转关节
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
            <param name="pos">中心点</param>
            <param name="collideConnected">指定两个实体是否应该相互碰撞</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewPrismaticJoint(Love.Body,Love.Body,Love.Vector2,Love.Vector2,Love.Vector2,System.Boolean)">
            <summary>
            创建棱柱关节
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
            <param name="pA">锚点A坐标</param>
            <param name="pB">锚点B坐标</param>
            <param name="angle">轴向量坐标</param>
            <param name="collideConnected">指定两个实体是否应该相互碰撞</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewPulleyJoint(Love.Body,Love.Body,Love.Vector2,Love.Vector2,Love.Vector2,Love.Vector2,System.Single,System.Boolean)">
            <summary>
            创建滑轮关节
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
            <param name="g1">物体1地锚坐标</param>
            <param name="g2"></param>
            <param name="pA">物体1滑轮关节锚点</param>
            <param name="pB"></param>
            <param name="ratio">关节比例</param>
            <param name="collideConnected"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewFrictionJoint(Love.Body,Love.Body,Love.Vector2,Love.Vector2,System.Boolean)">
            <summary>
            创建摩擦关节
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
            <param name="pA">锚点坐标1</param>
            <param name="pB">锚点坐标2</param>
            <param name="collideConnected"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewRopeJoint(Love.Body,Love.Body,Love.Vector2,Love.Vector2,System.Single,System.Boolean)">
            <summary>
            创建绳索关节
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
            <param name="pA"></param>
            <param name="pB"></param>
            <param name="maxLength">距离长度</param>
            <param name="collideConnected">是否碰撞</param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewMotorJoint(Love.Body,Love.Body,System.Single,System.Boolean)">
            <summary>
            创建移动关节
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
            <param name="correctionFactor"></param>
            <param name="collideConnected"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Physics.NewPolygonShape(Love.Vector2[])">
            <summary>
            
            </summary>
            <param name="pointList"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Love.ChainShape.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.CircleShape.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.EdgeShape.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.PolygonShape.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.DistanceJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.FrictionJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.GearJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.MotorJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.MouseJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.PrismaticJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.PulleyJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.RevoluteJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.RopeJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.WeldJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.WheelJoint.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Vector2.Rotate(Love.Vector2,System.Single)">
            <summary>
            Calculate the new position of the point after the counterclockwise rotation angle(degrees).
            </summary>
            <param name="v">the base point</param>
            <param name="degrees">the degrees to rotate</param>
            <returns></returns>
        </member>
        <member name="M:Love.Vector2.RotateRadian(Love.Vector2,System.Single)">
            <summary>
            Calculate the new position of the point after the counterclockwise rotation angle(radin).
            </summary>
            <param name="v">the base point</param>
            <param name="radins">the radian to rotate</param>
            <returns></returns>
        </member>
        <member name="M:Love.Vector2.ScalarProjection(Love.Vector2,Love.Vector2)">
            <summary>
            the scalar projection of a vector a on (or onto) a vector b
            </summary>
        </member>
        <member name="M:Love.Vector2.VectorProjection(Love.Vector2,Love.Vector2)">
            <summary>
            the vector projection of a vector a on (or onto) a vector b
            </summary>
        </member>
        <member name="M:Love.Vector3.ScalarProjection(Love.Vector3,Love.Vector3)">
            <summary>
            the scalar projection of a vector a on (or onto) a vector b
            </summary>
        </member>
        <member name="M:Love.Vector3.VectorProjection(Love.Vector3,Love.Vector3)">
            <summary>
            the vector projection of a vector a on (or onto) a vector b
            </summary>
        </member>
        <member name="M:Love.Vector4.ScalarProjection(Love.Vector4,Love.Vector4)">
            <summary>
            the scalar projection of a vector a on (or onto) a vector b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Love.Vector4.VectorProjection(Love.Vector4,Love.Vector4)">
            <summary>
            the vector projection of a vector a on (or onto) a vector b
            </summary>
        </member>
        <member name="M:Love.DllTool.GetUTF8Bytes(System.String)">
            <summary>
            <para>from C# string[] pass as char** to c language</para>
            </summary>
        </member>
        <member name="T:Love.Common">
            <summary>
            <para></para>
            <para></para>
            </summary>
        </member>
        <member name="M:Love.Common.GetVersion">
            <summary>
            Gets the current running version of LÖVE.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Common.GetVersionCodeName">
            <summary>
            Gets the current running version code of LÖVE.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Timer">
            <summary>
            <para>提供高精度计时功能。</para>
            <para>Provides high-resolution timing functionality.</para>
            </summary>
        </member>
        <member name="P:Love.Timer.StartTime">
            <summary>
            Time when launch the Timer.Init FirstTime
            </summary>
        </member>
        <member name="M:Love.Timer.Step">
            <summary>
            Measures the time between two frames.
            </summary>
        </member>
        <member name="M:Love.Timer.GetDelta">
            <summary>
            Returns the time between the last two frames.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.GetFPS">
            <summary>
            Returns the current frames per second.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.GetAverageDelta">
            <summary>
            Returns the average delta time over the last second.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.Sleep(System.Single)">
            <summary>
            Pauses the current thread for the specified amount of time.
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Love.Timer.GetTime">
            <summary>
            Returns time in seconds since the start of the game.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.GetTime(System.Double@)">
            <summary>
            Returns time in seconds since the start of the game.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.GetTimeRaw">
            <summary>
            Returns the amount of time since some time in the past.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.EnableLimitMaxFPS(System.Single)">
            <summary>
            enable max fps
            </summary>
        </member>
        <member name="M:Love.Timer.DisableLimitMaxFPS">
            <summary>
            disable max fps
            </summary>
        </member>
        <member name="M:Love.Timer.GetSystemTime">
            <summary>
            Returns the time of the system .
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Window">
            <summary>
            <para>用于修改窗口和获取窗口信息。</para>
            <para>Provides an interface for modifying and retrieving information about the program's window.</para>
            </summary>
        </member>
        <member name="M:Love.Window.SetFullscreen(System.Boolean)">
            <summary>
            Enters or exits fullscreen. The display to use when entering fullscreen is chosen based on which display the window is currently in, if multiple monitors are connected.
            </summary>
            <param name="fullscreen">Whether to enter or exit fullscreen mode.</param>
            <returns>True if an attempt to enter fullscreen was successful, false otherwise.</returns>
        </member>
        <member name="M:Love.Window.GetFullscreen">
            <summary>
            Gets whether the window is fullscreen.
            </summary>
            <returns>True if the window is fullscreen, false otherwise.</returns>
        </member>
        <member name="M:Love.Window.GetDisplayCount">
            <summary>
            <para>获取当前显示器的数量。</para>
            Gets the number of connected monitors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetDisplayName(System.Int32)">
            <summary>
            <para>获取显示器的名称。</para>
            <para>Gets the name of a display.</para>
            </summary>
            <param name="displayindex"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetMode(System.Int32,System.Int32,Love.WindowSettings)">
            <summary>
            <para>设置窗口的显示模式和属性。</para>
            <para>如果width或height为0，则setMode将使用桌面的宽度和高度。</para>
            <para>更改显示模式可能会产生副作用：例如，将清除 Canvas 并使用Shader：send发送到着色器的值将被删除。 如果需要，请务必事先保存 Canvas 的内容或之后重新绘制。</para>
            <para>Sets the display mode and properties of the window.</para>
            <para>If width or height is 0, setMode will use the width and height of the desktop.</para>
            <para>Changing the display mode may have side effects: for example, canvases will be cleared and values sent to shaders with Shader:send will be erased. Make sure to save the contents of canvases beforehand or re-draw to them afterward if you need to.</para>
            </summary>
            <param name="width">Display width.</param>
            <param name="height">Display height.</param>
            <param name="flag"></param>
        </member>
        <member name="M:Love.Window.SetMode(Love.WindowSettings)">
            <summary>
            <para>设置窗口的显示模式和属性。</para>
            <para>如果width或height为0，则setMode将使用桌面的宽度和高度。</para>
            <para>更改显示模式可能会产生副作用：例如，将清除 Canvas 并使用Shader：send发送到着色器的值将被删除。 如果需要，请务必事先保存 Canvas 的内容或之后重新绘制。</para>
            <para>Sets the display mode and properties of the window.</para>
            <para>If width or height is 0, setMode will use the width and height of the desktop.</para>
            <para>Changing the display mode may have side effects: for example, canvases will be cleared and values sent to shaders with Shader:send will be erased. Make sure to save the contents of canvases beforehand or re-draw to them afterward if you need to.</para>
            </summary>
            <param name="flag"></param>
        </member>
        <member name="M:Love.Window.GetMode">
            <summary>
            Gets the display mode and properties of the window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetMode(System.Int32@,System.Int32@)">
            <summary>
            Gets the display mode and properties of the window.
            </summary>
            <param name="out_width">Window width.</param>
            <param name="out_height">Window height.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetFullscreenModes(System.Int32)">
            <summary>
            Gets a list of supported fullscreen modes.
            </summary>
            <param name="displayindex">The index of the display, if multiple monitors are available.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetFullscreen(System.Boolean,Love.FullscreenType)">
            <summary>
            Enters or exits fullscreen. The display to use when entering fullscreen is chosen based on which display the window is currently in, if multiple monitors are connected.
            </summary>
            <param name="fullscreen">Whether to enter or exit fullscreen mode.</param>
            <param name="fstype">The type of fullscreen mode to use.</param>
            <returns>True if an attempt to enter fullscreen was successful, false otherwise.</returns>
        </member>
        <member name="M:Love.Window.GetFullscreen(System.Boolean@,Love.FullscreenType@)">
            <summary>
            Gets whether the window is fullscreen.
            </summary>
            <param name="out_fullscreen">True if the window is fullscreen, false otherwise.</param>
            <param name="out_fstype">The type of fullscreen mode used.</param>
        </member>
        <member name="M:Love.Window.IsOpen">
            <summary>
            True if the window is open, false otherwise.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.Close">
            <summary>
            Closes the window. It can be reopened with love.window.setMode.
            <para>love.graphics functions and objects will cause a hard crash of LÖVE if used while the window is closed.</para>
            </summary>
        </member>
        <member name="M:Love.Window.GetDesktopDimensions(System.Int32)">
            <summary>
            Gets the width and height of the desktop.
            </summary>
            <param name="displayIndex">The index of the display, if multiple monitors are available.</param>
        </member>
        <member name="M:Love.Window.SetPosition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the position of the window on the screen.
            </summary>
            <param name="x">The x-coordinate of the window's position.</param>
            <param name="y">The y-coordinate of the window's position.</param>
            <param name="displayindex">The window position is in the coordinate space of the specified display.</param>
        </member>
        <member name="M:Love.Window.GetPosition">
            <summary>
            Gets the position of the window on the screen
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetPosition(System.Int32@)">
            <summary>
            Gets the position of the window on the screen.
            And the index of the display that the window is in.
            </summary>
            <param name="out_displayindex"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetIcon(Love.ImageData)">
            <summary>
            Sets the window icon until the game is quit. Not all operating systems support very large icon images.
            </summary>
            <param name="imagedata">The window icon image.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetIcon">
            <summary>
            The window icon imagedata, or nil if no icon has been set with love.window.setIcon.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetDisplaySleepEnabled(System.Boolean)">
            <summary>
            Sets whether the display is allowed to sleep while the program is running.
            <para>Display sleep is disabled by default. Some types of input(e.g.joystick button presses) might not prevent the display from sleeping, if display sleep is allowed.</para>
            </summary>
            <param name="enable">True to enable system display sleep, false to disable it.</param>
        </member>
        <member name="M:Love.Window.IsDisplaySleepEnabled">
            <summary>
            Gets whether the display is allowed to sleep while the program is running.
            <para>Display sleep is disabled by default. Some types of input (e.g. joystick button presses) might not prevent the display from sleeping, if display sleep is allowed.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetTitle(System.String)">
            <summary>
            Sets the window title.
            <para>Constantly updating the window title can lead to issues on some systems and therefore is discouraged.</para>
            </summary>
            <param name="titleStr">The new window title.</param>
        </member>
        <member name="M:Love.Window.GetTitle">
            <summary>
            Gets the window title.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.HasFocus">
            <summary>
            Checks if the game window has keyboard focus.
            </summary>
            <returns>True if the window has the focus or false if not.</returns>
        </member>
        <member name="M:Love.Window.HasMouseFocus">
            <summary>
            Checks if the game window has mouse focus.
            </summary>
            <returns>True if the window has mouse focus or false if not.</returns>
        </member>
        <member name="M:Love.Window.IsVisible">
            <summary>
            Checks if the game window is visible.
            <para>The window is considered visible if it's not minimized and the program isn't hidden.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetDPIScale">
            <summary>
            <para>Gets the DPI scale factor associated with the window.</para>
            <para>The pixel density inside the window might be greater (or smaller) than the "size" of the window. For example on a retina screen in Mac OS X with the highdpi window flag enabled, the window may take up the same physical size as an 800x600 window, but the area inside the window uses 1600x1200 pixels. love.window.getDPIScale() would return 2.0 in that case.</para>
            <para>The love.window.fromPixels and love.window.toPixels functions can also be used to convert between units.</para>
            <para>The highdpi window flag must be enabled to use the full pixel density of a Retina screen on Mac OS X and iOS. The flag currently does nothing on Windows and Linux, and on Android it is effectively always enabled.</para>
            </summary>
            <returns>The pixel scale factor associated with the window.</returns>
        </member>
        <member name="M:Love.Window.ToPixels(System.Double)">
            <summary>
            <para>Converts a number from density-independent units to pixels.</para>
            <para>The pixel density inside the window might be greater (or smaller) than the "size" of the window. For example on a retina screen in Mac OS X with the highdpi window flag enabled, the window may take up the same physical size as an 800x600 window, but the area inside the window uses 1600x1200 pixels. love.window.getDPIScale() would return 2.0 in that case.</para>
            <para>The love.window.fromPixels and love.window.toPixels functions can also be used to convert between units.</para>
            <para>The highdpi window flag must be enabled to use the full pixel density of a Retina screen on Mac OS X and iOS. The flag currently does nothing on Windows and Linux, and on Android it is effectively always enabled.</para>
            <para>Most LÖVE functions return values and expect arguments in terms of pixels rather than density-independent units.</para>
            </summary>
            <param name="value">A number in density-independent units to convert to pixels.</param>
            <returns>The converted number, in pixels.</returns>
        </member>
        <member name="M:Love.Window.FromPixels(System.Double)">
            <summary>
            <para>Converts a number from pixels to density-independent units.</para>
            <para>The pixel density inside the window might be greater (or smaller) than the "size" of the window. For example on a retina screen in Mac OS X with the highdpi window flag enabled, the window may take up the same physical size as an 800x600 window, but the area inside the window uses 1600x1200 pixels. love.window.getDPIScale() would return 2.0 in that case.</para>
            <para>The love.window.fromPixels and love.window.toPixels functions can also be used to convert between units.</para>
            <para>The highdpi window flag must be enabled to use the full pixel density of a Retina screen on Mac OS X and iOS. The flag currently does nothing on Windows and Linux, and on Android it is effectively always enabled.</para>
            <para>Most LÖVE functions return values and expect arguments in terms of pixels rather than density-independent units.</para>
            </summary>
            <param name="pixelvalue">A number in pixels to convert to density-independent units.</param>
            <returns>The converted number, in density-independent units.</returns>
        </member>
        <member name="M:Love.Window.Minimize">
            <summary>
            <para>Minimizes the window to the system's task bar / dock.</para>
            </summary>
        </member>
        <member name="M:Love.Window.Maximize">
            <summary>
            <para>Makes the window as large as possible.</para>
            <para>This function has no effect if the window isn't resizable, since it essentially programmatically presses the window's "maximize" button.</para>
            </summary>
        </member>
        <member name="M:Love.Window.IsMaximized">
            <summary>
            <para>Gets whether the Window is currently maximized.</para>
            <para>The window can be maximized if it is not fullscreen and is resizable, and either the user has pressed the window's Maximize button or love.window.maximize has been called.</para>
            </summary>
            <returns>True if the window is currently maximized in windowed mode, false otherwise.</returns>
        </member>
        <member name="M:Love.Window.ShowMessageBox(System.String,System.String,Love.MessageBoxType,System.Boolean)">
            <summary>
            Displays a simple message box with a single 'OK' button.
            <para>	This function will pause all execution of the main thread until the user has clicked a button to exit the message box. Calling the function from a different thread may cause love to crash.</para>
            </summary>
            <param name="title">The title of the message box. </param>
            <param name="message">The text inside the message box. </param>
            <param name="msgbox_type">The type of the message box.</param>
            <param name="attachToWindow">Whether the message box should be attached to the love window or free-floating.</param>
            <returns>Whether the message box was successfully displayed.</returns>
        </member>
        <member name="M:Love.Window.ShowMessageBox(System.String,System.String,System.String[],System.Int32,System.Int32,Love.MessageBoxType,System.Boolean)">
            <summary>
            Displays a message box with a customized list of buttons.
            <para>	This function will pause all execution of the main thread until the user has clicked a button to exit the message box. Calling the function from a different thread may cause love to crash.</para>
            </summary>
            <param name="title">The title of the message box.</param>
            <param name="message">The text inside the message box.</param>
            <param name="buttonName"></param>
            <param name="enterButtonIndex"> when the user presses 'enter', which button index should be return </param>
            <param name="escapebuttonIndex"> when the user presses 'escapeb', which button index should be return </param>
            <param name="msgbox_type">The type of the message box.</param>
            <param name="attachToWindow">Whether the message box should be attached to the love window or free-floating.</param>
            <returns>The index of the button pressed by the user. May be 0 if the message box dialog was closed without pressing a button.</returns>
        </member>
        <member name="M:Love.Window.RequestAttention(System.Boolean)">
            <summary>
            Causes the window to request the attention of the user if it is not in the foreground.
            <para>In Windows the taskbar icon will flash, and in OS X the dock icon will bounce.</para>
            </summary>
            <param name="continuous"></param>
        </member>
        <member name="M:Love.Sound.NewDecoder(Love.FileData,System.Int32)">
            <summary>
            Attempts to find a decoder for the encoded sound data in the specified file.
            </summary>
            <param name="fdata">The file data with encoded sound data.</param>
            <param name="buffersize">The size of each decoded chunk, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Sound.NewDecoder(Love.File,System.Int32)">
            <summary>
            Attempts to find a decoder for the encoded sound data in the specified file.
            </summary>
            <param name="file">The file with encoded sound data.</param>
            <param name="buffersize">The size of each decoded chunk, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Sound.NewSoundData(Love.Decoder)">
            <summary>
            <para>Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="decoder">Decode data from this Decoder until EOF.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="M:Love.Sound.NewSoundData(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="samples">Total number of samples.</param>
            <param name="sampleRate">Number of samples per second</param>
            <param name="bits">Bits per sample (8 or 16).</param>
            <param name="channels">Either 1 for mono or 2 for stereo.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="M:Love.Sound.NewDecoder(System.String,System.Int32)">
            <summary>
            Attempts to find a decoder for the encoded sound data in the specified file.
            </summary>
            <param name="filename">The filename of the file with encoded sound data.</param>
            <param name="bufferSize">The size of each decoded chunk, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Sound.NewSoundData(Love.File)">
            <summary>
            <para> Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="file">A File pointing to an audio file.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="M:Love.Sound.NewSoundData(System.String)">
            <summary>
            <para> Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="filename">The file name of the file to load.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="M:Love.Audio.NewSource(Love.Decoder,Love.SourceType)">
            <summary>
            Creates a new Source from a Decoder.
            </summary>
            <param name="decoder">The Decoder to create a Source from.</param>
            <param name="type">Streaming or static source.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.NewSource(Love.SoundData)">
            <summary>
            Sources created from SoundData are always static.
            </summary>
            <param name="sd">The SoundData to create a Source from.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.GetActiveSourceCount">
            <summary>
            Gets the current number of simultaneously playing sources.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.Stop">
            <summary>
            Stops all currently played sources.
            </summary>
        </member>
        <member name="M:Love.Audio.Stop(Love.Source[])">
            <summary>
            Stops specified source.
            </summary>
        </member>
        <member name="M:Love.Audio.Pause">
            <summary>
            Pauses all currently played Sources.
            </summary>
        </member>
        <member name="M:Love.Audio.Pause(Love.Source[])">
            <summary>
            Pauses specific played Sources.
            </summary>
        </member>
        <member name="M:Love.Audio.Play(Love.Source[])">
            <summary>
            Plays the specified Source.
            </summary>
            <param name="sources"></param>
        </member>
        <member name="M:Love.Audio.SetVolume(System.Single)">
            <summary>
            Sets the master volume.
            </summary>
            <param name="v">1.0 is max and 0.0 is off.</param>
        </member>
        <member name="M:Love.Audio.GetVolume">
            <summary>
            Returns the master volume.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.SetPosition(System.Single,System.Single,System.Single)">
            <summary>
            Sets the position of the listener.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Love.Audio.GetPosition">
            <summary>
            Returns the position of the listener.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.SetOrientation(Love.Vector3,Love.Vector3)">
            <summary>
            Sets the orientation of the listener.
            </summary>
            <param name="forward">Forward vector of the listener orientation.</param>
            <param name="up">Up vector of the listener orientation.</param>
        </member>
        <member name="M:Love.Audio.GetOrientation(Love.Vector3@,Love.Vector3@)">
            <summary>
            Returns the orientation of the listener.
            </summary>
            <param name="forward">Forward vector of the listener orientation.</param>
            <param name="up">Up vector of the listener orientation.</param>
        </member>
        <member name="M:Love.Audio.SetVelocity(System.Single,System.Single,System.Single)">
            <summary>
            Sets the velocity of the listener.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Love.Audio.GetVelocity">
            <summary>
            Returns the velocity of the listener.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.SetDopplerScale(System.Single)">
            <summary>
            Sets a global scale factor for doppler effects.
            </summary>
            <param name="scale">The new doppler scale factor. The scale must be greater than 0.</param>
        </member>
        <member name="M:Love.Audio.GetDopplerScale">
            <summary>
            Gets the global scale factor for doppler effects.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.SetDistanceModel(Love.DistanceModel)">
            <summary>
            Sets the distance attenuation model.
            </summary>
            <param name="distancemodel_type"></param>
        </member>
        <member name="M:Love.Audio.GetDistanceModel">
            <summary>
            Returns the distance attenuation model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.NewSource(Love.FileData,Love.SourceType)">
            <summary>
            Creates a new Source from file data. 
            </summary>
            <param name="fdata">The FileData to create a Source from.</param>
            <param name="type">Streaming or static source.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.NewSource(System.String,Love.SourceType)">
            <summary>
            Creates a new Source from file name. 
            </summary>
            <param name="filename">The filepath to the audio file.</param>
            <param name="type">Streaming or static source.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.GetOrientation">
            <summary>
            Returns the orientation of the listener.
            </summary>
            <returns>tuple (Forward vector of the listener orientation, Up vector of the listener orientation.)</returns>
        </member>
        <member name="M:Love.Mathf.Init(System.Int64)">
            <summary>
            
            </summary>
            <param name="seed">Default random seed on Mathf.Random</param>
        </member>
        <member name="M:Love.Mathf.Random(System.Int32,System.Int32)">
            <summary>
            Get uniformly distributed pseudo-random integer within [min, max].
            </summary>
            <param name="min">The minimum possible value it should return.</param>
            <param name="max">The maximum possible value it should return.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.Random(System.Single,System.Single)">
            <summary>
            Get uniformly distributed pseudo-random integer within [min, max].
            </summary>
            <param name="min">The minimum possible value it should return.</param>
            <param name="max">The maximum possible value it should return.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.Random">
            <summary>
            Get uniformly distributed pseudo-random real number within [0, 1].
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.NewRandomGenerator">
            <summary>
            Creates a new RandomGenerator object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.NewBezierCurve(Love.Vector2[])">
            <summary>
            Creates a new BezierCurve object.
            <para>The number of vertices in the control polygon determines the degree of the curve, e.g. three vertices define a quadratic (degree 2) Bézier curve, four vertices define a cubic (degree 3) Bézier curve, etc.</para>
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.Triangulate(Love.Vector2[])">
            <summary>
            Decomposes a simple polygon into triangles.
            </summary>
            <param name="points">Polygon to triangulate. Must not intersect itself.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.IsConvex(Love.Vector2[])">
            <summary>
            <para>Checks whether a polygon is convex.</para>
            <para>PolygonShapes in love.physics, some forms of Meshes, and polygons drawn with love.graphics.polygon must be simple convex polygons.</para>
            </summary>
            <param name="points">The vertices of the polygon as a table in the form of {(x1, y1), (x2, y2), (x3, y3), ...}.</param>
            <returns>Whether the given polygon is convex.</returns>
        </member>
        <member name="M:Love.Mathf.GammaToLinear(System.Single)">
            <summary>
            <para>Converts a color from gamma-space (sRGB) to linear-space (RGB).</para>
            <para>This is useful when doing gamma-correct rendering and you need to do math in linear RGB in the few cases where LÖVE doesn't handle conversions automatically.</para>
            <para>Read more about gamma-correct rendering here(https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch24.html), here(http://filmicgames.com/archives/299), and here(http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/).</para>
            </summary>
            <param name="gama">The sRGB color to convert.</param>
            <returns>The color in gamma RGB space.</returns>
        </member>
        <member name="M:Love.Mathf.LinearToGamma(System.Single)">
            <summary>
            <para>Converts a color from linear-space (RGB) to gamma-space (sRGB). This is useful when storing linear RGB color values in an image, because the linear RGB color space has less precision than sRGB for dark colors, which can result in noticeable color banding when drawing.</para>
            <para>Read more about gamma-correct rendering here(https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch24.html), here(http://filmicgames.com/archives/299), and here(http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/).</para>
            </summary>
            <param name="liner">The RGB color to convert.</param>
            <returns>The color in gamma sRGB space.</returns>
        </member>
        <member name="M:Love.Mathf.Noise(System.Single)">
            <summary>
            <para>Generates Simplex noise from 1 dimension.</para>
            <para>Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.</para>
            <para>Simplex noise(http://en.wikipedia.org/wiki/Simplex_noise) is closely related to Perlin noise(http://en.wikipedia.org/wiki/Perlin_noise). It is widely used for procedural content generation.</para>
            <para>There are many webpages(http://libnoise.sourceforge.net/noisegen/) which discuss Perlin and Simplex noise in detail.</para>
            <para>The return value might be constant if only integer arguments are used. Avoid solely passing in integers, to get varying return values.</para>
            </summary>
            <param name="x">The number used to generate the noise value.</param>
            <returns>The noise value in the range of [0, 1].</returns>
        </member>
        <member name="M:Love.Mathf.Noise(System.Single,System.Single)">
            <summary>
            <para>Generates Simplex noise from 2 dimension.</para>
            <para>Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.</para>
            <para>Simplex noise(http://en.wikipedia.org/wiki/Simplex_noise) is closely related to Perlin noise(http://en.wikipedia.org/wiki/Perlin_noise). It is widely used for procedural content generation.</para>
            <para>There are many webpages(http://libnoise.sourceforge.net/noisegen/) which discuss Perlin and Simplex noise in detail.</para>
            <para>The return value might be constant if only integer arguments are used. Avoid solely passing in integers, to get varying return values.</para>
            </summary>
            <param name="x">The first value of the 2-dimensional vector used to generate the noise value.</param>
            <param name="y">The second value of the 2-dimensional vector used to generate the noise value.</param>
            <returns>The noise value in the range of [0, 1].</returns>
        </member>
        <member name="M:Love.Mathf.Noise(System.Single,System.Single,System.Single)">
            <summary>
            <para>Generates Simplex noise from 3 dimension.</para>
            <para>Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.</para>
            <para>Simplex noise(http://en.wikipedia.org/wiki/Simplex_noise) is closely related to Perlin noise(http://en.wikipedia.org/wiki/Perlin_noise). It is widely used for procedural content generation.</para>
            <para>There are many webpages(http://libnoise.sourceforge.net/noisegen/) which discuss Perlin and Simplex noise in detail.</para>
            <para>The return value might be constant if only integer arguments are used. Avoid solely passing in integers, to get varying return values.</para>
            </summary>
            <param name="x">The first value of the 3-dimensional vector used to generate the noise value.</param>
            <param name="y">The second value of the 3-dimensional vector used to generate the noise value.</param>
            <param name="z">The third value of the 3-dimensional vector used to generate the noise value.</param>
            <returns>The noise value in the range of [0, 1].</returns>
        </member>
        <member name="M:Love.Mathf.Noise(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>Generates Simplex noise from 4 dimension.</para>
            <para>Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.</para>
            <para>Simplex noise(http://en.wikipedia.org/wiki/Simplex_noise) is closely related to Perlin noise(http://en.wikipedia.org/wiki/Perlin_noise). It is widely used for procedural content generation.</para>
            <para>There are many webpages(http://libnoise.sourceforge.net/noisegen/) which discuss Perlin and Simplex noise in detail.</para>
            <para>The return value might be constant if only integer arguments are used. Avoid solely passing in integers, to get varying return values.</para>
            </summary>
            <param name="x">The first value of the 4-dimensional vector used to generate the noise value.</param>
            <param name="y">The second value of the 4-dimensional vector used to generate the noise value.</param>
            <param name="z">The third value of the 4-dimensional vector used to generate the noise value.</param>
            <param name="w">The fourth value of the 4-dimensional vector used to generate the noise value.</param>
            <returns>The noise value in the range of [0, 1].</returns>
        </member>
        <member name="F:Love.Mathf.Deg2Rad">
            <summary>
            Degrees-to-radians conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Deg2Grad">
            <summary>
            Degrees-to-grad conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Epsilon">
            <summary>
            A tiny floating point value.
            </summary>
        </member>
        <member name="F:Love.Mathf.ExponentialE">
            <summary>
            Exponential e.
            </summary>
        </member>
        <member name="F:Love.Mathf.GoldenRatio">
            <summary>
            The golden ratio. Oooooh!
            </summary>
        </member>
        <member name="F:Love.Mathf.Grad2Deg">
            <summary>
            Grad-to-degrees conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Grad2Rad">
            <summary>
            Grad-to-radians conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Infinity">
            <summary>
            A representation of positive infinity.
            </summary>
        </member>
        <member name="F:Love.Mathf.NegativeInfinity">
            <summary>
            A representation of negative infinity.
            </summary>
        </member>
        <member name="F:Love.Mathf.PI">
            <summary>
            The infamous 3.14159265358979... value.
            </summary>
        </member>
        <member name="F:Love.Mathf.Rad2Deg">
            <summary>
            Radians-to-degrees conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Rad2Grad">
            <summary>
            Radians-to-grad conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.TAU">
            <summary>
            The not-so-infamous TAU value.
            </summary>
        </member>
        <member name="M:Love.Mathf.Abs(System.Int32)">
            <summary>
            Returns the absolute value of a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Abs(System.Single)">
            <summary>
            Returns the absolute value of a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Acos(System.Single)">
            <summary>
            Returns the arc-cosine of a - the angle in radians whose cosine is a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Approximately(System.Single,System.Single)">
            <summary>
            Returns if the two values are approximately close to eachother
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.Asin(System.Single)">
            <summary>
            Returns the arc-sine of a - the angle in radians whose sine is a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Atan(System.Single)">
            <summary>
            Returns the arc-tangent of a - the angle in radians whose tangent is a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Atan2(System.Single,System.Single)">
            <summary>
            Returns the angle in radians whose Tan is y/x.
            </summary>
            <param name="y">The y value</param>
            <param name="x">The x value</param>
        </member>
        <member name="M:Love.Mathf.Ceil(System.Single)">
            <summary>
            Returns the smallest integer greater to or equal to a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.CeilToInt(System.Single)">
            <summary>
            Returns the smallest integer greater to or equal to a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamps a value between a minimum int and maximum int value.
            </summary>
            <param name="value">The value</param>
            <param name="min">The minimum value</param>
            <param name="max">The maximum value</param>
        </member>
        <member name="M:Love.Mathf.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamps a value between a minimum float and maximum float value.
            </summary>
            <param name="value">The value</param>
            <param name="min">The minimum value</param>
            <param name="max">The maximum value</param>
        </member>
        <member name="M:Love.Mathf.Clamp01(System.Single)">
            <summary>
            Clamps value between 0 and 1 and returns value.
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Love.Mathf.ClosestPowerOfTwo(System.Int32)">
            <summary>
            Returns the closest power of two to a value.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Cos(System.Single)">
            <summary>
            Returns the cosine of angle f in radians.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Exp(System.Single)">
            <summary>
            Returns e raised to the specified power.
            </summary>
            <param name="power">The power</param>
        </member>
        <member name="M:Love.Mathf.Floor(System.Single)">
            <summary>
            Returns the largest integer smaller to or equal to a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.FloorToInt(System.Single)">
            <summary>
            Returns the largest integer smaller to or equal to a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.IsPowerOfTwo(System.Int32)">
            <summary>
            Returns if the value is powered by two.
            </summary>
            <param name="value">A value</param>
        </member>
        <member name="M:Love.Mathf.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Interpolates between from and to by t. t is clamped between 0 and 1.
            </summary>
            <param name="from">The from value</param>
            <param name="to">The to value</param>
            <param name="t">The t value</param>
        </member>
        <member name="M:Love.Mathf.Log(System.Single)">
            <summary>
            Returns the natural (base e) logarithm of a specified value.
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Love.Mathf.Log10(System.Single)">
            <summary>
            Returns the base 10 logarithm of a specified value.
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Love.Mathf.Max(System.Int32,System.Int32)">
            <summary>
            Returns the largest of two integer values.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.Max(System.Single,System.Single)">
            <summary>
            Returns the largest of two float values.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.Max(System.Int32[])">
            <summary>
            Returns the largest of a set of integer values.
            </summary>
            <param name="values">The set of values</param>
        </member>
        <member name="M:Love.Mathf.Max(System.Single[])">
            <summary>
            Returns the largest of a set of float values.
            </summary>
            <param name="values">The set of values</param>
        </member>
        <member name="M:Love.Mathf.Min(System.Int32,System.Int32)">
            <summary>
            Returns the smaller of two integer values.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.Min(System.Single,System.Single)">
            <summary>
            Returns the smaller of two float values.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.NextPowerOfTwo(System.Int32)">
            <summary>
            Get the next power of two after a value.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Pow(System.Single,System.Single)">
            <summary>
            Returns f raised to power p.
            </summary>
            <param name="f">The value to raise</param>
            <param name="p">The power</param>
        </member>
        <member name="M:Love.Mathf.RoughlyEqual(System.Single,System.Single,System.Single)">
            <summary>
            Compares two floating point values if they are similar.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
            <param name="threshold">The threshold of similarity</param>
            <returns>True if the values are similar, otherwise false.</returns>
        </member>
        <member name="M:Love.Mathf.Round(System.Single)">
            <summary>
            Returns f rounded to the nearest integer.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.Round(System.Single,System.Int32)">
            <summary>
            Rounds a floating-point value to a specified number of fractional digits. 
            </summary>
            <param name="f">The value</param>
            <param name="decimals">The number of fractional digits to round to</param>
        </member>
        <member name="M:Love.Mathf.Round(System.Single,System.Int32,System.MidpointRounding)">
            <summary>
            Rounds a floating-point value to a specified number of fractional digits. A parameter specifies how to round a value if it is midway between two other numbers.
            </summary>
            <param name="f">The value</param>
            <param name="decimals">The number of fractional digits to round to</param>
            <param name="mode">The rounding mode to use</param>
        </member>
        <member name="M:Love.Mathf.RoundToInt(System.Single)">
            <summary>
            Returns f rounded to the nearest integer.
            </summary>
            <param name="f">The value to round</param>
        </member>
        <member name="M:Love.Mathf.RoundToInt(System.Single,System.MidpointRounding)">
            <summary>
             Rounds a floating-point value. A parameter specifies how to round a value if it is midway between two other numbers.
            </summary>
            <param name="f">The value</param>
            <param name="mode">The rounding mode to use</param>
        </member>
        <member name="M:Love.Mathf.Sign(System.Single)">
            <summary>
            Returns the sign of f.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.Sin(System.Single)">
            <summary>
            Returns the sine of angle f in radians.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.Sqrt(System.Single)">
            <summary>
            Returns square root of f.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.Tan(System.Single)">
            <summary>
            Returns the tangent of angle f in radians.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.SmoothStep(System.Single,System.Single,System.Single)">
            <summary>
            Interpolates between min and max with smoothing at the limits.
            This function interpolates between min and max in a similar way to Lerp.
            However, the interpolation will gradually speed up from the start and slow down toward the end.
            This is useful for creating natural-looking animation, fading and other transitions.
            </summary>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.CatmullRom(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Using formula from http://www.mvps.org/directx/articles/catmull/
            </summary>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
            <param name="value4"></param>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="F:Love.Graphics.SystemLimit.PointSize">
            <summary>
            The maximum size of points.
            </summary>
        </member>
        <member name="F:Love.Graphics.SystemLimit.TextureSize">
            <summary>
            The maximum width or height of Images and Canvases.
            </summary>
        </member>
        <member name="F:Love.Graphics.SystemLimit.MultiCanvas">
            <summary>
            The maximum number of simultaneously active canvases (via <see cref="M:Love.Graphics.SetCanvas(Love.RenderTargetInfo)"/>.)
            </summary>
        </member>
        <member name="F:Love.Graphics.SystemLimit.CanvasMSAA">
            <summary>
            The maximum number of antialiasing samples for a Canvas.
            </summary>
        </member>
        <member name="M:Love.Graphics.NewQuad(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            局部区域
            </summary>
            <param name="x">大图中小图左顶点横坐标</param>
            <param name="y">大图中小图左顶点纵坐标</param>
            <param name="w">小图宽度</param>
            <param name="h">小图高度</param>
            <param name="sw">大图宽度</param>
            <param name="sh">大图高度</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewCanvas(System.Int32,System.Int32,Love.Graphics.Settings)">
            <summary>
            Creates a new Canvas.
            <para>This function can be slow if it is called repeatedly, such as from love.update or love.draw. If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <param name="width">The desired width of the Canvas.</param>
            <param name="height">The desired height of the Canvas.</param>
            <returns>A new Canvas with specified width and height.</returns>
        </member>
        <member name="M:Love.Graphics.NewMesh(System.Int32,Love.MeshDrawMode,Love.SpriteBatchUsage)">
            <summary>
            Creates a standard Mesh with the specified number of vertices.
            </summary>
            <param name="count">The total number of vertices the Mesh will use. Each vertex is initialized to position of (0,0), uv of (0,0), color of (1,1,1,1).</param>
            <param name="drawMode">How the vertices are used when drawing. The default mode "fan" is sufficient for simple convex polygons.</param>
            <param name="usage">The expected usage of the Mesh. The specified usage mode affects the Mesh's memory usage and performance.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewVideo(Love.VideoStream,System.Boolean,System.Nullable{System.Single})">
            <summary>
            Creates a new drawable Video. Currently only Ogg Theora video files are supported.
            </summary>
            <param name="videoStream"> a VideoStream object </param>
            <param name="audio">Whether to try to load the video's audio into an audio Source. If not explicitly set to true or false, it will try without causing an error if the video has no audio.</param>
            <param name="dipScale">The DPI scale factor of the video. if it was null, value will be Graphics.GetDPIScale()</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Reset">
            <summary>
            Resets the current graphics settings.
            <para>Calling reset makes the current drawing color white, the current background color black, disables any active Canvas or Shader, and removes any scissor settings. It sets the BlendMode to alpha, enables all color component masks, disables wireframe mode and resets the current graphics transformation to the origin. It also sets both the point and line drawing modes to smooth and their sizes to 1.0.</para>
            </summary>
        </member>
        <member name="M:Love.Graphics.IsActive">
            <summary>
            Gets whether the graphics module is able to be used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.IsGammaCorrect">
            <summary>
            Gets whether gamma-correct rendering is enabled.
            <para></para>
            <para>Not all devices support gamma-correct rendering, in which case it will be automatically disabled and this function will return false. It is supported on desktop systems which have graphics cards that are capable of using OpenGL 3 / DirectX 10, and iOS devices that can use OpenGL ES 3.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetScissor">
            <summary>
            Disables scissor.
            </summary>
        </member>
        <member name="M:Love.Graphics.SetScissor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets scissor.
            <para>The scissor limits the drawing area to a specified rectangle. This affects all graphics calls, including love.graphics.clear.</para>
            <para>The dimensions of the scissor is unaffected by graphical transformations(translate, scale, ...).</para>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="w"></param>
            <param name="h"></param>
        </member>
        <member name="M:Love.Graphics.SetScissor(Love.Rectangle)">
            <summary>
            Sets scissor.
            <para>The scissor limits the drawing area to a specified rectangle. This affects all graphics calls, including love.graphics.clear.</para>
            <para>The dimensions of the scissor is unaffected by graphical transformations(translate, scale, ...).</para>
            </summary>
        </member>
        <member name="M:Love.Graphics.SetScissor(Love.RectangleF)">
            <summary>
            Sets scissor.
            <para>The scissor limits the drawing area to a specified rectangle. This affects all graphics calls, including love.graphics.clear.</para>
            <para>The dimensions of the scissor is unaffected by graphical transformations(translate, scale, ...).</para>
            </summary>
        </member>
        <member name="M:Love.Graphics.IntersectScissor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            设置 scissor 为所给矩形和现有 scissor 的交集（交集肯定还是个矩形）。如果之前没有设置 scissor，则相当于调用 <see cref="M:Love.Graphics.SetScissor"/>
            <para>Sets the scissor to the rectangle created by the intersection of the specified rectangle with the existing scissor.</para>
            <para>The scissor limits the drawing area to a specified rectangle. This affects all graphics calls, including love.graphics.clear.</para>
            <para>The dimensions of the scissor is unaffected by graphical transformations(translate, scale, ...).</para>
            </summary>
            <param name="x">x coordinate of upper left corner.</param>
            <param name="y">y coordinate of upper left corner.</param>
            <param name="w">width of clipping rectangle.</param>
            <param name="h">height of clipping rectangle.</param>
        </member>
        <member name="M:Love.Graphics.IntersectScissor(Love.Rectangle)">
            <summary>
            设置 scissor 为所给矩形和现有 scissor 的交集（交集肯定还是个矩形）。如果之前没有设置 scissor，则相当于调用 <see cref="M:Love.Graphics.SetScissor"/>
            <para>Sets the scissor to the rectangle created by the intersection of the specified rectangle with the existing scissor.</para>
            <para>The scissor limits the drawing area to a specified rectangle. This affects all graphics calls, including love.graphics.clear.</para>
            <para>The dimensions of the scissor is unaffected by graphical transformations(translate, scale, ...).</para>
            </summary>
        </member>
        <member name="M:Love.Graphics.IntersectScissor(Love.RectangleF)">
            <summary>
            设置 scissor 为所给矩形和现有 scissor 的交集（交集肯定还是个矩形）。如果之前没有设置 scissor，则相当于调用 <see cref="M:Love.Graphics.SetScissor"/>
            <para>Sets the scissor to the rectangle created by the intersection of the specified rectangle with the existing scissor.</para>
            <para>The scissor limits the drawing area to a specified rectangle. This affects all graphics calls, including love.graphics.clear.</para>
            <para>The dimensions of the scissor is unaffected by graphical transformations(translate, scale, ...).</para>
            </summary>
        </member>
        <member name="M:Love.Graphics.GetScissor">
            <summary>
            Gets the current scissor box.
            <para> Int4:x The x-component of the top-left point of the box. </para>
            <para> Int4:y The y-component of the top-left point of the box. </para>
            <para> The width of the box. </para>
            <para> The height of the box. </para>
            </summary>
            <returns>
            </returns>
        </member>
        <member name="M:Love.Graphics.SetStencilTest(Love.CompareMode,System.Int32)">
            <summary>
            Configures or disables stencil testing.
            <para>When stencil testing is enabled, the geometry of everything that is drawn afterward will be clipped / stencilled out based on a comparison between the arguments of this function and the stencil value of each pixel that the geometry touches. The stencil values of pixels are affected via Graphics.Stencil.</para>
            </summary>
            <param name="compare_type">The type of comparison to make for each pixel.</param>
            <param name="compareValue">The value to use when comparing with the stencil value of each pixel. </param>
        </member>
        <member name="M:Love.Graphics.GetStencilTest(Love.CompareMode@,System.Int32@)">
            <summary>
            Gets the current stencil test configuration.
            <para>When stencil testing is enabled, the geometry of everything that is drawn afterward will be clipped / stencilled out based on a comparison between the arguments of this function and the stencil value of each pixel that the geometry touches. The stencil values of pixels are affected via Graphics.Stencil.</para>
            <para>Each Canvas has its own per-pixel stencil values.</para>
            </summary>
            <param name="out_compare_type">The type of comparison that is made for each pixel. Will be "always" if stencil testing is disabled.</param>
            <param name="out_compareValue">The value used when comparing with the stencil value of each pixel.</param>
        </member>
        <member name="M:Love.Graphics.SetColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the color used for drawing.
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
        </member>
        <member name="M:Love.Graphics.GetColor">
            <summary>
            Gets the current color.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetBackgroundColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the background color.
            </summary>
            <param name="r">The red component (0-1).</param>
            <param name="g">The green component (0-1).</param>
            <param name="b">The blue component (0-1).</param>
            <param name="a">The alpha component (0-1).</param>
        </member>
        <member name="M:Love.Graphics.SetBackgroundColor(Love.Color)">
            <summary>
            Sets the background color.
            </summary>
            <param name="r">The red component (0-1).</param>
            <param name="g">The green component (0-1).</param>
            <param name="b">The blue component (0-1).</param>
            <param name="a">The alpha component (0-1).</param>
        </member>
        <member name="M:Love.Graphics.GetBackgroundColor">
            <summary>
            Gets the current background color.
            </summary>
        </member>
        <member name="M:Love.Graphics.SetFont(Love.Font)">
            <summary>
            set font used. pass null to use default font
            </summary>
            <param name="font"></param>
        </member>
        <member name="M:Love.Graphics.GetFont">
            <summary>
            Gets the current Font object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetColorMask(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets the color mask. Enables or disables specific color components when rendering.
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
        </member>
        <member name="M:Love.Graphics.GetColorMask(System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Gets the active color components used when drawing. Normally all 4 components are active unless <see cref="M:Love.Graphics.SetColorMask(System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> has been used.
            <para>The color mask determines whether individual components of the colors of drawn objects will affect the color of the screen. They affect <see cref="M:Love.Graphics.Clear(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Single,System.Boolean)"/> as well.</para>
            </summary>
            <param name="out_r">Whether the red color component is active when rendering.</param>
            <param name="out_g">Whether the red green component is active when rendering.</param>
            <param name="out_b">Whether the red blue component is active when rendering.</param>
            <param name="out_a">Whether the red alpha component is active when rendering.</param>
        </member>
        <member name="M:Love.Graphics.SetBlendMode(Love.BlendMode,Love.BlendAlphaMode)">
            <summary>
            Sets the blending mode.
            </summary>
            <param name="blendMode">The blend mode to use.</param>
            <param name="blendAlphaMode">What to do with the alpha of drawn objects when blending.</param>
        </member>
        <member name="M:Love.Graphics.GetBlendMode(Love.BlendMode@,Love.BlendAlphaMode@)">
            <summary>
            Gets the blending mode.
            </summary>
            <param name="out_blendMode_type">The current blend mode.</param>
            <param name="out_blendAlphaMode_type">The current blend alpha mode – it determines how the alpha of drawn objects affects blending.</param>
        </member>
        <member name="M:Love.Graphics.SetDefaultFilter(Love.FilterMode,Love.FilterMode,System.Int32)">
            <summary>
            Sets the default scaling filters used with Images, Canvases, and Fonts.
            </summary>
            <param name="filterModeMagMin_type">Filter mode used when scaling the image down.</param>
            <param name="filterModeMag_type">Filter mode used when scaling the image up.</param>
            <param name="anisotropy">Maximum amount of Anisotropic Filtering used.</param>
        </member>
        <member name="M:Love.Graphics.GetDefaultFilter(Love.FilterMode@,Love.FilterMode@,System.Int32@)">
            <summary>
            Returns the default scaling filters used with Images, Canvases, and Fonts.
            </summary>
            <param name="out_filterModeMagMin_type">Filter mode used when scaling the image down.</param>
            <param name="out_filterModeMag_type">Filter mode used when scaling the image up.</param>
            <param name="out_anisotropy">Maximum amount of Anisotropic Filtering used.</param>
        </member>
        <member name="M:Love.Graphics.SetLineWidth(System.Single)">
            <summary>
            Sets the line width.
            </summary>
            <param name="width"></param>
        </member>
        <member name="M:Love.Graphics.SetLineStyle(Love.LineStyle)">
            <summary>
            Sets the line style.
            </summary>
            <param name="style_type"></param>
        </member>
        <member name="M:Love.Graphics.SetLineJoin(Love.LineJoin)">
            <summary>
            Sets the line join style.
            </summary>
            <param name="join_type"></param>
        </member>
        <member name="M:Love.Graphics.GetLineWidth">
            <summary>
            Gets the current line width.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetLineStyle">
            <summary>
            Gets the line style.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetLineJoin">
            <summary>
            Gets the line join style.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetPointSize(System.Single)">
            <summary>
            Sets the point size.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Love.Graphics.GetPointSize">
            <summary>
            Gets the point size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.IsWireframe">
            <summary>
            是否使用线框模式绘图
            Gets whether wireframe mode is used when drawing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetShader(Love.Shader)">
            <summary>
            Routes drawing operations through a shader.
            </summary>
            <param name="shader"></param>
        </member>
        <member name="M:Love.Graphics.SetShader">
            <summary>
            Disables shaders, allowing unfiltered drawing operations.
            </summary>
        </member>
        <member name="M:Love.Graphics.GetShader">
            <summary>
            Gets the current Shader. Returns null if none is set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetTextureTypes">
            <summary>
            return supported TextureType
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Push(Love.StackType)">
            <summary>
            Copies and pushes the current coordinate transformation to the transformation stack.
            </summary>
            <param name="stack"></param>
        </member>
        <member name="M:Love.Graphics.Pop">
            <summary>
            Pops the current coordinate transformation from the transformation stack.
            This function is always used to reverse a previous <see cref="M:Love.Graphics.Push(Love.StackType)"/> operation. It returns the current transformation state to what it was before the last preceding push.
            </summary>
        </member>
        <member name="M:Love.Graphics.Rotate(System.Single)">
            <summary>
            Rotates the coordinate system in two dimensions.
            <para>Calling this function affects all future drawing operations by rotating the coordinate system around the origin by the given amount of radians. This change lasts until Scene.Draw exits.</para>
            </summary>
            <param name="angle">The amount to rotate the coordinate system in radians.</param>
        </member>
        <member name="M:Love.Graphics.Scale(System.Single,System.Single)">
             <summary>
             <para>以二维方式缩放坐标系。</para>
             <para>默认情况下，LÖVE中的坐标系在水平和垂直方向上一对一显示像素，x轴向右增加，y轴向下增加。 缩放坐标系会改变这种关系。</para>
             <para>在通过sx和sy进行缩放之后，所有坐标都被视为与sx和sy相乘。 绘图操作的每个结果也相应地缩放，例如按（2,2）缩放将意味着在x和y方向上使所有内容都变为两倍。 按负值缩放会使坐标系在相应的方向上翻转，所有内容都会被翻转或颠倒（或两者兼而有之）。 按零缩放没有意义。</para>
             <para>缩放(Scale)操作和平移(Translate)操作不是可交换操作，以不同的顺序调用它们会产生不同的结果。</para>
             <para>效果持续到 Scene.Draw 调用结束（每一帧画面绘制结束都会自动重置为1倍。）</para>
            
             <para>Scales the coordinate system in two dimensions.</para>
             <para>By default the coordinate system in LÖVE corresponds to the display pixels in horizontal and vertical directions one-to-one, and the x-axis increases towards the right while the y-axis increases downwards. Scaling the coordinate system changes this relation.</para>
             <para>After scaling by sx and sy, all coordinates are treated as if they were multiplied by sx and sy. Every result of a drawing operation is also correspondingly scaled, so scaling by (2, 2) for example would mean making everything twice as large in both x- and y-directions. Scaling by a negative value flips the coordinate system in the corresponding direction, which also means everything will be drawn flipped or upside down, or both. Scaling by zero is not a useful operation.</para>
             <para>Scale and translate are not commutative operations, therefore, calling them in different orders will change the outcome.</para>
             <para>Scaling lasts until Scene.Draw exits.</para>
             </summary>
             <param name="sx">The scaling in the direction of the x-axis.</param>
             <param name="sy">The scaling in the direction of the y-axis.</param>
        </member>
        <member name="M:Love.Graphics.Translate(System.Single,System.Single)">
            <summary>
            Translates the coordinate system in two dimensions.
            <para>When this function is called with two numbers, dx, and dy, all the following drawing operations take effect as if their x and y coordinates were x+dx and y+dy.</para>
            <para>Scale and translate are not commutative operations, therefore, calling them in different orders will change the outcome.</para>
            <para>This change lasts until Scene.Draw exits or else a <see cref="M:Love.Graphics.Pop"/> reverts to a previous <see cref="M:Love.Graphics.Push(Love.StackType)"/> .</para>
            <para>Translating using whole numbers will prevent tearing/blurring of images and fonts draw after translating.</para>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Love.Graphics.Translate(Love.Vector2)">
            <summary>
            Translates the coordinate system in two dimensions.
            <para>When this function is called with two numbers, dx, and dy, all the following drawing operations take effect as if their x and y coordinates were x+dx and y+dy.</para>
            <para>Scale and translate are not commutative operations, therefore, calling them in different orders will change the outcome.</para>
            <para>This change lasts until Scene.Draw exits or else a <see cref="M:Love.Graphics.Pop"/> reverts to a previous <see cref="M:Love.Graphics.Push(Love.StackType)"/> .</para>
            <para>Translating using whole numbers will prevent tearing/blurring of images and fonts draw after translating.</para>
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Love.Graphics.Shear(System.Single,System.Single)">
            <summary>
            Shears the coordinate system.
            </summary>
            <param name="kx"></param>
            <param name="ky"></param>
        </member>
        <member name="M:Love.Graphics.Origin">
            <summary>
            Resets the current coordinate transformation.
            </summary>
        </member>
        <member name="M:Love.Graphics.TransformPoint(System.Single,System.Single)">
            <summary>
            Converts the given 2D position from global coordinates into screen-space.
            This effectively applies the current graphics transformations to the given position. A similar Transform:transformPoint method exists for Transform objects.
            </summary>
        </member>
        <member name="M:Love.Graphics.TransformPoint(Love.Vector2)">
            <summary>
            Converts the given 2D position from global coordinates into screen-space.
            This effectively applies the current graphics transformations to the given position. A similar Transform:transformPoint method exists for Transform objects.
            </summary>
        </member>
        <member name="M:Love.Graphics.InverseTransformPoint(System.Single,System.Single)">
            <summary>
            Converts the given 2D position from screen-space into global coordinates.
            This effectively applies the reverse of the current graphics transformations to the given position. A similar Transform:inverseTransformPoint method exists for Transform objects.
            </summary>
        </member>
        <member name="M:Love.Graphics.ApplyTransform(Love.Matrix44)">
            <summary>
            Applies the given Transform object to the current coordinate transformation.
            This effectively multiplies the existing coordinate transformation's matrix with the Transform object's internal matrix to produce the new coordinate transformation.
            </summary>
        </member>
        <member name="M:Love.Graphics.ReplaceTransform(Love.Matrix44)">
            <summary>
            Replaces the current coordinate transformation with the given Transform object.
            </summary>
        </member>
        <member name="M:Love.Graphics.InverseTransformPoint(Love.Vector2)">
            <summary>
            Converts the given 2D position from screen-space into global coordinates.
            This effectively applies the reverse of the current graphics transformations to the given position. A similar Transform:inverseTransformPoint method exists for Transform objects.
            </summary>
        </member>
        <member name="M:Love.Graphics.Stencil(System.Action,Love.StencilAction,System.Int32,System.Boolean)">
            <summary>
            Draws geometry as a stencil.
            <para> The geometry drawn by the supplied function sets invisible stencil values of pixels, instead of setting pixel colors. The stencil buffer (which contains those stencil values) can act like a mask / stencil - love.graphics.setStencilTest can be used afterward to determine how further rendering is affected by the stencil values in each pixel.</para>
            <para> Stencil values are integers within the range of [0, 255].</para>
            <para> Starting with version 11.0, a stencil buffer must be set or requested in love.graphics.setCanvas when using stencils with a Canvas. love.graphics.setCanvas{canvas, stencil=true} is an easy way to use an automatically provided temporary stencil buffer in that case.</para>
            https://love2d.org/wiki/love.graphics.stencil
            </summary>
            <param name="actionFunc">Function which draws geometry. The stencil values of pixels, rather than the color of each pixel, will be affected by the geometry.</param>
            <param name="stencilAction">How to modify any stencil values of pixels that are touched by what's drawn in the stencil function.</param>
            <param name="value">The new stencil value to use for pixels if the "replace" stencil action is used. Has no effect with other stencil actions. Must be between 0 and 255.</param>
            <param name="keepValue">True to preserve old stencil values of pixels, false to re-set every pixel's stencil value to 0 before executing the stencil function. love.graphics.clear will also re-set all stencil values.</param>
        </member>
        <member name="M:Love.Graphics.Discard(System.Boolean[],System.Boolean)">
            <summary>
            Discards (trashes) the contents of the screen or active Canvas. This is a performance optimization function with niche use cases.
            </summary>
            <param name="discardColors">An array containing boolean values indicating whether to discard the texture of each active Canvas, when multiple simultaneous Canvases are active.</param>
            <param name="discardStencil">Whether to discard the contents of the stencil buffer of the screen / active Canvas.</param>
        </member>
        <member name="M:Love.Graphics.Present">
            <summary>
            Displays the results of drawing operations on the screen.
            This function is used when writing your own Boot.Run function. It presents all the results of your drawing operations on the screen. See the example in Boot.Run for a typical use of this function.
            </summary>
        </member>
        <member name="M:Love.Graphics.Draw(Love.Drawable,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws a Drawable object (an Image, Canvas, SpriteBatch, ParticleSystem, Mesh, Text object, or Video) on the screen with optional rotation, scaling and shearing.
            </summary>
            <param name="drawable">A drawable object.</param>
            <param name="x">The position to draw the object (x-axis).</param>
            <param name="y">The position to draw the object (y-axis).</param>
            <param name="angle">Orientation (radians).</param>
            <param name="sx">Scale factor (x-axis).</param>
            <param name="sy">Scale factor (y-axis).</param>
            <param name="ox">Origin offset (x-axis).</param>
            <param name="oy">Origin offset (y-axis).</param>
            <param name="kx">Shearing factor (x-axis).</param>
            <param name="ky">Shearing factor (y-axis).</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Print(System.String,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws text on screen. If no Font is set, one will be created and set (once) if needed.
            As of LOVE 0.7.1, when using translation and scaling functions while drawing text, this function assumes the scale occurs first. If you don't script with this in mind, the text won't be in the right position, or possibly even on screen.
            Love.Graphics.Print and Love.Graphics.Printf both support UTF-8 encoding. You'll also need a proper Font for special characters.
            </summary>
            <param name="text">The text to draw.</param>
            <param name="x">The position to draw the object (x-axis).</param>
            <param name="y">The position to draw the object (y-axis).</param>
            <param name="angle">Orientation (radians).</param>
            <param name="sx">Scale factor (x-axis).</param>
            <param name="sy">Scale factor (y-axis).</param>
            <param name="ox">Origin offset (x-axis).</param>
            <param name="oy">Origin offset (y-axis).</param>
            <param name="kx">Shearing factor (x-axis).</param>
            <param name="ky">Shearing factor (y-axis).</param>
        </member>
        <member name="M:Love.Graphics.Print(Love.ColoredStringArray,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Same as Love.Graphics.Print(string...), but coloredStr used to show text in different color.
            </summary>
            <param name="coloredStr">colors and strings </param>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws a rectangle.
            </summary>
            <param name="mode_type">How to draw the rectangle.</param>
            <param name="x">The position of top-left corner along the x-axis.</param>
            <param name="y">The position of top-left corner along the y-axis.</param>
            <param name="w">Width of the rectangle.</param>
            <param name="h">Height of the rectangle.</param>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,Love.RectangleF[])">
            <summary>
            Draws a rectangle.
            </summary>
            <param name="mode">How to draw the rectangle.</param>
            <param name="rect">the rectangle array to draw.</param>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draws a rectangle with rounded corners.
            </summary>
            <param name="mode_type">How to draw the rectangle.</param>
            <param name="x">The position of top-left corner along the x-axis.</param>
            <param name="y">The position of top-left corner along the y-axis.</param>
            <param name="w">Width of the rectangle.</param>
            <param name="h">Height of the rectangle.</param>
            <param name="rx">The x-axis radius of each round corner. Cannot be greater than half the rectangle's width.</param>
            <param name="ry">The y-axis radius of each round corner. Cannot be greater than half the rectangle's height.</param>
            <param name="points">The number of segments used for drawing the round corners. A default amount will be chosen if no number is given.</param>
        </member>
        <member name="M:Love.Graphics.Circle(Love.DrawMode,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draws a circle.
            </summary>
            <param name="mode_type">How to draw the circle.</param>
            <param name="x">The position of the center along x-axis.</param>
            <param name="y">The position of the center along y-axis.</param>
            <param name="radius">The radius of the circle.</param>
            <param name="points">The number of segments used for drawing the circle. Note: The default variable for the segments parameter varies between different versions of LÖVE.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Circle(Love.DrawMode,System.Single,System.Single,System.Single)">
            <summary>
            Draws a circle.
            </summary>
            <param name="mode_type">How to draw the circle.</param>
            <param name="x">The position of the center along x-axis.</param>
            <param name="y">The position of the center along y-axis.</param>
            <param name="radius">The radius of the circle.</param>
            <param name="points">The number of segments used for drawing the circle. Note: The default variable for the segments parameter varies between different versions of LÖVE.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Ellipse(Love.DrawMode,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draws an ellipse.
            </summary>
            <param name="mode_type">How to draw the ellipse.</param>
            <param name="x">he position of the center along x-axis.</param>
            <param name="y">he position of the center along y-axis.</param>
            <param name="radiusX">The radius of the ellipse along the x-axis (half the ellipse's width).</param>
            <param name="radiusY">The radius of the ellipse along the y-axis (half the ellipse's height).</param>
            <param name="points">The number of segments used for drawing the ellipse.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Points(Love.Vector2[])">
            <summary>
            Draws one or more points.
            </summary>
            <param name="coords">The position of the each point</param>
        </member>
        <member name="M:Love.Graphics.Line(Love.Vector2[])">
            <summary>
            Draws lines between points.
            </summary>
            <param name="coords">A array of point positions.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Polygon(Love.DrawMode,Love.Vector2[])">
            <summary>
            Draw a polygon.
            When in fill mode, the polygon must be convex and simple or rendering artifacts may occur. Love.Mathf.Triangulate and Love.Mathf.IsConvex can be used in 0.9.0+.
            </summary>
            <param name="mode_type">How to draw the polygon.</param>
            <param name="coords">The vertices of the polygon.</param>
        </member>
        <member name="M:Love.Graphics.GetDPIScale">
            <summary>
            Gets the DPI scale factor of the window.
            <para>The DPI scale factor represents relative pixel density. The pixel density inside the window might be greater (or smaller) than the "size" of the window. For example on a retina screen in Mac OS X with the highdpi window flag enabled, the window may take up the same physical size as an 800x600 window, but the area inside the window uses 1600x1200 pixels. love.graphics.getDPIScale() would return 2 in that case.</para>
            <para>The love.window.fromPixels and love.window.toPixels functions can also be used to convert between units.</para>
            <para>The highdpi window flag must be enabled to use the full pixel density of a Retina screen on Mac OS X and iOS. The flag currently does nothing on Windows and Linux, and on Android it is effectively always enabled.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetWidth">
            <summary>
            Gets the width in pixels of the window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetHeight">
            <summary>
            Gets the height in pixels of the window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetSupported(Love.Feature)">
            <summary>
            Gets the optional graphics features and whether they're supported.
            </summary>
            <param name="feature_type"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetCanvasFormats(Love.PixelFormat)">
            <summary>
            Gets the available Canvas formats, and whether each is supported.
            </summary>
            <param name="format_type"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetRendererInfo(System.String@,System.String@,System.String@,System.String@)">
            <summary>
            Gets information about the system's video card and drivers.
            <para> Almost everything returned by this function is highly dependent on the system running the code and should probably not be used to make run-time decisions</para>
            </summary>
            <param name="name">The name of the renderer, e.g. "OpenGL" or "OpenGL ES".</param>
            <param name="version">The version of the renderer with some extra driver-dependent version info, e.g. "2.1 INTEL-8.10.44".</param>
            <param name="vendor">The name of the graphics card vendor, e.g. "Intel Inc".</param>
            <param name="device">The name of the graphics card, e.g. "Intel HD Graphics 3000 OpenGL Engine".</param>
        </member>
        <member name="M:Love.Graphics.GetSystemLimits(Love.Graphics.SystemLimit)">
            <summary>
            Gets the system-dependent maximum values for love.graphics features.
            </summary>
            <param name="limit_type"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetStats(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Gets performance-related rendering statistics.
            <para>	The per-frame metrics (drawcalls, canvasswitches, shaderswitches) are reset by love.graphics.present, which for the default implementation of <see cref="M:Love.Boot.Run(Love.Scene,Love.BootConfig)"/> is called right after the execution of Scene.Draw. Therefore this function should probably be called at the end of Scene.Draw.</para>
            </summary>
            <param name="out_drawCalls">The number of draw calls made so far during the current frame.</param>
            <param name="out_canvasSwitches">The number of times the active Canvas has been switched so far during the current frame.</param>
            <param name="out_shaderSwitches">The number of times the active Shader has been changed so far during the current frame.</param>
            <param name="out_canvases">The number of Canvas objects currently loaded.</param>
            <param name="out_images">The number of Image objects currently loaded.</param>
            <param name="out_fonts">The number of Font objects currently loaded.</param>
            <param name="out_textureMemory">The estimated total size in bytes of video memory used by all loaded Images, Canvases, and Fonts.</param>
        </member>
        <member name="M:Love.Graphics.NewCanvas">
            <summary>
            Creates a new Canvas.
            <para>This function can be slow if it is called repeatedly, such as from love.update or love.draw. If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <returns>A new Canvas with dimensions equal to the window's size in pixels.</returns>
        </member>
        <member name="M:Love.Graphics.NewText(Love.Font,System.String)">
            <summary>
            Creates a new drawable Text object.
            </summary>
            <param name="font">The font to use for the text.</param>
            <param name="coloredStr">The initial string of text that the new Text object will contain. May be nil.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewImage(System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Image from a filepath.
            </summary>
            <param name="filename">The filepath to the image file .</param>
            <param name="flagMipmaps">If true, mipmaps for the image will be automatically generated (or taken from the images's file if possible, if the image originated from a CompressedImageData). If this value is a table, it should contain a list of other filenames of images of the same format that have progressively half-sized dimensions, all the way down to 1x1. Those images will be used as this Image's mipmap levels.</param>
            <param name="flagLinear">True if the image's pixels should be interpreted as being linear RGB rather than sRGB-encoded, if gamma-correct rendering is enabled. Has no effect otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewFont(System.Int32,Love.HintingMode)">
            <summary>
            Create a new instance of the default font (Vera Sans) with a custom size.
            </summary>
            <param name="size">The size of the font in pixels.</param>
            <param name="hinting">True Type hinting mode.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewBMFont(System.String,System.String[])">
            <summary>
            </summary>
            <param name="filename">The filepath to the BMFont file.</param>
            <param name="imageFileName">The filepath to the BMFont's image file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewBMFont(System.String)">
            <summary>
            Create a new BMFont. The filepath to the BMFont's image file specified inside the BMFont file will be used.
            </summary>
            <param name="filename">The filepath to the BMFont file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewImageFont(System.String,System.String,System.Int32)">
            <summary>
            Creates a new Font by loading a specifically formatted image.
            <para>In versions prior to 0.9.0, LÖVE expects ISO 8859-1 encoding for the glyphs string.</para>
            <para>	This function can be slow if it is called repeatedly, such as from Scene.Update. If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <param name="filename">The filepath to the image file.</param>
            <param name="glyphs">A string of the characters in the image in order from left to right.</param>
            <param name="extraspacing">Additional spacing (positive or negative) to apply to each glyph in the Font.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewFont(System.String,System.Int32,Love.HintingMode)">
            <summary>
            Create a new TrueType font.
            </summary>
            <param name="filename">The filepath to the TrueType font file.</param>
            <param name="size">The size of the font in pixels.</param>
            <param name="hinting">True Type hinting mode.</param>
            <returns>A Font object which can be used to draw text on screen.</returns>
        </member>
        <member name="M:Love.Graphics.NewVideo(System.String,System.Boolean,System.Nullable{System.Single})">
            <summary>
            Creates a new drawable Video. Currently only Ogg Theora video files are supported.
            </summary>
            <param name="filename">The file path to the Ogg Theora video file.</param>
            <param name="audio">Whether to try to load the video's audio into an audio Source. If not explicitly set to true or false, it will try without causing an error if the video has no audio.</param>
            <param name="dipScale">The DPI scale factor of the video. if it was null, value will be Graphics.GetDPIScale()</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Clear">
            <summary>
            Clears the screen to transparent black (0, 0, 0, 0).
            </summary>
        </member>
        <member name="M:Love.Graphics.Clear(Love.Color)">
            <summary>
            Clears the screen to transparent black (0, 0, 0, 0).
            </summary>
        </member>
        <member name="M:Love.Graphics.SetColor(Love.Color)">
            <summary>
            Sets the color used for drawing.
            </summary>
        </member>
        <member name="M:Love.Graphics.SetColor(Love.Vector4)">
            <summary>
            Sets the color used for drawing.
            </summary>
        </member>
        <member name="M:Love.Graphics.Circle(Love.DrawMode,Love.Vector2,System.Single)">
            <summary>
            Draws a circle.
            </summary>
            <param name="mode_type">How to draw the circle.</param>
            <param name="center">The position of the center .</param>
            <param name="radius">The radius of the circle.</param>
            <param name="points">The number of segments used for drawing the circle. Note: The default variable for the segments parameter varies between different versions of LÖVE.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Circle(Love.DrawMode,Love.Vector2,System.Single,System.Int32)">
            <summary>
            Draws a circle.
            </summary>
            <param name="mode_type">How to draw the circle.</param>
            <param name="center">The position of the center .</param>
            <param name="radius">The radius of the circle.</param>
            <param name="points">The number of segments used for drawing the circle. Note: The default variable for the segments parameter varies between different versions of LÖVE.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,Love.RectangleF)">
            <summary>
            Draws a rectangle.
            </summary>
            <param name="mode">How to draw the rectangle.</param>
            <param name="rect">the rectangle to draw.</param>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,Love.Rectangle)">
            <summary>
            Draws a rectangle.
            </summary>
            <param name="mode">How to draw the rectangle.</param>
            <param name="rect">the rectangle to draw.</param>
        </member>
        <member name="M:Love.Graphics.Arc(Love.DrawMode,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws an arc using the "pie" ArcType.
            </summary>
            <param name="draw_mode"></param>
            <param name="x">The position of the center along x-axis.</param>
            <param name="y">The position of the center along y-axis.</param>
            <param name="radius">Radius of the arc.</param>
            <param name="angle1">The angle at which the arc begins.</param>
            <param name="angle2">The angle at which the arc terminates.</param>
        </member>
        <member name="M:Love.Graphics.Discard(System.Boolean,System.Boolean)">
            <summary>
            Discards (trashes) the contents of the screen or active Canvas. This is a performance optimization function with niche use cases.
            </summary>
            <param name="discardColor">Whether to discard the texture(s) of the active Canvas(es) (the contents of the screen if no Canvas is active.)</param>
            <param name="discardStencil">Whether to discard the contents of the stencil buffer of the screen / active Canvas.</param>
        </member>
        <member name="M:Love.Graphics.NewMesh(Love.MeshFormatDescribe,System.Byte[],Love.MeshDrawMode,Love.SpriteBatchUsage)">
            <summary>
            Each vertex attribute component is initialized to 0 if its data type is "float", or 1 if its data type is "byte". Mesh:setVertices or Mesh:setVertex and Mesh:setDrawRange can be used to specify vertex information once the Mesh is created.
            <para> If the data type of an attribute is "float", components can be in the range 1 to 4, if the data type is "byte" it must be 4. </para>
            <para> If a custom vertex attribute uses the name "VertexPosition", "VertexTexCoord", or "VertexColor", then the vertex data for that vertex attribute will be used for the standard vertex positions, texture coordinates, or vertex colors respectively, when drawing the Mesh.Otherwise a Vertex Shader is required in order to make use of the vertex attribute when the Mesh is drawn. </para>
            </summary>
        </member>
        <member name="M:Love.Graphics.NewMesh(Love.MeshFormatDescribe,System.Int32,Love.MeshDrawMode,Love.SpriteBatchUsage)">
            <summary>
            Each vertex attribute component is initialized to 0 if its data type is "float", or 1 if its data type is "byte". Mesh:setVertices or Mesh:setVertex and Mesh:setDrawRange can be used to specify vertex information once the Mesh is created.
            <para> If the data type of an attribute is "float", components can be in the range 1 to 4, if the data type is "byte" it must be 4. </para>
            <para> If a custom vertex attribute uses the name "VertexPosition", "VertexTexCoord", or "VertexColor", then the vertex data for that vertex attribute will be used for the standard vertex positions, texture coordinates, or vertex colors respectively, when drawing the Mesh.Otherwise a Vertex Shader is required in order to make use of the vertex attribute when the Mesh is drawn. </para>
            </summary>
        </member>
        <member name="M:Love.Graphics.Printf(System.String,System.Single,System.Single,System.Single,Love.AlignMode,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para> Draws formatted text, with word wrap and alignment.</para>
            <para> See additional notes in love.graphics.print. </para>
            <para>In version 0.9.2 and earlier, wrapping was implemented by breaking up words by spaces and putting them back together to make sure things fit nicely within the limit provided. However, due to the way this is done, extra spaces between words would end up missing when printed on the screen, and some lines could overflow past the provided wrap limit. In version 0.10.0 and newer this is no longer the case.</para>
            <para>Aligning does not work as one might expect! It doesn't align to the x/y coordinates given, but in a rectangle, where the limit is the width.</para>
            <para>Text may appear blurry if it's rendered at non-integer pixel locations.</para>
            </summary>
            <param name="text">A text string.</param>
            <param name="x">The position on the x-axis.</param>
            <param name="y">The position on the y-axis.</param>
            <param name="wrap"></param>
            <param name="align_type">Wrap the line after this many horizontal pixels.</param>
            <param name="angle">Orientation (radians).</param>
            <param name="sx">Scale factor (x-axis).</param>
            <param name="sy">Scale factor (y-axis).</param>
            <param name="ox">Origin offset (x-axis).</param>
            <param name="oy">Origin offset (y-axis).</param>
            <param name="kx">Shearing factor (x-axis).</param>
            <param name="ky">Shearing factor (y-axis).</param>
        </member>
        <member name="M:Love.Graphics.SetStencilTest">
            <summary>
            Disables stencil testing.
            </summary>
        </member>
        <member name="M:Love.Graphics.GetDimensions">
            <summary>
            Gets the width and height of the window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Line(System.Single[])">
            <summary>
            Draws lines between points.
            </summary>
            <param name="points">must be an integer multiple of 2. [first(x, y), second(x, y) ....]</param>
        </member>
        <member name="M:Love.Graphics.Points(System.Single[])">
            <summary>
            Draws one or more points.
            </summary>
            <param name="points">must be an integer multiple of 2. [first(x, y), second(x, y) ....]</param>
        </member>
        <member name="M:Love.Graphics.Polygon(Love.DrawMode,System.Single[])">
            <summary>
            Draw a polygon.
            </summary>
            <param name="mode">How to draw the polygon.</param>
            <param name="points">must be an integer multiple of 2. [first(x, y), second(x, y) ....]</param>
        </member>
        <member name="M:Love.Graphics.Scale(Love.Vector2)">
            <summary>
            <para>以二维方式缩放坐标系。</para>
            <para>默认情况下，LÖVE中的坐标系在水平和垂直方向上一对一显示像素，x轴向右增加，y轴向下增加。 缩放坐标系会改变这种关系。</para>
            <para>在通过sx和sy进行缩放之后，所有坐标都被视为与sx和sy相乘。 绘图操作的每个结果也相应地缩放，例如按（2,2）缩放将意味着在x和y方向上使所有内容都变为两倍。 按负值缩放会使坐标系在相应的方向上翻转，所有内容都会被翻转或颠倒（或两者兼而有之）。 按零缩放没有意义。</para>
            <para>缩放(Scale)操作和平移(Translate)操作不是可交换操作，以不同的顺序调用它们会产生不同的结果。</para>
            <para>效果持续到 Scene.Draw 调用结束（每一帧画面绘制结束都会自动重置为1倍。）</para>
            
            <para>Scales the coordinate system in two dimensions.</para> 
            <para>By default the coordinate system in LÖVE corresponds to the display pixels in horizontal and vertical directions one-to-one, and the x-axis increases towards the right while the y-axis increases downwards. Scaling the coordinate system changes this relation.</para>
            <para>After scaling by sx and sy, all coordinates are treated as if they were multiplied by sx and sy. Every result of a drawing operation is also correspondingly scaled, so scaling by (2, 2) for example would mean making everything twice as large in both x- and y-directions. Scaling by a negative value flips the coordinate system in the corresponding direction, which also means everything will be drawn flipped or upside down, or both. Scaling by zero is not a useful operation.</para>
            <para>Scale and translate are not commutative operations, therefore, calling them in different orders will change the outcome.</para>
            <para>Scaling lasts until Scene.Draw exits.</para>
            </summary>
            <param name="scale">The scaling on each axis.</param>
        </member>
        <member name="M:Love.Graphics.Scale(System.Single)">
            <summary>
            <para>以二维方式缩放坐标系。</para>
            <para>默认情况下，LÖVE中的坐标系在水平和垂直方向上一对一显示像素，x轴向右增加，y轴向下增加。 缩放坐标系会改变这种关系。</para>
            <para>在通过sx和sy进行缩放之后，所有坐标都被视为与sx和sy相乘。 绘图操作的每个结果也相应地缩放，例如按（2,2）缩放将意味着在x和y方向上使所有内容都变为两倍。 按负值缩放会使坐标系在相应的方向上翻转，所有内容都会被翻转或颠倒（或两者兼而有之）。 按零缩放没有意义。</para>
            <para>缩放(Scale)操作和平移(Translate)操作不是可交换操作，以不同的顺序调用它们会产生不同的结果。</para>
            <para>效果持续到 Scene.Draw 调用结束（每一帧画面绘制结束都会自动重置为1倍。）</para>
            
            <para>Scales the coordinate system in two dimensions.</para> 
            <para>By default the coordinate system in LÖVE corresponds to the display pixels in horizontal and vertical directions one-to-one, and the x-axis increases towards the right while the y-axis increases downwards. Scaling the coordinate system changes this relation.</para>
            <para>After scaling by sx and sy, all coordinates are treated as if they were multiplied by sx and sy. Every result of a drawing operation is also correspondingly scaled, so scaling by (2, 2) for example would mean making everything twice as large in both x- and y-directions. Scaling by a negative value flips the coordinate system in the corresponding direction, which also means everything will be drawn flipped or upside down, or both. Scaling by zero is not a useful operation.</para>
            <para>Scale and translate are not commutative operations, therefore, calling them in different orders will change the outcome.</para>
            <para>Scaling lasts until Scene.Draw exits.</para>
            </summary>
            <param name="scale">The scaling on each axis.</param>
        </member>
        <member name="M:Love.Graphics.SetCanvas(Love.RenderTargetInfo)">
            <summary>
            Captures drawing operations to a Canvas
            <para>Sets the render target to a specified Canvas. All drawing operations until the next love.graphics.setCanvas call will be redirected to the Canvas and not shown on the screen.</para>
            <para>if Length of canvas is zero, then resets the render target to the screen, i.e. re-enables drawing to the screen.</para>
            </summary>
            <param name="canvas"></param>
        </member>
        <member name="M:Love.Graphics.GetCanvas">
            <summary>
            Returns the current target Canvas. Returns zero length array if drawing to the real screen.
            </summary>
        </member>
        <member name="M:Love.Graphics.SetCanvas(Love.Canvas[])">
            <summary>
            Captures drawing operations to a Canvas
            <para>Sets the render target to a specified Canvas. All drawing operations until the next love.graphics.setCanvas call will be redirected to the Canvas and not shown on the screen.</para>
            <para>if Length of canvas is zero, then resets the render target to the screen, i.e. re-enables drawing to the screen.</para>
            </summary>
            <param name="canvas"></param>
        </member>
        <member name="M:Love.Graphics.CalculateViewOffset(System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            计算画面偏移
            </summary>
            <param name="playerX">人物横坐标</param>
            <param name="playerY">人物纵坐标</param>
            <param name="screenWidth">窗口宽度</param>
            <param name="screenHeight">窗口高度</param>
            <param name="mapWidth">地图宽度</param>
            <param name="mapHeight">地图高度</param>
            <returns></returns>
        </member>
        <member name="T:Love.Scene">
            <summary>
            <para>继承本类，作为 Boot.Run 的启动参数。</para>
            <para>Inherit this class as the startup parameter for Boot.Run()</para>
            </summary>
        </member>
        <member name="M:Love.Scene.KeyPressed(Love.KeyConstant,Love.Scancode,System.Boolean)">
            <summary>
            Triggered when a key is pressed.
            </summary>
            <param name="key">Character of the pressed key.</param>
            <param name="scancode">The scancode representing the pressed key.</param>
            <param name="isRepeat">Whether this keypress event is a repeat. The delay between key repeats depends on the user's system settings.</param>
        </member>
        <member name="M:Love.Scene.KeyReleased(Love.KeyConstant,Love.Scancode)">
            <summary>
            Triggered when a keyboard key is released.
            </summary>
            <param name="key">Character of the pressed key.</param>
            <param name="scancode">The scancode representing the pressed key.</param>
        </member>
        <member name="M:Love.Scene.MouseMoved(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Callback function triggered when the mouse is moved.
            </summary>
            <param name="x">The mouse position on the x-axis.</param>
            <param name="y">The mouse position on the y-axis.</param>
            <param name="dx">The amount moved along the x-axis since the last time love.mousemoved was called.</param>
            <param name="dy">The amount moved along the y-axis since the last time love.mousemoved was called.</param>
            <param name="isTouch">True if the mouse button press originated from a touchscreen touch-press.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Love.Scene.MousePressed(System.Single,System.Single,System.Int32,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Love.Scene.MouseReleased(System.Single,System.Single,System.Int32,System.Boolean)" -->
        <member name="M:Love.Scene.MouseFocus(System.Boolean)">
            <summary>
            Callback function triggered when window receives or loses mouse focus.
            </summary>
            <param name="focus">Whether the window has mouse focus or not.</param>
        </member>
        <member name="M:Love.Scene.WheelMoved(System.Int32,System.Int32)">
            <summary>
            Callback function triggered when the mouse wheel is moved.
            </summary>
            <param name="x">Amount of horizontal mouse wheel movement. Positive values indicate movement to the right.</param>
            <param name="y">Amount of vertical mouse wheel movement. Positive values indicate upward movement.</param>
        </member>
        <member name="M:Love.Scene.JoystickPressed(Love.Joystick,System.Int32)">
            <summary>
            Called when a joystick button is pressed.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="button">The button number.</param>
        </member>
        <member name="M:Love.Scene.JoystickReleased(Love.Joystick,System.Int32)">
            <summary>
            Called when a joystick button is released.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="button">The button number.</param>
        </member>
        <member name="M:Love.Scene.JoystickAxis(Love.Joystick,System.Single,System.Single)">
            <summary>
            Called when a joystick axis moves.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="axis">The axis number.</param>
            <param name="value">The new axis value.</param>
        </member>
        <member name="M:Love.Scene.JoystickHat(Love.Joystick,System.Int32,Love.JoystickHat)">
            <summary>
            Called when a joystick hat direction changes.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="hat">The hat number.</param>
            <param name="direction">The new hat direction.</param>
        </member>
        <member name="M:Love.Scene.JoystickGamepadPressed(Love.Joystick,Love.GamepadButton)">
            <summary>
            Called when a Joystick's virtual gamepad button is pressed.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="button">The virtual gamepad button.</param>
        </member>
        <member name="M:Love.Scene.JoystickGamepadReleased(Love.Joystick,Love.GamepadButton)">
            <summary>
            Called when a Joystick's virtual gamepad button is released.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="button">The virtual gamepad button.</param>
        </member>
        <member name="M:Love.Scene.JoystickGamepadAxis(Love.Joystick,Love.GamepadAxis,System.Single)">
            <summary>
            Called when a Joystick's virtual gamepad axis is moved.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="axis">The virtual gamepad axis.</param>
            <param name="value">The new axis value.</param>
        </member>
        <member name="M:Love.Scene.JoystickAdded(Love.Joystick)">
            <summary>
            Called when a Joystick is connected.
            </summary>
            <param name="joystick">The newly connected Joystick object.</param>
        </member>
        <member name="M:Love.Scene.JoystickRemoved(Love.Joystick)">
            <summary>
            Called when a Joystick is disconnected.
            </summary>
            <param name="joystick">The now-disconnected Joystick object.</param>
        </member>
        <member name="M:Love.Scene.TouchMoved(System.Int64,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Callback function triggered when a touch press moves inside the touch screen.
            </summary>
            <param name="id">The identifier for the touch press.</param>
            <param name="x">The x-axis position of the touch inside the window, in pixels.</param>
            <param name="y">The y-axis position of the touch inside the window, in pixels.</param>
            <param name="dx">The x-axis movement of the touch inside the window, in pixels.</param>
            <param name="dy">The y-axis movement of the touch inside the window, in pixels.</param>
            <param name="pressure">The amount of pressure being applied. Most touch screens aren't pressure sensitive, in which case the pressure will be 1.</param>
        </member>
        <member name="M:Love.Scene.TouchPressed(System.Int64,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Callback function triggered when the touch screen is touched.
            </summary>
            <param name="id">The identifier for the touch press.</param>
            <param name="x">The x-axis position of the touch inside the window, in pixels.</param>
            <param name="y">The y-axis position of the touch inside the window, in pixels.</param>
            <param name="dx">The x-axis movement of the touch inside the window, in pixels.</param>
            <param name="dy">The y-axis movement of the touch inside the window, in pixels.</param>
            <param name="pressure">The amount of pressure being applied. Most touch screens aren't pressure sensitive, in which case the pressure will be 1.</param>
        </member>
        <member name="M:Love.Scene.TouchReleased(System.Int64,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Callback function triggered when the touch screen stops being touched.
            </summary>
            <param name="id">The identifier for the touch press.</param>
            <param name="x">The x-axis position of the touch inside the window, in pixels.</param>
            <param name="y">The y-axis position of the touch inside the window, in pixels.</param>
            <param name="dx">The x-axis movement of the touch inside the window, in pixels.</param>
            <param name="dy">The y-axis movement of the touch inside the window, in pixels.</param>
            <param name="pressure">The amount of pressure being applied. Most touch screens aren't pressure sensitive, in which case the pressure will be 1.</param>
        </member>
        <member name="M:Love.Scene.TextEditing(System.String,System.Int32,System.Int32)">
            <summary>
            Called when the candidate text for an IME has changed.
            </summary>
            <param name="text">The UTF-8 encoded unicode candidate text.</param>
            <param name="start">The start cursor of the selected candidate text.</param>
            <param name="end">The length of the selected candidate text. May be 0.</param>
        </member>
        <member name="M:Love.Scene.TextInput(System.String)">
            <summary>
            Called when text has been entered by the user.
            </summary>
            <param name="text">The UTF-8 encoded unicode text.</param>
        </member>
        <member name="M:Love.Scene.WindowFocus(System.Boolean)">
            <summary>
            Callback function triggered when window receives or loses focus.
            </summary>
            <param name="focus">True if the window gains focus, false if it loses focus.</param>
        </member>
        <member name="M:Love.Scene.WindowVisible(System.Boolean)">
            <summary>
            Callback function triggered when window is shown or hidden.
            </summary>
            <param name="visible">True if the window is visible, false if it isn't.</param>
        </member>
        <member name="M:Love.Scene.WindowResize(System.Int32,System.Int32)">
            <summary>
            Called when the window is resized, for example if the user resizes the window, or if Love.Window.SetMode is called with an unsupported width or height in fullscreen and the window chooses the closest appropriate size.
            </summary>
            <param name="w">The new width, in pixels.</param>
            <param name="h">The new height, in pixels.</param>
        </member>
        <member name="M:Love.Scene.DirectoryDropped(System.String)">
            <summary>
            Callback function triggered when a directory is dragged and dropped onto the window.
            </summary>
            <param name="path">The full platform-dependent path to the directory. It can be used as an argument to love.filesystem.mount, in order to gain read access to the directory with love.filesystem.</param>
        </member>
        <member name="M:Love.Scene.FileDropped(System.String)">
            <summary>
            Callback function triggered when a file is dragged and dropped onto the window.
            </summary>
            <param name="file">The unopened File object representing the file that was dropped.</param>
        </member>
        <member name="M:Love.Scene.Quit">
            <summary>
            Callback function triggered when the game is closed.
            </summary>
            <returns>Abort quitting. If true, do not close the game.</returns>
        </member>
        <member name="M:Love.Scene.LowMemory">
            <summary>
            Callback function triggered when the system is running out of memory on mobile devices.
            </summary>
        </member>
        <member name="M:Love.Scene.Load">
            <summary>
            This function is called exactly once at the beginning of the game.
            </summary>
        </member>
        <member name="M:Love.Scene.Update(System.Single)">
            <summary>
            Callback function used to update the state of the game every frame.
            </summary>
            <param name="dt">Time since the last update in seconds.</param>
        </member>
        <member name="M:Love.Scene.Draw">
            <summary>
            Callback function used to draw on the screen every frame.
            </summary>
        </member>
        <member name="M:Love.Scene.ErrorHandler(System.Exception)">
            <summary>
            Callback function when exception occur.
            Return true means exit error screen.
            This function will be called each error screen render frame.
            </summary>
        </member>
        <member name="T:Love.BootConfig">
            <summary>
            Boot class start params
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowWidth">
            <summary>
            The window width(height)
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowHeight">
            <summary>
            The window width(height)
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowTitle">
            <summary>
            The window title
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowBorderless">
            <summary>
            Remove all border visuals from the window
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowResizable">
            <summary>
            Let the window be user-resizable
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowMinWidth">
            <summary>
            Minimum window width if the window is resizable
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowMinHeight">
            <summary>
            Minimum window height if the window is resizable
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowFullscreenType">
            <summary>
            Choose between "DeskTop" fullscreen or "Exclusive" fullscreen mode
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowFullscreen">
            <summary>
            Fullscreen (true), or windowed (false).
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowVsync">
            <summary>
            Vertical sync mode
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowMSAA">
            <summary>
            The number of samples to use with multi-sampled antialiasing
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowDisplay">
            <summary>
            Index of the monitor to show the window in
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowHighdpi">
            <summary>
            Enable high-dpi mode for the window on a Retina display
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowX">
            <summary>
            The x-coordinate(y-coordinate) of the window's position in the specified display
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowY">
            <summary>
            The x-coordinate(y-coordinate) of the window's position in the specified display
            </summary>
        </member>
        <member name="F:Love.BootConfig.DefaultRandomSeed">
            <summary>
            Default random seed on Mathf.Random
            </summary>
        </member>
        <member name="T:Love.Boot">
            <summary>
            LÖVE engine entrance class
            <para>LÖVE 引擎入口类</para>
            </summary>
        </member>
        <member name="F:Love.Boot.QuitFlag">
            <summary>
            <para>Event.Quit() will lead QuitFlag = true, with will lead Boot.Run()  quit </para>
            </summary>
        </member>
        <member name="M:Love.Boot.SystemStep(Love.Scene)">
            <summary>
            you should not manual call this function, Unless you know what you're doing
            <para>event poll</para>
            </summary>
        </member>
        <member name="M:Love.Boot.Run(Love.Scene,Love.BootConfig)">
            <summary>
            LÖVE engine entrance function
            </summary>
            <param name="scene">The way to run LÖVE engine</param>
            <param name="bootConfig">LÖVE engine boot config</param>
        </member>
        <member name="M:Love.Half.IntToFloat(System.Int32)">
            <summary>
            ignores the higher 16 bits
            <para>https://codereview.stackexchange.com/questions/45007/half-precision-reader-writer-for-c</para>
            </summary>
            <param name="hbits"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Half.FloatToInt(System.Single)">
            <summary>
            returns all higher 16 bits as 0 for all results
            <para>https://codereview.stackexchange.com/questions/45007/half-precision-reader-writer-for-c</para>
            </summary>
            <param name="fval"></param>
            <returns></returns>
        </member>
        <member name="F:Love.MouseButton.LeftButton">
            <summary>
            The mouse left button
            </summary>
        </member>
        <member name="F:Love.MouseButton.RightButton">
            <summary>
            The mouse right button
            </summary>
        </member>
        <member name="F:Love.MouseButton.MiddleButton">
            <summary>
            The mouse middle button
            </summary>
        </member>
        <member name="F:Love.MouseButton.ExtendedButton1">
            <summary>
            The first extended button
            </summary>
        </member>
        <member name="F:Love.MouseButton.ExtendedButton2">
            <summary>
            The second extended button
            </summary>
        </member>
        <member name="F:Love.MouseButton.ExtendedButton3">
            <summary>
            The third extended button
            </summary>
        </member>
        <member name="F:Love.MouseButton.ExtendedButton4">
            <summary>
            The Fourth extended button
            </summary>
        </member>
        <member name="F:Love.MouseButton.ExtendedButton5">
            <summary>
            The Fifth extended button
            </summary>
        </member>
        <member name="T:Love.BodyType">
            <summary>
            The types of a Body.
            </summary>
        </member>
        <member name="F:Love.BodyType.Static">
            <summary>
            Static bodies do not move.
            </summary>
        </member>
        <member name="F:Love.BodyType.Dynamic">
            <summary>
            Dynamic bodies collide with all bodies.
            </summary>
        </member>
        <member name="F:Love.BodyType.Kinematic">
            <summary>
            Kinematic bodies only collide with dynamic bodies.
            </summary>
        </member>
        <member name="T:Love.JointType">
            <summary>
            Different types of joints.
            </summary>
        </member>
        <member name="T:Love.ShapeType">
            <summary>
            The different types of Shapes, as returned by Shape:getType.
            </summary>
        </member>
        <member name="T:Love.HintingMode">
            <summary>
            True Type hinting mode. See True Type official document for more information.
            </summary>
        </member>
        <member name="T:Love.GamepadButton">
            <summary>
            Virtual gamepad buttons.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.LeftStick">
            <summary>
            Left stick click button.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.RightStick">
            <summary>
            Right stick click button.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.LeftShoulder">
            <summary>
            Left bumper.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.RightShoulder">
            <summary>
            Right bumper.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.DPadUp">
            <summary>
            D-pad up.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.DPadDown">
            <summary>
            D-pad down.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.DPadLeft">
            <summary>
            D-pad left.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.DPadRight">
            <summary>
            D-pad right.
            </summary>
        </member>
        <member name="T:Love.GamepadAxis">
            <summary>
            Virtual gamepad axes.
            </summary>
        </member>
        <member name="F:Love.JoystickHat.RightUp">
            <summary>
            Right+Up
            </summary>
        </member>
        <member name="F:Love.JoystickHat.RightDown">
            <summary>
            Right+Down
            </summary>
        </member>
        <member name="F:Love.JoystickHat.LeftUp">
            <summary>
            Left+Up
            </summary>
        </member>
        <member name="F:Love.JoystickHat.LeftDown">
            <summary>
            Left+Down
            </summary>
        </member>
        <member name="T:Love.ParticleInsertMode">
            <summary>
            How newly created particles are added to the ParticleSystem.
            </summary>
        </member>
        <member name="F:Love.ParticleInsertMode.Top">
            <summary>
            Particles are inserted at the top of the ParticleSystem's list of particles.
            </summary>
        </member>
        <member name="F:Love.ParticleInsertMode.Bottom">
            <summary>
            Particles are inserted at the bottom of the ParticleSystem's list of particles.
            </summary>
        </member>
        <member name="F:Love.ParticleInsertMode.Random">
            <summary>
            Particles are inserted at random positions in the ParticleSystem's list of particles.
            </summary>
        </member>
        <member name="T:Love.WrapMode">
            <summary>
            How the image wraps inside a Quad with a larger quad size than image size. This also affects how Meshes with texture coordinates which are outside the range of [0, 1] are drawn, and the color returned by the Texel Shader function when using it to sample from texture coordinates outside of the range of [0, 1].
            <para>https://love2d.org/wiki/WrapMode</para>
            </summary>
        </member>
        <member name="F:Love.WrapMode.Clamp">
            <summary>
            Clamp the texture. Appears only once. The area outside the texture's normal range is colored based on the edge pixels of the texture.
            </summary>
        </member>
        <member name="F:Love.WrapMode.ClampZero">
            <summary>
            Clamp the texture. Fills the area outside the texture's normal range with transparent black (or opaque black for textures with no alpha channel.)
            </summary>
        </member>
        <member name="F:Love.WrapMode.Repeat">
            <summary>
            Repeat the texture. Fills the whole available extent.
            </summary>
        </member>
        <member name="F:Love.WrapMode.MirroredRepeat">
            <summary>
            Repeat the texture, flipping it each time it repeats. May produce better visual results than the <see cref="F:Love.WrapMode.Repeat"/> mode when the texture doesn't seamlessly tile.
            </summary>
        </member>
        <member name="T:Love.FilterMode">
            <summary>
            How the image is filtered when scaling.
            </summary>
        </member>
        <member name="F:Love.FilterMode.Linear">
            <summary>
            Scale image with linear interpolation. (default)
            </summary>
        </member>
        <member name="F:Love.FilterMode.Nearest">
            <summary>
            Scale image with nearest neighbor interpolation.
            </summary>
        </member>
        <member name="T:Love.AlignMode">
            <summary>
            Text alignment.
            </summary>
        </member>
        <member name="F:Love.AlignMode.Left">
            <summary>
            Align text left.
            </summary>
        </member>
        <member name="F:Love.AlignMode.Center">
            <summary>
            Align text center.
            </summary>
        </member>
        <member name="F:Love.AlignMode.Right">
            <summary>
            Align text right.
            </summary>
        </member>
        <member name="F:Love.AlignMode.Justify">
            <summary>
            Align text both left and right.
            </summary>
        </member>
        <member name="T:Love.ImageDataPixelFormat">
            <summary>
            Provide for custom image data, not all Pixel format support to create new custom imageData;
            </summary>
        </member>
        <member name="T:Love.ImageFormat">
            <summary>
            Encoded image formats.
            </summary>
        </member>
        <member name="F:Love.ImageFormat.TGA">
            <summary>
            Targa image format.
            </summary>
        </member>
        <member name="F:Love.ImageFormat.PNG">
            <summary>
            PNG image format.
            </summary>
        </member>
        <member name="T:Love.FileMode">
            <summary>
            The different modes you can open a File in.
            </summary>
        </member>
        <member name="F:Love.FileMode.Closed">
            <summary>
            Do not open a file (represents a closed file.)
            </summary>
        </member>
        <member name="F:Love.FileMode.Read">
            <summary>
            Open a file for read.
            </summary>
        </member>
        <member name="F:Love.FileMode.Write">
            <summary>
            Open a file for write.
            </summary>
        </member>
        <member name="F:Love.FileMode.Append">
            <summary>
            Open a file for append.
            </summary>
        </member>
        <member name="T:Love.BufferMode">
            <summary>
            Buffer modes for File objects.
            </summary>
        </member>
        <member name="F:Love.BufferMode.None">
            <summary>
            No buffering. The result of write and append operations appears immediately.
            </summary>
        </member>
        <member name="F:Love.BufferMode.Line">
            <summary>
            Line buffering. Write and append operations are buffered until a newline is output or the buffer size limit is reached.
            </summary>
        </member>
        <member name="F:Love.BufferMode.Full">
            <summary>
            Full buffering. Write and append operations are always buffered until the buffer size limit is reached.
            </summary>
        </member>
        <member name="T:Love.FileType">
            <summary>
            The type of a file.
            </summary>
        </member>
        <member name="F:Love.FileType.File">
            <summary>
            Regular file.
            </summary>
        </member>
        <member name="F:Love.FileType.Directory">
            <summary>
            Directory.
            </summary>
        </member>
        <member name="F:Love.FileType.SymLink">
            <summary>
            Symbolic link.
            </summary>
        </member>
        <member name="F:Love.FileType.Other">
            <summary>
            Something completely different like a device.
            </summary>
        </member>
        <member name="T:Love.DistanceModel">
            <summary>
            The different distance models.
            <para>Extended information can be found in the chapter "3.4. Attenuation By Distance" of the OpenAL 1.1 specification.( https://www.openal.org/documentation/openal-1.1-specification.pdf )</para>
            </summary>
        </member>
        <member name="F:Love.DistanceModel.None">
            <summary>
            Sources do not get attenuated.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.Inverse">
            <summary>
            Inverse distance attenuation.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.InverseClamped">
            <summary>
            Inverse distance attenuation. Gain is clamped. In version 0.9.2 and older this is named inverse clamped.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.Linear">
            <summary>
            Linear attenuation.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.LinearClamped">
            <summary>
            Linear attenuation. Gain is clamped. In version 0.9.2 and older this is named linear clamped.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.Exponent">
            <summary>
            Exponential attenuation.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.ExponentClamped">
            <summary>
            Exponential attenuation. Gain is clamped. In version 0.9.2 and older this is named exponent clamped.
            </summary>
        </member>
        <member name="T:Love.SystemCursor">
            <summary>
            Types of cursors.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Arrow">
            <summary>
            An arrow pointer.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Ibeam">
            <summary>
            An I-beam, normally used when mousing over editable or selectable text.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Wait">
            <summary>
            Wait graphic.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Crosshair">
            <summary>
            Crosshair symbol.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.WaitArrow">
            <summary>
            Small wait cursor with an arrow pointer.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeNWSE">
            <summary>
            Double arrow pointing to the top-left and bottom-right.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeNESW">
            <summary>
            Double arrow pointing to the top-right and bottom-left.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeWE">
            <summary>
            Double arrow pointing left and right.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeNS">
            <summary>
            Double arrow pointing up and down.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeAll">
            <summary>
            Four-pointed arrow pointing up, down, left, and right.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.No">
            <summary>
            Slashed circle or crossbones.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Hand">
            <summary>
            Hand symbol.
            </summary>
        </member>
        <member name="F:Love.CursorType.Custom">
            <summary>
            自定义的光标类型
            </summary>
        </member>
        <member name="F:Love.CursorType.System">
            <summary>
            系统的光标
            </summary>
        </member>
        <member name="T:Love.TimeUnit">
            <summary>
            Units that represent time.
            </summary>
        </member>
        <member name="F:Love.TimeUnit.Seconds">
            <summary>
            Regular seconds.
            </summary>
        </member>
        <member name="F:Love.TimeUnit.Samples">
            <summary>
            Audio samples.
            </summary>
        </member>
        <member name="T:Love.KeyConstant">
            <summary>
            All the keys you can press. Note that some keys may not be available on your keyboard or system.
            </summary>
        </member>
        <member name="T:Love.Scancode">
            <summary>
            <para>Scancodes are keyboard layout-independent, so the scancode "w" will be generated if the key in the same place as the "w" key on an American QWERTY keyboard ( https://en.wikipedia.org/wiki/Keyboard_layout#/media/File:ISO_keyboard_(105)_QWERTY_UK.svg )  is pressed, no matter what the key is labelled or what the user's operating system settings are.</para>
            <para>Using scancodes, rather than keycodes, is useful because keyboards with layouts differing from the US/UK layout(s) might have keys that generate 'unknown' keycodes, but the scancodes will still be detected. This however would necessitate having a list for each keyboard layout one would choose to support.</para>
            <para>One could use textinput or textedited instead, but those only give back the end result of keys used, i.e. you can't get modifiers on their own from it, only the final symbols that were generated.</para>
            </summary>
        </member>
        <member name="T:Love.SourceType">
            <summary>
            <para>Types of audio sources. </para>
            <para>A good rule of thumb is to use Stream for music files and Static for all short sound effects. Basically, you want to avoid loading large files into memory at once.</para>
            </summary>
        </member>
        <member name="F:Love.SourceType.Static">
            <summary>
            Decode the entire sound at once.
            </summary>
        </member>
        <member name="F:Love.SourceType.Stream">
            <summary>
            Stream the sound; decode it gradually.
            </summary>
        </member>
        <member name="F:Love.StackType.All">
            <summary>
            All Love.Graphics state, including transform state.
            </summary>
        </member>
        <member name="F:Love.StackType.Transform">
            <summary>
            The transformation stack (Love.Graphics.translate, Love.Graphics.rotate, etc.)
            </summary>
        </member>
        <member name="T:Love.FullscreenType">
            <summary>
            <para>全屏模式的类型。</para>
            <para>Types of fullscreen modes.</para>
            </summary>
        </member>
        <member name="F:Love.FullscreenType.Exclusive">
            <summary>
            Standard exclusive-fullscreen mode. Changes the display mode (actual resolution) of the monitor.
            </summary>
        </member>
        <member name="F:Love.FullscreenType.DeskTop">
            <summary>
            Sometimes known as borderless fullscreen windowed mode. A borderless screen-sized window is created which sits on top of all desktop UI elements. The window is automatically resized to match the dimensions of the desktop, and its size cannot be changed.
            </summary>
        </member>
        <member name="T:Love.MessageBoxType">
            <summary>
            <para>消息框对话框的类型。</para>
            <para>Types of message box dialogs.</para>
            </summary>
        </member>
        <member name="F:Love.MessageBoxType.Error">
            <summary>
            Error dialog.
            </summary>
        </member>
        <member name="F:Love.MessageBoxType.Warning">
            <summary>
            Warning dialog.
            </summary>
        </member>
        <member name="F:Love.MessageBoxType.Info">
            <summary>
            Informational dialog.
            </summary>
        </member>
        <member name="T:Love.ArcType">
            <summary>
            Different types of arcs that can be drawn.
            </summary>
        </member>
        <member name="F:Love.ArcType.Open">
            <summary>
            The arc circle's two end-points are unconnected when the arc is drawn as a line. Behaves like the "closed" arc type when the arc is drawn in filled mode.
            </summary>
        </member>
        <member name="F:Love.ArcType.Closed">
            <summary>
            The arc circle's two end-points are connected to each other.
            </summary>
        </member>
        <member name="F:Love.ArcType.Pie">
            <summary>
            The arc is drawn like a slice of pie, with the arc circle connected to the center at its end-points.
            </summary>
        </member>
        <member name="T:Love.BlendMode">
            <summary>
            Different ways to do color blending. See BlendAlphaMode and the BlendMode Formulas for additional notes.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Alpha">
            <summary>
            Alpha blending (normal). The alpha of what's drawn determines its opacity.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Add">
            <summary>
            The pixel colors of what's drawn are added to the pixel colors already on the screen. The alpha of the screen is not modified.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Subtract">
            <summary>
            The pixel colors of what's drawn are subtracted from the pixel colors already on the screen. The alpha of the screen is not modified.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Multiply">
            <summary>
            The pixel colors of what's drawn are multiplied with the pixel colors already on the screen (darkening them). The alpha of drawn objects is multiplied with the alpha of the screen rather than determining how much the colors on the screen are affected, even when the <see cref="F:Love.BlendAlphaMode.PreMultiplied"/> BlendAlphaMode is used.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Lighten">
            <summary>
            The pixel colors of what's drawn are compared to the existing pixel colors, and the larger of the two values for each color component is used. Only works when the "premultiplied" BlendAlphaMode is used in <see cref="M:Love.Graphics.SetBlendMode(Love.BlendMode,Love.BlendAlphaMode)"/>
            </summary>
        </member>
        <member name="F:Love.BlendMode.Darken">
            <summary>
            The pixel colors of what's drawn are compared to the existing pixel colors, and the smaller of the two values for each color component is used. Only works when the "premultiplied" BlendAlphaMode is used in <see cref="M:Love.Graphics.SetBlendMode(Love.BlendMode,Love.BlendAlphaMode)"/>
            </summary>
        </member>
        <member name="F:Love.BlendMode.Screen">
            <summary>
            'Screen' blending.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Replace">
            <summary>
            The colors of what's drawn completely replace what was on the screen, with no additional blending. The BlendAlphaMode specified in love.graphics.setBlendMode still affects what happens.
            </summary>
        </member>
        <member name="T:Love.BlendAlphaMode">
            <summary>
            The "premultiplied" constant should generally be used when drawing a Canvas to the screen, because the RGB values of the Canvas' texture had previously been multiplied by its alpha values when drawing content to the Canvas itself.
            <para>The "alphamultiply" constant does not affect the "multiply" BlendMode.Similarly, the "screen" BlendMode's math is only correct if the "premultiplied" alpha mode is used and the alpha of drawn objects has already been multiplied with its RGB values previously (possibly inside a shader).</para>
            <para>https://love2d.org/wiki/BlendAlphaMode</para>
            </summary>
        </member>
        <member name="F:Love.BlendAlphaMode.Multiply">
            <summary>
            The RGB values of what's drawn are multiplied by the alpha values of those colors during blending. This is the default alpha mode.
            </summary>
        </member>
        <member name="F:Love.BlendAlphaMode.PreMultiplied">
            <summary>
            The RGB values of what's drawn are not multiplied by the alpha values of those colors during blending. For most blend modes to work correctly with this alpha mode, the colors of a drawn object need to have had their RGB values multiplied by their alpha values at some point previously ("premultiplied alpha").
            </summary>
        </member>
        <member name="T:Love.LineStyle">
            <summary>
            The styles in which lines are drawn.
            </summary>
        </member>
        <member name="F:Love.LineStyle.Rough">
            <summary>
            Draw rough lines.
            </summary>
        </member>
        <member name="F:Love.LineStyle.Smooth">
            <summary>
            Draw smooth lines.
            </summary>
        </member>
        <member name="T:Love.LineJoin">
            <summary>
            https://love2d.org/wiki/LineJoin
            </summary>
        </member>
        <member name="F:Love.LineJoin.None">
            <summary>
            No cap applied to the ends of the line segments.
            <para>https://love2d.org/wiki/LineJoin</para>
            </summary>
        </member>
        <member name="F:Love.LineJoin.Miter">
            <summary>
            The ends of the line segments beveled in an angle so that they join seamlessly.
            <para>https://love2d.org/wiki/LineJoin</para>
            </summary>
        </member>
        <member name="F:Love.LineJoin.Bevel">
            <summary>
            Flattens the point where line segments join together.
            <para>https://love2d.org/wiki/LineJoin</para>
            </summary>
        </member>
        <member name="T:Love.StencilAction">
            <summary>
            <para>How a stencil function modifies the stencil values of pixels it touches.</para>
            https://love2d.org/wiki/StencilAction
            </summary>
        </member>
        <member name="F:Love.StencilAction.Replace">
            <summary>
            The stencil value of a pixel will be replaced by the value specified in love.graphics.stencil, if any object touches the pixel.
            </summary>
        </member>
        <member name="F:Love.StencilAction.Increment">
            <summary>
            The stencil value of a pixel will be incremented by 1 for each object that touches the pixel. If the stencil value reaches 255 it will stay at 255.
            </summary>
        </member>
        <member name="F:Love.StencilAction.Decrement">
            <summary>
            The stencil value of a pixel will be decremented by 1 for each object that touches the pixel. If the stencil value reaches 0 it will stay at 0.
            </summary>
        </member>
        <member name="F:Love.StencilAction.IncrementWrap">
            <summary>
            The stencil value of a pixel will be incremented by 1 for each object that touches the pixel. If a stencil value of 255 is incremented it will be set to 0.
            </summary>
        </member>
        <member name="F:Love.StencilAction.DecrementWrap">
            <summary>
            The stencil value of a pixel will be decremented by 1 for each object that touches the pixel. If the stencil value of 0 is decremented it will be set to 255.
            </summary>
        </member>
        <member name="F:Love.StencilAction.Invert">
            <summary>
            The stencil value of a pixel will be bitwise-inverted for each object that touches the pixel. If a stencil value of 0 is inverted it will become 255.
            </summary>
        </member>
        <member name="T:Love.CompareMode">
            <summary>
            Different types of per-pixel stencil test comparisons. The pixels of an object will be drawn if the comparison succeeds, for each pixel that the object touches.
            <para>https://love2d.org/wiki/CompareMode</para>
            </summary>
        </member>
        <member name="F:Love.CompareMode.Less">
            <summary>
            The stencil value of the pixel must be less than the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.LEqual">
            <summary>
            The stencil value of the pixel must be less than or equal to the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.Equal">
            <summary>
            The stencil value of the pixel must be equal to the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.GEqual">
            <summary>
            The stencil value of the pixel must be greater than or equal to the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.Greater">
            <summary>
            The stencil value of the pixel must be greater than the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.NotEqual">
            <summary>
            The stencil value of the pixel must not be equal to the supplied value.
            </summary>
        </member>
        <member name="T:Love.Feature">
            <summary>
            https://love2d.org/wiki/GraphicsFeature
            <para>Graphics features that can be checked for with love.graphics.getSupported.</para>
            </summary>
        </member>
        <member name="F:Love.Feature.MultiCanvasFormats">
            <summary>
            Whether multiple Canvases with different formats can be used in the same love.graphics.setCanvas call.
            <para>multicanvasformats is supported on OpenGL 3-capable desktop systems, and OpenGL ES 3-capable mobile devices.</para>
            </summary>
        </member>
        <member name="F:Love.Feature.ClampZero">
            <summary>
            Whether the "clampzero" WrapMode is supported.
            <para>clampzero is supported on all desktop systems, but only some mobile devices. If it's not supported and it's attempted to be set, the "clamp" wrap mode will automatically be used instead.</para>
            </summary>
        </member>
        <member name="F:Love.Feature.Lighten">
            <summary>
            Whether the "lighten" and "darken" BlendModes are supported.
            <para>lighten is supported on all desktop systems, and OpenGL ES 3-capable mobile devices.</para>
            </summary>
        </member>
        <member name="F:Love.Feature.FullNPOT">
            <summary>
            Whether textures with non-power-of-two dimensions can use mipmapping and the 'repeat' WrapMode (Texture:setMipmapFilter).
            </summary>
        </member>
        <member name="F:Love.Feature.PixelShaderHighp">
            <summary>
            Whether pixel shaders can use "highp" 32 bit floating point numbers (as opposed to just 16 bit or lower precision).
            </summary>
        </member>
        <member name="F:Love.Feature.ShaderDerivatives">
            <summary>
            
            </summary>
        </member>
        <member name="F:Love.Feature.GLSL3">
            <summary>
            Whether GLSL 3 Shaders can be used.
            </summary>
        </member>
        <member name="F:Love.Feature.Instancing">
            <summary>
            Whether mesh instancing (love.graphics.drawInstanced) is supported.
            </summary>
        </member>
        <member name="T:Love.AreaSpreadDistribution">
            <summary>
            Type of distribution new particles are drawn from: None, uniform, normal, ellipse, borderellipse, borderrectangle.
            <para>https://love2d.org/wiki/AreaSpreadDistribution</para>
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.Uniform">
            <summary>
            Uniform distribution.
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.Normal">
            <summary>
            Normal (gaussian) distribution.
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.Ellipse">
            <summary>
            Uniform distribution in an ellipse.
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.BorderEllipse">
            <summary>
            Distribution in an ellipse with particles spawning at the edges of the ellipse.
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.BorderRectangle">
            <summary>
            Distribution in a rectangle with particles spawning at the edges of the rectangle.
            </summary>
        </member>
        <member name="T:Love.DrawMode">
            <summary>
            Controls whether shapes are drawn as an outline, or filled.
            </summary>
        </member>
        <member name="F:Love.DrawMode.Line">
            <summary>
            Draw outlined shape.
            </summary>
        </member>
        <member name="F:Love.DrawMode.Fill">
            <summary>
            Draw filled shape.
            </summary>
        </member>
        <member name="F:Love.SpriteBatchUsage.Stream">
            <summary>
            The object data will always change between draws.
            </summary>
        </member>
        <member name="F:Love.SpriteBatchUsage.Dynamic">
            <summary>
            The object's data will change occasionally during its lifetime.
            </summary>
        </member>
        <member name="F:Love.SpriteBatchUsage.Static">
            <summary>
            The object will not be modified after initial sprites or vertices are added.
            </summary>
        </member>
        <member name="T:Love.MeshDrawMode">
            <summary>
            https://love2d.org/wiki/MeshDrawMode
            </summary>
        </member>
        <member name="F:Love.MeshDrawMode.Trangles">
            <summary>
            The vertices create a "fan" shape with the first vertex acting as the hub point. Can be easily used to draw simple convex polygons.
            </summary>
        </member>
        <member name="F:Love.MeshDrawMode.Strip">
            <summary>
            The vertices create a series of connected triangles using vertices 1, 2, 3, then 3, 2, 4 (note the order), then 3, 4, 5, and so on.
            </summary>
        </member>
        <member name="F:Love.MeshDrawMode.Fan">
            <summary>
            The vertices create a "fan" shape with the first vertex acting as the hub point. Can be easily used to draw simple convex polygons.
            </summary>
        </member>
        <member name="F:Love.MeshDrawMode.Points">
            <summary>
            The vertices are drawn as unconnected points (see love.graphics.setPointSize.)
            </summary>
        </member>
        <member name="T:Love.PixelFormat">
            <summary>
            Pixel formats for Textures, ImageData, and CompressedImageData.
            https://love2d.org/wiki/PixelFormat
            </summary>
        </member>
        <member name="T:Love.CanvasMipmapMode">
            <summary>
            https://love2d.org/wiki/CanvasMipmapMode
            </summary>
        </member>
        <member name="F:Love.CanvasMipmapMode.None">
            <summary>
            Do not enable mipmap.
            </summary>
        </member>
        <member name="F:Love.CanvasMipmapMode.Manual">
            <summary>
            Let user manually generate mipmap.
            </summary>
        </member>
        <member name="F:Love.CanvasMipmapMode.Auto">
            <summary>
            Automatically generate mipmap.
            </summary>
        </member>
        <member name="T:Love.TextureType">
            <summary>
            Types of textures (2D, cubemap, etc.)
            </summary>
        </member>
        <member name="F:Love.TextureType.TEXTURE_2D">
            <summary>
            Regular 2D texture with width and height.
            </summary>
        </member>
        <member name="F:Love.TextureType.TEXTURE_VOLUME">
            <summary>
            3D texture with width, height, and depth. Requires a custom shader to use. Volume textures can have texture filtering applied along the 3rd axis.
            </summary>
        </member>
        <member name="F:Love.TextureType.TEXTURE_2D_ARRAY">
            <summary>
            Several same-size 2D textures organized into a single object. Similar to a texture atlas / sprite sheet, but avoids sprite bleeding and other issues.
            </summary>
        </member>
        <member name="F:Love.TextureType.TEXTURE_CUBE">
            <summary>
            Cubemap texture with 6 faces. Requires a custom shader (and Shader:send) to use. Sampling from a cube texture in a shader takes a 3D direction vector instead of a texture coordinate.
            </summary>
        </member>
        <member name="M:Love.Love2dGraphicsShaderBoot.createShaderStageCode(System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
             <summary>
            
             </summary>
             <param name="stage">"VERTEX" or "PIXEL"</param>
             <param name="code">input string</param>
             <param name="lang">glsl1 or glsl3</param>
             <param name="gles"></param>
             <param name="glsl1on3"></param>
             <param name="gammacorrect"></param>
             <param name="custom"></param>
             <returns></returns>
        </member>
        <member name="T:Love.LoveObject">
            <summary>
            LÖVE 引擎对象
            </summary>
        </member>
        <member name="M:Love.LoveObject.RetainLoveObject(System.IntPtr)">
            <summary>
            danger !!!!!
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:Love.LoveObject.Equals(System.Object)">
            <summary>
            如果两个 LoveObject 指向的非托管对象一样，那么则返回相等
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Love.LoveObject.GetHashCode">
            <summary>
            返回此实例的 IntPtr p 的哈希代码。
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Source">
            <summary>
            <para>A Source represents audio you can play back. You can do interesting things with Sources, like set the volume, pitch, and its position relative to the listener. Please note that positional audio only works for mono (i.e. non-stereo) sources.</para>
            </summary>
        </member>
        <member name="M:Love.Source.#ctor(System.IntPtr)">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.Source.Clone">
            <summary>
            Creates an identical copy of the Source in the stopped state.
            <para>Static Sources will use significantly less memory and take much less time to be created if <see cref="M:Love.Source.Clone"/> is used to create them instead of Audio.NewSource, so this method should be preferred when making multiple Sources which play the same sound.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Source.Play">
            <summary>
            Plays a source.
            </summary>
            <returns>Whether the Source was able to successfully start playing.</returns>
        </member>
        <member name="M:Love.Source.Stop">
            <summary>
            Stops a source.
            </summary>
        </member>
        <member name="M:Love.Source.Pause">
            <summary>
            Pauses the Source.
            </summary>
        </member>
        <member name="M:Love.Source.SetPitch(System.Single)">
            <summary>
            Sets the pitch of the Source.
            </summary>
            <param name="pitch">Calculated with regard to 1 being the base pitch. Each reduction by 50 percent equals a pitch shift of -12 semitones (one octave reduction). Each doubling equals a pitch shift of 12 semitones (one octave increase). Zero is not a legal value.</param>
        </member>
        <member name="M:Love.Source.GetPitch">
            <summary>
            Gets the current pitch of the Source.
            </summary>
            <returns>The pitch, where 1.0 is normal.</returns>
        </member>
        <member name="M:Love.Source.SetVolume(System.Single)">
            <summary>
            Sets the current volume of the Source.
            </summary>
            <param name="volume">The volume for a Source, where 1.0 is normal volume. Volume cannot be raised above 1.0.</param>
        </member>
        <member name="M:Love.Source.GetVolume">
            <summary>
            Gets the current volume of the Source.
            </summary>
            <returns>The volume of the Source, where 1.0 is normal volume.</returns>
        </member>
        <member name="M:Love.Source.Seek(System.Single,Love.TimeUnit)">
            <summary>
            Sets the currently playing position of the Source.
            </summary>
            <param name="offset">The position to seek to.</param>
            <param name="unit_type">The unit of the position value.</param>
        </member>
        <member name="M:Love.Source.Tell(Love.TimeUnit)">
            <summary>
            Gets the currently playing position of the Source.
            </summary>
            <param name="unit_type">The type of unit for the return value.</param>
            <returns>The currently playing position of the Source.</returns>
        </member>
        <member name="M:Love.Source.GetDuration(Love.TimeUnit)">
            <summary>
            Gets the duration of the Source.
            </summary>
            <param name="unit_type">The time unit for the return value.</param>
            <returns>The duration of the Source, or -1 if it cannot be determined.</returns>
        </member>
        <member name="M:Love.Source.SetPosition(System.Single,System.Single,System.Single)">
            <summary>
            Sets the position of the Source.
            </summary>
            <param name="x">The X position of the Source.</param>
            <param name="y">The Y position of the Source.</param>
            <param name="z">The Z position of the Source.</param>
        </member>
        <member name="M:Love.Source.GetPosition">
            <summary>
            Gets the position of the Source.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Source.SetVelocity(System.Single,System.Single,System.Single)">
            <summary>
            Sets the velocity of the Source.
            </summary>
            <param name="x">The X part of the velocity vector.</param>
            <param name="y">The Y part of the velocity vector.</param>
            <param name="z">The Z part of the velocity vector.</param>
        </member>
        <member name="M:Love.Source.GetVelocity">
            <summary>
            Gets the velocity of the Source.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Source.SetDirection(System.Single,System.Single,System.Single)">
            <summary>
            Sets the direction of the Source.
            </summary>
            <param name="x">The X part of the direction vector.</param>
            <param name="y">The Y part of the direction vector.</param>
            <param name="z">The Z part of the direction vector.</param>
        </member>
        <member name="M:Love.Source.GetDirection">
            <summary>
            Gets the direction of the Source.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Source.SetCone(System.Single,System.Single,System.Single)">
            <summary>
            Sets the Source's directional volume cones.
            </summary>
            <param name="innerAngle">The inner angle from the Source's direction, in radians. The Source will play at normal volume if the listener is inside the cone defined by this angle.</param>
            <param name="outerAngle">The outer angle from the Source's direction, in radians. The Source will play at a volume between the normal and outer volumes, if the listener is in between the cones defined by the inner and outer angles.</param>
            <param name="outerVolume">The Source's volume when the listener is outside both the inner and outer cone angles.</param>
        </member>
        <member name="M:Love.Source.GetCone(System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the Source's directional volume cones.
            </summary>
            <param name="out_innerAngle"></param>
            <param name="out_outerAngle"></param>
            <param name="out_outerVolume"></param>
        </member>
        <member name="M:Love.Source.SetRelative(System.Boolean)">
            <summary>
            Sets whether the Source's position and direction are relative to the listener.
            <para>By default, all sources are absolute and therefore relative to the origin of love's coordinate system [0, 0, 0]. Only absolute sources are affected by the position of the listener. Please note that positional audio only works for mono (i.e. non-stereo) sources.</para>
            </summary>
            <param name="relative">True to make the position, velocity, direction and cone angles relative to the listener, false to make them absolute.</param>
        </member>
        <member name="M:Love.Source.IsRelative">
            <summary>
            Gets whether the Source's position and direction are relative to the listener.
            </summary>
            <returns>True if the position, velocity, direction and cone angles are relative to the listener, false if they're absolute.</returns>
        </member>
        <member name="M:Love.Source.SetLooping(System.Boolean)">
            <summary>
            Sets whether the Source should loop.
            </summary>
            <param name="looping">True if the source should loop, false otherwise.</param>
        </member>
        <member name="M:Love.Source.IsLooping">
            <summary>
            Returns whether the Source will loop.
            </summary>
            <returns>True if the Source will loop, false otherwise.</returns>
        </member>
        <member name="M:Love.Source.IsPlaying">
            <summary>
            Returns whether the Source is playing.
            </summary>
            <returns>True if the Source is playing, false otherwise.</returns>
        </member>
        <member name="M:Love.Source.SetVolumeLimits(System.Single,System.Single)">
            <summary>
            Sets the volume limits of the source.
            </summary>
            <param name="vmin">The minimum volume.</param>
            <param name="vmax">The maximum volume.</param>
        </member>
        <member name="M:Love.Source.GetVolumeLimits(System.Single@,System.Single@)">
            <summary>
            Returns the volume limits of the source.
            </summary>
            <param name="out_vmin">The minimum volume.</param>
            <param name="out_vmax">The minimum volume.</param>
        </member>
        <member name="M:Love.Source.SetAttenuationDistances(System.Single,System.Single)">
            <summary>
            Sets the reference and maximum attenuation distances of the Source.
            <para>The parameters, combined with the current DistanceModel, affect how the Source's volume attenuates based on distance. Distance attenuation is only applicable to Sources based on mono (rather than stereo) audio.</para>
            </summary>
            <param name="dref">The new reference attenuation distance. If the current <see cref="T:Love.DistanceModel"/> is clamped, this is the minimum attenuation distance.</param>
            <param name="dmax"></param>
        </member>
        <member name="M:Love.Source.GetAttenuationDistances(System.Single@,System.Single@)">
            <summary>
            Gets the reference and maximum attenuation distances of the Source.
            <para>The values, combined with the current DistanceModel, affect how the Source's volume attenuates based on distance from the listener.</para>
            </summary>
            <param name="out_dref">The current reference attenuation distance. If the current <see cref="T:Love.DistanceModel"/> is clamped, this is the minimum distance before the Source is no longer attenuated.</param>
            <param name="out_dmax">The current maximum attenuation distance.</param>
        </member>
        <member name="M:Love.Source.SetRolloff(System.Single)">
            <summary>
            Sets the rolloff factor which affects the strength of the used distance attenuation. see <see cref="T:Love.DistanceModel"/>
            <para>Extended information and detailed formulas can be found in the chapter "3.4. Attenuation By Distance" of OpenAL 1.1 specification(https://www.openal.org/documentation/openal-1.1-specification.pdf).</para>
            </summary>
            <param name="rolloff">The new rolloff factor.</param>
        </member>
        <member name="M:Love.Source.GetRolloff">
            <summary>
            Returns the rolloff factor of the source.
            </summary>
            <returns>The rolloff factor.</returns>
        </member>
        <member name="M:Love.Source.GetChannelCount">
            <summary>
            Gets the number of channels in the Source. Only 1-channel (mono) Sources can use directional and positional effects.
            </summary>
            <returns>1 for mono, 2 for stereo.</returns>
        </member>
        <member name="M:Love.Source.GetSourceType">
            <summary>
            Gets the type of the Source.
            </summary>
            <returns>The type of the source.</returns>
        </member>
        <member name="T:Love.File">
            <summary>
            <para>Represents a file on the filesystem. A function that takes a file path can also take a <see cref="T:Love.File"/>.</para>
            </summary>
        </member>
        <member name="M:Love.File.#ctor(System.IntPtr)">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.File.GetSize">
            <summary>
            Returns the file size(in byte).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.File.Open(Love.FileMode)">
            <summary>
            Open the file for write, read or append.
            </summary>
            <param name="mode_type">The mode to open the file in.</param>
        </member>
        <member name="M:Love.File.Close">
            <summary>
            Closes a File.
            </summary>
            <returns>Whether closing was successful.</returns>
        </member>
        <member name="M:Love.File.IsOpen">
            <summary>
            Gets whether the file is open.
            </summary>
            <returns>True if the file is currently open, false otherwise.</returns>
        </member>
        <member name="M:Love.File.Read(System.Int64)">
            <summary>
            Read a number of bytes from a file
            </summary>
            <param name="size">The number of bytes to read.</param>
            <returns></returns>
        </member>
        <member name="M:Love.File.Write(System.Byte[],System.Int64)">
            <summary>
            Write data to a file.
            </summary>
            <param name="data">The byte data to write.</param>
            <param name="datasize">How many bytes to write.</param>
            <returns>Whether the operation was successful.</returns>
        </member>
        <member name="M:Love.File.Write(Love.Data,System.Int64)">
            <summary>
            Write data to a file.
            </summary>
            <param name="data">The Data object to write.</param>
            <param name="datasize">How many bytes to write.</param>
            <returns>Whether the operation was successful.</returns>
        </member>
        <member name="M:Love.File.Write(System.Byte[])">
            <summary>
            Write data to a file.
            </summary>
            <param name="data"></param>
            <returns>Whether the operation was successful.</returns>
        </member>
        <member name="M:Love.File.Write(Love.Data)">
            <summary>
            Write data to a file.
            </summary>
            <param name="data">The Data object to write.</param>
            <returns>Whether the operation was successful.</returns>
        </member>
        <member name="M:Love.File.Flush">
            <summary>
            Flushes any buffered written data in the file to disk.
            </summary>
        </member>
        <member name="M:Love.File.IsEOF">
            <summary>
            Gets whether end-of-file has been reached.
            </summary>
            <returns>Whether EOF has been reached.</returns>
        </member>
        <member name="M:Love.File.Tell">
            <summary>
            Returns the position in the file.
            </summary>
            <returns>The current position.</returns>
        </member>
        <member name="M:Love.File.Seek(System.Int64)">
            <summary>
            Seek to a position in a file
            </summary>
            <param name="pos">The position to seek to</param>
            <returns>Whether the operation was successful</returns>
        </member>
        <member name="M:Love.File.SetBuffer(Love.BufferMode,System.Int64)">
            <summary>
            <para>Sets the buffer mode for a file opened for writing or appending. Files with buffering enabled will not write data to the disk until the buffer size limit is reached, depending on the buffer mode.</para>
            <para><see cref="M:Love.File.Flush"/> will force any buffered data to be written to the disk.</para>
            </summary>
            <param name="bufmode_type">The buffer mode to use.</param>
            <param name="size">The maximum size in bytes of the file's buffer.</param>
            <returns>Whether the buffer mode was successfully set.</returns>
        </member>
        <member name="M:Love.File.GetBuffer(Love.BufferMode@,System.Int64@)">
            <summary>
            Gets the buffer mode of a file.
            </summary>
            <param name="out_bufmode_type">The current buffer mode of the file.</param>
            <param name="out_size">The maximum size in bytes of the file's buffer.</param>
        </member>
        <member name="M:Love.File.GetMode">
            <summary>
            Gets the <see cref="T:Love.FileMode"/> the file has been opened with.
            </summary>
            <returns>The mode this file has been opened with.</returns>
        </member>
        <member name="M:Love.File.GetFilename">
            <summary>
            Gets the filename that the File object was created with. If the file object originated from the <see cref="!:Scene.FileDropped(File)"/> callback, the filename will be the full platform-dependent file path.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.FileData">
            <summary>
            <see cref="T:Love.Data"/> representing the contents of a file.
            </summary>
        </member>
        <member name="M:Love.FileData.#ctor(System.IntPtr)">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.FileData.GetFilename">
            <summary>
            Gets the filename of the FileData.
            </summary>
            <returns>The name of the file the FileData represents.</returns>
        </member>
        <member name="M:Love.FileData.GetExtension">
            <summary>
            Gets the extension of the FileData.
            </summary>
            <returns>The extension of the file the FileData represents.</returns>
        </member>
        <member name="T:Love.GlyphData">
            <summary>
            A GlyphData represents a drawable symbol of a font Rasterizer.
            </summary>
        </member>
        <member name="M:Love.GlyphData.#ctor(System.IntPtr)">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="T:Love.Rasterizer">
            <summary>
            A Rasterizer handles font rendering, containing the font data (image or TrueType font) and drawable glyphs.
            </summary>
        </member>
        <member name="M:Love.Rasterizer.#ctor(System.IntPtr)">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.Rasterizer.GetHeight">
            <summary>
            Get font height
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Canvas">
            <summary>
            <para>A Canvas is used for off-screen rendering. Think of it as an invisible screen that you can draw to, but that will not be visible until you draw it to the actual visible screen. It is also known as "render to texture".</para>
            <para>By drawing things that do not change position often (such as background items) to the Canvas, and then drawing the entire Canvas instead of each item, you can reduce the number of draw operations performed each frame.</para>
            <para>When drawing content to a Canvas using regular alpha blending, the alpha values of the content get multiplied with its RGB values. Therefore the Canvas' pixel colors will have premultiplied alpha once it has been drawn to, so when drawing the Canvas to the screen or to another Canvas you must use premultiplied alpha blending – Graphics.SetBlendMode(BlendMode.Alpha, BlendAlphaMode.PreMultiplied).</para>
            </summary>
        </member>
        <member name="M:Love.Canvas.#ctor(System.IntPtr)">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.Canvas.NewImageData">
            <summary>
            Generates ImageData from the contents of the Canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.NewImageData(System.Int32,System.Int32)">
            <summary>
            Generates ImageData from the contents of the Canvas.
            </summary>
            <param name="slice">The cubemap face index, array index, or depth layer for cubemap, array, or volume type Canvases, respectively. This argument is ignored for regular 2D canvases.</param>
            <param name="mipmap">he mipmap index to use, for Canvases with mipmaps. https://love2d.org/wiki/CanvasMipmapMode </param>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.NewImageData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates ImageData from the contents of the Canvas.
            </summary>
            <param name="slice">The cubemap face index, array index, or depth layer for cubemap, array, or volume type Canvases, respectively. This argument is ignored for regular 2D canvases.</param>
            <param name="mipmap">he mipmap index to use, for Canvases with mipmaps. (default is 0) https://love2d.org/wiki/CanvasMipmapMode </param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="w"></param>
            <param name="h"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.GetFormat">
            <summary>
            Gets the texture format of the Canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.GetMSAA">
            <summary>
            Gets the number of MSAA samples used when drawing to the Canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.RenderTo(System.Action)">
            <summary>
            Render to the Canvas using a function. This is a shortcut to love.graphics.setCanvas.
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Love.Font.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Font.GetHeight">
            <summary>
            Gets the height of the Font in pixels.
            </summary>
            <returns>The height of the Font in pixels.</returns>
        </member>
        <member name="M:Love.Font.GetWidth(System.Byte[])">
            <summary>
            Determines the width of the given text.
            </summary>
            <param name="str">A string. </param>
            <returns>The width of the text.</returns>
        </member>
        <member name="M:Love.Font.SetLineHeight(System.Single)">
            <summary>
            Sets the line height. When rendering the font in lines the actual height will be determined by the line height multiplied by the height of the font. The default is 1.0.
            </summary>
            <param name="h">The new line height.</param>
        </member>
        <member name="M:Love.Font.GetLineHeight">
            <summary>
            Gets the line height. This will be the value previously set by <see cref="M:Love.Font.SetLineHeight(System.Single)"/>, or 1.0 by default.
            </summary>
            <returns>The current line height.</returns>
        </member>
        <member name="M:Love.Font.SetFilter(Love.FilterMode,Love.FilterMode,System.Single)">
            <summary>
            Sets the filter mode for a font.
            </summary>
            <param name="min_type">How to scale a font down.</param>
            <param name="mag_type">How to scale a font up.</param>
            <param name="anisotropy">Maximum amount of anisotropic filtering used.</param>
        </member>
        <member name="M:Love.Font.GetFilter(Love.FilterMode@,Love.FilterMode@,System.Single@)">
            <summary>
            Gets the filter mode for a font.
            </summary>
            <returns></returns>
            <param name="min_type">Filter mode used when minifying the font.</param>
            <param name="mag_type">Filter mode used when magnifying the font.</param>
            <param name="out_anisotropy">Maximum amount of anisotropic filtering used.</param>
        </member>
        <member name="M:Love.Font.GetAscent">
            <summary>
            Gets the ascent of the Font. The ascent spans the distance between the baseline and the top of the glyph that reaches farthest from the baseline.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Font.GetDescent">
            <summary>
            Gets the descent of the Font. The descent spans the distance between the baseline and the lowest descending glyph in a typeface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Font.GetBaseline">
            <summary>
            Gets the baseline of the Font. Most scripts share the notion of a baseline: an imaginary horizontal line on which characters rest. In some scripts, parts of glyphs lie below the baseline.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Font.HasGlyphs(System.Byte[])">
            <summary>
            Gets whether the Font can render a character or string.
            </summary>
            <param name="str">A string. </param>
            <returns>Whether the font can render all characters in the string.</returns>
        </member>
        <member name="M:Love.Font.SetFallbacks(Love.Font[])">
            <summary>
            Sets the fallback fonts. When the Font doesn't contain a glyph, it will substitute the glyph from the next subsequent fallback Fonts. This is akin to setting a "font stack" in Cascading Style Sheets (CSS).
            </summary>
            <param name="fallback">[The first fallback Font to use, ...Additional fallback Fonts.]</param>
        </member>
        <member name="M:Love.Font.NewGlyphData(Love.Rasterizer,System.String)">
            <summary>
            Creates a new GlyphData.
            </summary>
            <param name="rasterizer">The Rasterizer containing the font.</param>
            <param name="glyph">The character code of the glyph.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewRasterizer(System.String)">
            <summary>
            Creates a new Rasterizer.
            </summary>
            <param name="filename">The font file.</param>
            <returns>The rasterizer.</returns>
        </member>
        <member name="M:Love.Font.GetWidth(System.String)">
            <summary>
            Determines the width of the given text.
            </summary>
            <param name="str">A string.</param>
            <returns>The width of the text.</returns>
        </member>
        <member name="M:Love.Font.HasGlyphs(System.String)">
            <summary>
            Gets whether the Font can render a character or string.
            </summary>
            <param name="str">A string.</param>
            <returns>Whether the font can render all characters in the string.</returns>
        </member>
        <member name="M:Love.Font.GetWrap(System.String,System.Single)">
            <summary>
            Gets formatting information for text, given a wrap limit.
            </summary>
            <param name="text">The text that will be wrapped.</param>
            <param name="wrap_limit">The maximum width in pixels of each line that text is allowed before wrapping.</param>
            <returns>(The maximum width of the wrapped text., A sequence containing each line of text that was wrapped.)</returns>
        </member>
        <member name="M:Love.Font.NewRasterizer(Love.FileData)">
            <summary>
            Creates a new Rasterizer.
            </summary>
            <param name="fileData">The FileData of the font file.</param>
            <returns>The rasterizer.</returns>
        </member>
        <member name="M:Love.Font.NewTrueTypeRasterizer(Love.Data,System.Int32,Love.HintingMode)">
            <summary>
            Create a TrueTypeRasterizer with the font data.
            </summary>
            <param name="data">The data of to the TrueType font.</param>
            <param name="size">The font size.</param>
            <param name="hinting">True Type hinting mode.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewTrueTypeRasterizer(System.Int32,Love.HintingMode)">
            <summary>
            Create a TrueTypeRasterizer with the default font.
            </summary>
            <param name="size">The font size.</param>
            <param name="hinting">True Type hinting mode.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewBMFontRasterizer(Love.FileData,Love.ImageData[])">
            <summary>
            Creates a new BMFont Rasterizer.
            </summary>
            <param name="fileData">The file data of the BMFont.</param>
            <param name="imageDatas">The image data containing the drawable pictures of font glyphs.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewGlyphData(Love.Rasterizer,System.Byte[])">
            <summary>
            Creates a new GlyphData.
            </summary>
            <param name="rasterizer">The Rasterizer containing the font.</param>
            <param name="glyph">The character code of the glyph.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewGlyphData(Love.Rasterizer,System.Int32)">
            <summary>
            Creates a new GlyphData.
            </summary>
            <param name="rasterizer">The Rasterizer containing the font.</param>
            <param name="glyphCode">The character code of the glyph.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Image.IsCompressed">
            <summary>
            Gets whether the Image was created from <see cref="T:Love.CompressedImageData"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Image.ReplacePixels(Love.ImageData,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Replace the contents of an Image.
            </summary>
            <param name="imageData">The new ImageData to replace the contents with.</param>
            <param name="slice">Which cubemap face, array index, or volume layer to replace, if applicable.</param>
            <param name="mipmap">The mimap level to replace, if the Image has mipmaps.</param>
            <param name="x">The x-offset in pixels from the top-left of the image to replace. The given ImageData's width plus this value must not be greater than the pixel width of the Image's specified mipmap level.</param>
            <param name="y">The y-offset in pixels from the top-left of the image to replace. The given ImageData's height plus this value must not be greater than the pixel height of the Image's specified mipmap level.</param>
            <param name="reloadmipmaps">Whether to generate new mipmaps after replacing the Image's pixels. True by default if the Image was created with automatically generated mipmaps, false by default otherwise.</param>
        </member>
        <member name="M:Love.Image.NewImageData(System.UInt32,System.UInt32,Love.ImageDataPixelFormat,System.Byte[])">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="w">The width of the ImageData.</param>
            <param name="h">The height of the ImageData.</param>
            <param name="format">The pixel format of the ImageData.</param>
            <param name="data">Optional raw byte data to load into the ImageData, in the format specified by format.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewImageData(System.Int32,System.Int32,Love.ImageDataPixelFormat,System.Byte[])">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="w">The width of the ImageData.</param>
            <param name="h">The height of the ImageData.</param>
            <param name="format">The pixel format of the ImageData.</param>
            <param name="data">Optional raw byte data to load into the ImageData, in the format specified by format.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewImageData(Love.FileData)">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="data">The encoded file data to decode into image data.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewCompressedData(Love.FileData)">
            <summary>
            Create a new <see cref="T:Love.CompressedImageData"/> object from a compressed image file. LÖVE supports several compressed texture formats, enumerated in the <see cref="T:Love.PixelFormat"/> page.
            </summary>
            <param name="data">A FileData containing a compressed image.</param>
            <returns>The new CompressedImageData object.</returns>
        </member>
        <member name="M:Love.Image.IsCompressed(Love.FileData)">
            <summary>
            Determines whether a file can be loaded as <see cref="T:Love.CompressedImageData"/>.
            </summary>
            <param name="data">A FileData potentially containing a compressed image.</param>
            <returns>Whether the file can be loaded as <see cref="T:Love.CompressedImageData"/> or not.</returns>
        </member>
        <member name="M:Love.Image.NewImageData(System.String)">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="filename">The filename of the image file.</param>
            <returns>The new ImageData object.</returns>
        </member>
        <member name="M:Love.Image.NewCompressedData(System.String)">
            <summary>
            Create a new <see cref="T:Love.CompressedImageData"/> object from a compressed image file. LÖVE supports several compressed texture formats, enumerated in the <see cref="T:Love.PixelFormat"/> page.
            </summary>
            <param name="filename">The filename of the compressed image file.</param>
            <returns>The new CompressedImageData object.</returns>
        </member>
        <member name="M:Love.Image.NewImageData(Love.Vector4[0:,0:],Love.ImageDataPixelFormat)">
            <summary>
            Creates a new ImageData object. -----  Vector4[x, y]
            <para> Vector4[x, y] - new Vector4(0.1f, 0.2f, 0.3f, 0.4f) </para>
            </summary>
            <param name="rawData">color data to set</param>
            <param name="format">The pixel format of the ImageData.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewImageData(Love.Vector4[][],Love.ImageDataPixelFormat)">
            <summary>
            Creates a new ImageData object. -----  Vector4[x][y]
            </summary>
            <param name="rawData">Optional raw byte data to load into the ImageData, in the format specified by format.</param>
            <param name="format">The pixel format of the ImageData.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewImageData(Love.Color[][],Love.ImageDataPixelFormat)">
            <summary>
            Creates a new ImageData object. -----  Color[x][y]
            </summary>
            <param name="rawData">Optional raw byte data to load into the ImageData, in the format specified by format.</param>
            <param name="format">The pixel format of the ImageData.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewImageData(Love.Color[0:,0:],Love.ImageDataPixelFormat)">
            <summary>
            Creates a new ImageData object. -----  Color[x, y]
            </summary>
            <param name="rawData">Optional raw byte data to load into the ImageData, in the format specified by format.</param>
            <param name="format">The pixel format of the ImageData.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.IsCompressed(System.String)">
            <summary>
            Determines whether a file can be loaded as <see cref="T:Love.CompressedImageData"/>.
            </summary>
            <param name="filename">The filename of the potentially compressed image file.</param>
            <returns>Whether the file can be loaded as <see cref="T:Love.CompressedImageData"/> or not.</returns>
        </member>
        <member name="T:Love.Mesh">
            <summary>
            Mesh in Love2d CS is different from  love2d lua.
            </summary>
        </member>
        <member name="M:Love.Mesh.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="T:Love.ParticleSystem">
            <summary>
            A ParticleSystem can be used to create particle effects like fire or smoke.
            <para>The particle system has to be created using <see cref="M:Love.Graphics.NewParticleSystem(Love.Texture,System.Int32)"/>. Just like any other <see cref="T:Love.Drawable"/> it can be drawn to the screen using love.graphics.draw. You also have to call <see cref="M:Love.ParticleSystem.Update(System.Single)"/> in the update callback to see any changes in the particles emitted.</para>
            <para>The particle system won't create any particles unless you call <see cref="M:Love.ParticleSystem.SetParticleLifetime(System.Single,System.Single)"/> and <see cref="M:Love.ParticleSystem.SetEmissionRate(System.Single)"/>.</para>
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.GetOffset">
            <summary>
            Get the offset position which the particle sprite is rotated around. If this function is not used, the particles rotate around their center.
            </summary>
            <returns>The coordinate of the rotation offset.</returns>
        </member>
        <member name="M:Love.ParticleSystem.Clone">
            <summary>
            Creates an identical copy of the ParticleSystem in the stopped state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ParticleSystem.SetTexture(Love.Texture)">
            <summary>
            Sets the texture (Image or Canvas) to be used for the particles.
            </summary>
            <param name="texture">An Image or Canvas to use for the particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetTexture">
            <summary>
            Gets the texture (Image or Canvas) used for the particles.
            </summary>
            <returns>The Image or Canvas used for the particles.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetBufferSize(System.UInt32)">
            <summary>
            Sets the size of the buffer (the max allowed amount of particles in the system).
            </summary>
            <param name="buffersize">The buffer size.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetBufferSize">
            <summary>
            Gets the maximum number of particles the ParticleSystem can have at once.
            </summary>
            <returns>The maximum number of particles.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetInsertMode(Love.ParticleInsertMode)">
            <summary>
            Sets the mode to use when the ParticleSystem adds new particles.
            </summary>
            <param name="mode_type">The mode to use when the ParticleSystem adds new particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetInsertMode">
            <summary>
            Gets the mode used when the ParticleSystem adds new particles.
            </summary>
            <returns>The mode used when the ParticleSystem adds new particles.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetEmissionRate(System.Single)">
            <summary>
            Sets the amount of particles emitted per second.
            </summary>
            <param name="rate">The amount of particles per second.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetEmissionRate">
            <summary>
            Gets the amount of particles emitted per second.
            </summary>
            <returns>The amount of particles per second.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetEmitterLifetime(System.Single)">
            <summary>
            Sets how long the particle system should emit particles (if -1 then it emits particles forever).
            </summary>
            <param name="lifetime">The lifetime of the emitter (in seconds).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetEmitterLifetime">
            <summary>
            Gets how long the particle system will emit particles (if -1 then it emits particles forever).
            </summary>
            <returns>The lifetime of the emitter (in seconds).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetParticleLifetime(System.Single,System.Single)">
            <summary>
            Sets the lifetime of the particles.
            </summary>
            <param name="min">The minimum life of the particles (in seconds).</param>
            <param name="max">The maximum life of the particles (in seconds).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetParticleLifetime(System.Int32@,System.Int32@)">
            <summary>
            Gets the lifetime of the particles.
            </summary>
            <param name="out_min">The minimum life of the particles (in seconds).</param>
            <param name="out_max">The maximum life of the particles (in seconds).</param>
        </member>
        <member name="M:Love.ParticleSystem.SetPosition(System.Single,System.Single)">
            <summary>
            Sets the position of the emitter.
            </summary>
            <param name="x">Position along x-axis.</param>
            <param name="y">Position along y-axis.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetPosition">
            <summary>
            Gets the position of the emitter.
            </summary>
            <returns>Position of the emitter.</returns>
        </member>
        <member name="M:Love.ParticleSystem.MoveTo(System.Single,System.Single)">
            <summary>
            Moves the position of the emitter.
            This results in smoother particle spawning behaviour than if ParticleSystem.SetPosition is used every frame.
            </summary>
            <param name="x">Position along x-axis.</param>
            <param name="y">Position along y-axis.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetAreaSpread(Love.AreaSpreadDistribution@,System.Single@,System.Single@)">
            <summary>
            Gets the area-based spawn parameters for the particles.
            </summary>
            <param name="out_distribution_type">The type of distribution for new particles.</param>
            <param name="out_x"></param>
            <param name="out_y"></param>
        </member>
        <member name="M:Love.ParticleSystem.SetEmissionArea(Love.AreaSpreadDistribution,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets area-based spawn parameters for the particles. Newly created particles will spawn in an area around the emitter based on the parameters to this function.
            </summary>
            <param name="distribution">The type of distribution for new particles.</param>
            <param name="dx">The maximum spawn distance from the emitter along the x-axis for uniform distribution, or the standard deviation along the x-axis for normal distribution.</param>
            <param name="dy">The maximum spawn distance from the emitter along the y-axis for uniform distribution, or the standard deviation along the y-axis for normal distribution.</param>
            <param name="angle">The angle in radians of the emission area.</param>
            <param name="directionRelativeToCenter">True if newly spawned particles will be oriented relative to the center of the emission area, false otherwise.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetDirection(System.Single)">
            <summary>
            Sets the direction the particles will be emitted in.
            </summary>
            <param name="direction">The direction of the particles(in radians).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetDirection">
            <summary>
            Gets the direction of the particle emitter (in radians).
            </summary>
            <returns>The direction of the emitter (radians).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetSpread(System.Single)">
            <summary>
            Sets the amount of spread for the system.
            </summary>
            <param name="spread">The amount of spread (radians).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSpread">
            <summary>
            Gets the amount of directional spread of the particle emitter (in radians).
            </summary>
            <returns>The spread of the emitter (radians).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetSpeed(System.Single,System.Single)">
            <summary>
            Sets the speed of the particles.
            </summary>
            <param name="min">The minimum linear speed of the particles.</param>
            <param name="max">The maximun linear speed of the particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSpeed(System.Single@,System.Single@)">
            <summary>
            Gets the speed of the particles.
            </summary>
            <param name="out_min">The minimum linear speed of the particles.</param>
            <param name="out_max">The maximum linear speed of the particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetLinearAcceleration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the linear acceleration (acceleration along the x and y axes) for particles.
            <para>Every particle created will accelerate along the x and y axes between xmin,ymin and xmax,ymax.</para>
            </summary>
            <param name="xmin">The minimum acceleration along the x axis.</param>
            <param name="ymin">The minimum acceleration along the y axis.</param>
            <param name="xmax">The maximum acceleration along the x axis.</param>
            <param name="ymax">The maximum acceleration along the y axis.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetLinearAcceleration(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the linear acceleration (acceleration along the x and y axes) for particles.
            <para>Every particle created will accelerate along the x and y axes between xmin,ymin and xmax,ymax.</para>
            </summary>
            <param name="out_xmin">The minimum acceleration along the x axis.</param>
            <param name="out_ymin">The minimum acceleration along the y axis.</param>
            <param name="out_xmax">The maximum acceleration along the x axis.</param>
            <param name="out_ymax">The maximum acceleration along the y axis.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetRadialAcceleration(System.Single,System.Single)">
            <summary>
            Set the radial acceleration (away from the emitter).
            </summary>
            <param name="min">The minimum acceleration.</param>
            <param name="max">The maximum acceleration.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetRadialAcceleration(System.Int32@,System.Int32@)">
            <summary>
            Gets the radial acceleration (away from the emitter).
            </summary>
            <param name="out_min">The minimum acceleration.</param>
            <param name="out_max">The maximum acceleration.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetTangentialAcceleration(System.Single,System.Single)">
            <summary>
            Sets the tangential acceleration (acceleration perpendicular to the particle's direction).
            </summary>
            <param name="min">The minimum acceleration.</param>
            <param name="max">The maximum acceleration.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetTangentialAcceleration(System.Int32@,System.Int32@)">
            <summary>
            Gets the tangential acceleration (acceleration perpendicular to the particle's direction).
            </summary>
            <param name="out_min">The minimum acceleration.</param>
            <param name="out_max">The maximum acceleration.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetLinearDamping(System.Single,System.Single)">
            <summary>
            Sets the amount of linear damping (constant deceleration) for particles.
            </summary>
            <param name="min">The minimum amount of linear damping applied to particles.</param>
            <param name="max">The maximum amount of linear damping applied to particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetLinearDamping(System.Int32@,System.Int32@)">
            <summary>
            Gets the amount of linear damping (constant deceleration) for particles.
            </summary>
            <param name="out_min">The minimum amount of linear damping applied to particles.</param>
            <param name="out_max">The maximum amount of linear damping applied to particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetSizes(System.Single[])">
            <summary>
            Sets a series of sizes by which to scale a particle sprite. 1.0 is normal size. The particle system will interpolate between each size evenly over the particle's lifetime.
            <para>At least one size must be specified.A maximum of eight may be used.</para>
            </summary>
            <param name="sizeArray">The size array.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSizes">
            <summary>
            Gets the series of sizes by which the sprite is scaled. 1.0 is normal size. The particle system will interpolate between each size evenly over the particle's lifetime.
            </summary>
            <returns>The size array.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetSizeVariation(System.Single)">
            <summary>
            Sets the amount of size variation (0 meaning no variation and 1 meaning full variation between start and end).
            </summary>
            <param name="variation">The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSizeVariation">
            <summary>
            Gets the amount of size variation (0 meaning no variation and 1 meaning full variation between start and end).
            </summary>
            <returns>The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetRotation(System.Single,System.Single)">
            <summary>
            Sets the rotation of the image upon particle creation (in radians).
            </summary>
            <param name="min">The minimum initial angle (radians).</param>
            <param name="max">The maximum initial angle (radians).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetRotation(System.Int32@,System.Int32@)">
            <summary>
            Gets the rotation of the image upon particle creation (in radians).
            </summary>
            <param name="out_min">The minimum initial angle (radians).</param>
            <param name="out_max">The maximum initial angle (radians).</param>
        </member>
        <member name="M:Love.ParticleSystem.SetSpin(System.Single,System.Single)">
            <summary>
            Sets the spin of the sprite.
            </summary>
            <param name="start">The minimum spin (radians per second).</param>
            <param name="end">The maximum spin (radians per second).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSpin(System.Single@,System.Single@)">
            <summary>
            Gets the spin of the sprite.
            </summary>
            <param name="out_start">The minimum spin (radians per second).</param>
            <param name="out_end">The maximum spin (radians per second).</param>
        </member>
        <member name="M:Love.ParticleSystem.SetSpinVariation(System.Single)">
            <summary>
            Sets the amount of spin variation (0 meaning no variation and 1 meaning full variation between start and end).
            </summary>
            <param name="variation">The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSpinVariation">
            <summary>
            Gets the amount of spin variation (0 meaning no variation and 1 meaning full variation between start and end).
            </summary>
            <returns>The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetOffset(System.Single,System.Single)">
            <summary>
            Set the offset position which the particle sprite is rotated around. If this function is not used, the particles rotate around their center.
            </summary>
            <param name="x">The x coordinate of the rotation offset.</param>
            <param name="y">The y coordinate of the rotation offset.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetOffset(System.Single@,System.Single@)">
            <summary>
            Get the offset position which the particle sprite is rotated around. If this function is not used, the particles rotate around their center.
            </summary>
            <param name="out_x">The x coordinate of the rotation offset.</param>
            <param name="out_y">The y coordinate of the rotation offset.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetColors(Love.Vector4[])">
            <summary>
            <para>Sets a series of colors to apply to the particle sprite. The particle system will interpolate between each color evenly over the particle's lifetime.</para>
            <para>Arguments can be passed in groups of four, representing the components of the desired RGBA value, or as tables of RGBA component values, with a default alpha value of 1 if only three values are given. At least one color must be specified. A maximum of eight may be used.</para>
            </summary>
            <param name="colorArray"></param>
        </member>
        <member name="M:Love.ParticleSystem.GetColors">
            <summary>
            Gets the series of colors applied to the particle sprite.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ParticleSystem.SetQuads(Love.Quad[])">
            <summary>
            Sets a series of Quads to use for the particle sprites. Particles will choose a Quad from the list based on the particle's current lifetime, allowing for the use of animated sprite sheets with ParticleSystems.
            </summary>
            <param name="quads">The Quads to use.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetQuads">
            <summary>
            Gets the series of Quads used for the particle sprites.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ParticleSystem.SetRelativeRotation(System.Boolean)">
            <summary>
            Sets whether particle angles and rotations are relative to their velocities. If enabled, particles are aligned to the angle of their velocities and rotate relative to that angle.
            </summary>
            <param name="enable">True to enable relative particle rotation, false to disable it.</param>
        </member>
        <member name="M:Love.ParticleSystem.HasRelativeRotation">
            <summary>
            Gets whether particle angles and rotations are relative to their velocities. If enabled, particles are aligned to the angle of their velocities and rotate relative to that angle.
            </summary>
            <returns>True if relative particle rotation is enabled, false if it's disabled.</returns>
        </member>
        <member name="M:Love.ParticleSystem.GetCount">
            <summary>
            Gets the number of particles that are currently in the system.
            </summary>
            <returns>The current number of live particles.</returns>
        </member>
        <member name="M:Love.ParticleSystem.Start">
            <summary>
            Starts the particle emitter.
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Stop">
            <summary>
            Stops the particle emitter, resetting the lifetime counter.
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Pause">
            <summary>
            Pauses the particle emitter.
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Reset">
            <summary>
            Resets the particle emitter, removing any existing particles and resetting the lifetime counter.
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Emit(System.Int32)">
            <summary>
            Emits a burst of particles from the particle emitter.
            </summary>
            <param name="num">The amount of particles to emit. The number of emitted particles will be truncated if the particle system's max buffer size is reached.</param>
        </member>
        <member name="M:Love.ParticleSystem.IsActive">
            <summary>
            Checks whether the particle system is actively emitting particles.
            </summary>
            <returns>True if system is active, false otherwise.</returns>
        </member>
        <member name="M:Love.ParticleSystem.IsPaused">
            <summary>
            Checks whether the particle system is paused.
            </summary>
            <returns>True if system is paused, false otherwise.</returns>
        </member>
        <member name="M:Love.ParticleSystem.IsStopped">
            <summary>
            Checks whether the particle system is stopped.
            </summary>
            <returns>True if system is stopped, false otherwise.</returns>
        </member>
        <member name="M:Love.ParticleSystem.Update(System.Single)">
            <summary>
            Updates the particle system; moving, creating and killing particles.
            </summary>
            <param name="dt">The time (seconds) since last frame.</param>
        </member>
        <member name="T:Love.Quad">
            <summary>
            A quadrilateral (a polygon with four sides and four corners) with texture coordinate information.
            <para>Quads can be used to select part of a texture to draw. In this way, one large texture atlas can be loaded, and then split up into sub-images.</para>
            <para>Quads 'bleed' when scaled, rotated or drawn at non-integer coordinates, even within SpriteBatches, to compensate for this, use 1px borders around the textures inside the texture atlas (preferably with the same colors as the actual border)</para>
            </summary>
        </member>
        <member name="M:Love.Quad.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Quad.SetViewport(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the texture coordinates according to a viewport.
            </summary>
            <param name="x">The top-left corner along the x-axis.</param>
            <param name="y">The top-right corner along the y-axis.</param>
            <param name="w">The width of the viewport.</param>
            <param name="h">The height of the viewport.</param>
        </member>
        <member name="M:Love.Quad.GetViewport(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the texture coordinates according to a viewport.
            </summary>
            <param name="out_x">The top-left corner along the x-axis.</param>
            <param name="out_y">The top-right corner along the y-axis.</param>
            <param name="out_w">The width of the viewport.</param>
            <param name="out_h">The height of the viewport.</param>
        </member>
        <member name="M:Love.Quad.GetTextureDimensions(System.Single@,System.Single@)">
            <summary>
            Gets reference texture dimensions initially specified in love.graphics.newQuad.
            </summary>
            <returns>The Texture size used by the Quad.</returns>
        </member>
        <member name="M:Love.Quad.GetViewport">
            <summary>
            Gets the texture coordinates according to a viewport.
            </summary>
            <returns>The size of the viewport</returns>
        </member>
        <member name="M:Love.Quad.SetViewport(Love.RectangleF)">
            <summary>
            Gets the texture coordinates according to a viewport.
            </summary>
            <returns>The size of the viewport</returns>
        </member>
        <member name="M:Love.Quad.GetTextureDimensions">
            <summary>
            Gets reference texture dimensions initially specified in love.graphics.newQuad.
            </summary>
            <returns>The Texture size used by the Quad.</returns>
        </member>
        <member name="T:Love.Shader">
            <summary>
            A Shader is used for advanced hardware-accelerated pixel or vertex manipulation. These effects are written in a language based on GLSL (OpenGL Shading Language) with a few things simplified for easier coding.
            <para>Potential uses for shaders include HDR/bloom, motion blur, grayscale/invert/sepia/any kind of color effect, reflection/refraction, distortions, bump mapping, and much more! Here is a collection of basic shaders and good starting point to learn: https://github.com/vrld/moonshine </para>
            </summary>
        </member>
        <member name="M:Love.Shader.#ctor(System.IntPtr)">
            <summary>
            Use Graphics.NewShader(...) to create Shader !
            </summary>
        </member>
        <member name="M:Love.Shader.GetWarnings">
            <summary>
            Gets warning and error messages (if any).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Shader.SendColors(System.String,Love.Vector4[])">
            <summary>
            Sends one or more colors to a special (extern / uniform) vec3 or vec4 variable inside the shader. The color components must be in the range of [0, 1]. The colors are gamma-corrected if global gamma-correction is enabled.
            </summary>
            <param name="name">The name of the color extern variable to send to in the shader. </param>
            <param name="valueArray">A array with red, green, blue, and alpha color components in the range of [0, 1] to send to the extern as a vector.</param>
        </member>
        <member name="M:Love.Shader.SendFloats(System.String,System.Single[])">
            <summary>
            Sends one or more float values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the float to send to the shader. </param>
            <param name="valueArray">Float to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendUints(System.String,System.UInt32[])">
            <summary>
            Sends one or more uint values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the uint to send to the shader. </param>
            <param name="valueArray">Uint to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendInts(System.String,System.Int32[])">
            <summary>
            Sends one or more int values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the int to send to the shader. </param>
            <param name="valueArray">Int to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendBooleans(System.String,System.Boolean[])">
            <summary>
            Sends one or more boolean values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the boolean to send to the shader. </param>
            <param name="valueArray">Boolean to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.String,System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            WARNNING: incorrect use of this function can carsh program.
            <para> params of valueArray.Length should equals columns * rows * count </para>
            </summary>
            <param name="name">uniform variable name</param>
            <param name="valueArray">each float consistute matrix array</param>
            <param name="columns">matrix columns</param>
            <param name="rows">matrix rows</param>
            <param name="count">matrix count</param>
        </member>
        <member name="M:Love.Shader.SendTexture(System.String,Love.Texture[])">
            <summary>
            Sends one or more texture to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Texture to send to the shader.</param>
            <param name="texture">Texture (Image or Canvas) to send to the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendVector2(System.String,Love.Vector2[])">
            <summary>
            Sends one or more Vector2 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector2 to send to the shader.</param>
            <param name="valueArray">Vector2 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendVector3(System.String,Love.Vector3[])">
            <summary>
            Sends one or more Vector3 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector3 to send to the shader.</param>
            <param name="valueArray">Vector3 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendVector4(System.String,Love.Vector4[])">
            <summary>
            Sends one or more Vector4 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector4 to send to the shader.</param>
            <param name="valueArray">Vector4 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Vector2[])">
            <summary>
            Sends one or more Vector2 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector2 to send to the shader.</param>
            <param name="valueArray">Vector2 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Vector3[])">
            <summary>
            Sends one or more Vector3 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector3 to send to the shader.</param>
            <param name="valueArray">Vector3 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Vector4[])">
            <summary>
            Sends one or more Vector4 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector4 to send to the shader.</param>
            <param name="valueArray">Vector4 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,System.Single[])">
            <summary>
            Sends one or more float values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the float to send to the shader.</param>
            <param name="valueArray">Float to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,System.UInt32[])">
            <summary>
            Sends one or more uint values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the uint to send to the shader.</param>
            <param name="valueArray">Uint to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,System.Int32[])">
            <summary>
            Sends one or more int values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the int to send to the shader.</param>
            <param name="valueArray">Int to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,System.Boolean[])">
            <summary>
            Sends one or more boolean values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the boolean to send to the shader.</param>
            <param name="valueArray">Boolean to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Matrix22[])">
            <summary>
            Sends one or more Matrix22 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Matrix22 to send to the shader.</param>
            <param name="valueArray">Matrix22 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Matrix33[])">
            <summary>
            Sends one or more Matrix33 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Matrix33 to send to the shader.</param>
            <param name="valueArray">Matrix33 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Matrix44[])">
            <summary>
            Sends one or more SendMatrix values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the SendMatrix to send to the shader.</param>
            <param name="valueArray">SendMatrix to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Texture)">
            <summary>
            Sends one or more texture to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Texture to send to the shader.</param>
            <param name="texture">Texture (Image or Canvas) to send to the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendColors(System.String,Love.Color[])">
            <summary>
            Sends one or more colors to a special (extern / uniform) vec3 or vec4 variable inside the shader. The color components must be in the range of [0, 1]. The colors are gamma-corrected if global gamma-correction is enabled.
            </summary>
            <param name="name">The name of the color extern variable to send to in the shader.</param>
            <param name="valueArray">A array with red, green, blue, and alpha color components in the range of [0, 1] to send to the extern as a vector.</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.String,Love.Matrix22[])">
            <summary>
            Sends one or more Matrix22 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Matrix22 to send to the shader.</param>
            <param name="valueArray">Matrix22 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.String,Love.Matrix33[])">
            <summary>
            Sends one or more Matrix33 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Matrix33 to send to the shader.</param>
            <param name="valueArray">Matrix33 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.String,Love.Matrix44[])">
            <summary>
            Sends one or more SendMatrix values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the SendMatrix to send to the shader.</param>
            <param name="valueArray">SendMatrix to send to store in the uniform variable.</param>
        </member>
        <member name="T:Love.SpriteBatch">
            <summary>
            Using a single image, draw any number of identical copies of the image using a single call to Love.Graphics.Draw(). This can be used, for example, to draw repeating copies of a single background image with high performance.
            <para>A SpriteBatch can be even more useful when the underlying image is a texture atlas (a single image file containing many independent images); by adding Quads to the batch, different sub-images from within the atlas can be drawn.</para>
            </summary>
        </member>
        <member name="M:Love.SpriteBatch.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Text.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Text.GetWidth(System.Int32)">
            <summary>
            Gets the width of the text in pixels.
            </summary>
            <param name="index">An index number returned by Text:add or Text:addf.</param>
            <returns>The width of the sub-string (before scaling and other transformations).</returns>
        </member>
        <member name="M:Love.Text.GetHeight(System.Int32)">
            <summary>
            Gets the height of the text in pixels.
            </summary>
            <param name="index">An index number returned by Text:add or Text:addf.</param>
            <returns>The height of the sub-string (before scaling and other transformations).</returns>
        </member>
        <member name="T:Love.Texture">
            <summary>
            Superclass for drawable objects which represent a texture. All Textures can be drawn with Quads. This is an abstract type that can't be created directly.
            </summary>
        </member>
        <member name="M:Love.Texture.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Texture.SetMipmapFilter(Love.FilterMode,System.Single)">
            <summary>
            Sets the mipmap filter mode for a Texture.
            <para>Mipmapping(https://en.wikipedia.org/wiki/Mipmap) is useful when drawing a texture at a reduced scale. It can improve performance and reduce aliasing issues.</para>
            <para>The texture must be created with the mipmaps flag enabled for the mipmap filter to have any effect. </para>
            <remarks>On mobile devices (Android and iOS), the sharpness parameter is not supported and will do nothing. You can use a custom Shader instead, and specify the mipmap sharpness in the optional third parameter to the Texel function in the shader (a negative value makes the texture use a more detailed mipmap level.)</remarks>
            </summary>
            <param name="mipmap_type">The filter mode to use in between mipmap levels. "nearest" will often give better performance.</param>
            <param name="sharpness">A positive sharpness value makes the texture use a more detailed mipmap level when drawing, at the expense of performance. A negative value does the reverse.</param>
        </member>
        <member name="M:Love.Texture.GetMipmapFilter(Love.FilterMode@,System.Single@)">
            <summary>
            Gets the mipmap filter mode for a Texture.
            </summary>
            <param name="out_mipmap_type">The filter mode used in between mipmap levels. nil if mipmap filtering is not enabled.</param>
            <param name="out_sharpness">Value used to determine whether the image should use more or less detailed mipmap levels than normal when drawing.</param>
        </member>
        <member name="M:Love.Texture.GetMipmapCount">
            <summary>
            Gets the number of mipmaps contained in the Texture. If the texture was not created with mipmaps, it will return 0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Texture.GetWidth">
            <summary>
            Gets the width of the Texture.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Texture.GetHeight">
            <summary>
            Gets the height of the Texture.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Texture.SetFilter(Love.FilterMode,Love.FilterMode,System.Single)">
            <summary>
            Sets the filter mode of the Texture.
            </summary>
            <param name="filtermin_type">Filter mode to use when minifying the texture (rendering it at a smaller size on-screen than its size in pixels).</param>
            <param name="filtermag_type">Filter mode to use when magnifying the texture (rendering it at a larger size on-screen than its size in pixels).</param>
            <param name="anisotropy">Maximum amount of anisotropic filtering to use.</param>
        </member>
        <member name="M:Love.Texture.GetFilter(Love.FilterMode@,Love.FilterMode@,System.Single@)">
            <summary>
            Gets the filter mode of the Texture.
            </summary>
            <param name="out_filtermin_type">Filter mode to use when minifying the texture (rendering it at a smaller size on-screen than its size in pixels).</param>
            <param name="out_filtermag_type">Filter mode to use when magnifying the texture (rendering it at a smaller size on-screen than its size in pixels).</param>
            <param name="out_anisotropy">Maximum amount of anisotropic filtering used.</param>
        </member>
        <member name="M:Love.Texture.SetWrap(Love.WrapMode,Love.WrapMode)">
            <summary>
            Sets the wrapping properties of a Texture.
            <para>This function sets the way a Texture is repeated when it is drawn with a Quad that is larger than the texture's extent, or when a custom Shader is used which uses texture coordinates outside of [0, 1]. A texture may be clamped or set to repeat in both horizontal and vertical directions.</para>
            <para>Clamped textures appear only once (with the edges of the texture stretching to fill the extent of the Quad), whereas repeated ones repeat as many times as there is room in the Quad.</para>
            </summary>
            <param name="wraphoriz_type">Horizontal wrapping mode of the texture.</param>
            <param name="wrapvert_type">Vertical wrapping mode of the texture.</param>
        </member>
        <member name="M:Love.Texture.GetWrap(Love.WrapMode@,Love.WrapMode@)">
            <summary>
            Gets the wrapping properties of a Texture.
            <para>This function returns the currently set horizontal and vertical wrapping modes for the texture.</para>
            </summary>
            <param name="out_wraphoriz_type">Horizontal wrapping mode of the texture.</param>
            <param name="out_wrapvert_type">Vertical wrapping mode of the texture.</param>
        </member>
        <member name="M:Love.Video.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Video.NewVideoStream(System.String)">
            <summary>
            Creates a new VideoStream. Currently only Ogg Theora video files are supported. VideoStreams can't draw videos, see love.graphics.newVideo for that.
            </summary>
            <param name="filename">The file path to the Ogg Theora video file.</param>
            <returns>A new VideoStream.</returns>
        </member>
        <member name="M:Love.Video.Play">
            <summary>
            Starts playing the Video.
            </summary>
        </member>
        <member name="M:Love.Video.Pause">
            <summary>
            Pauses the Video.
            </summary>
        </member>
        <member name="M:Love.Video.Seek(System.Double)">
            <summary>
            Sets the current playback position of the Video.
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Love.Video.Rewind">
            <summary>
            Rewinds the Video to the beginning.
            </summary>
        </member>
        <member name="M:Love.Video.Tell">
            <summary>
            Gets the current playback position of the Video.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Video.IsPlaying">
            <summary>
            Gets whether the Video is currently playing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Video.NewVideoStream(Love.File)">
            <summary>
            Creates a new VideoStream. Currently only Ogg Theora video files are supported. VideoStreams can't draw videos, see love.graphics.newVideo for that.
            </summary>
            <param name="file">The File object containing the Ogg Theora video.</param>
            <returns>A new VideoStream.</returns>
        </member>
        <member name="M:Love.ImageDataBase.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.CompressedImageData.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.ImageData.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.ImageData.GetWidth">
            <summary>
            Gets the width of the ImageData in pixels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.GetHeight">
            <summary>
            Gets the height of the ImageData in pixels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.GetPixel(System.Int32,System.Int32)">
            <summary>
            <para>Gets the color of a pixel at a specific position in the image.</para>
            </summary>
            <param name="x">The position of the pixel on the x-axis.</param>
            <param name="y">The position of the pixel on the y-axis.</param>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.SetPixel(System.Int32,System.Int32,Love.Color)">
            <summary>
            <para>Sets the color of a pixel at a specific position in the image. </para>
            </summary>
            <param name="x">The position of the pixel on the x-axis.</param>
            <param name="y">The position of the pixel on the y-axis.</param>
        </member>
        <member name="M:Love.ImageData.GetFormat">
            <summary>
            Gets the pixel format of the ImageData.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.Paste(Love.ImageData,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            从另一个源ImageData粘贴到ImageData
            </summary>
            <param name="src_imageData">Source ImageData from which to copy.</param>
            <param name="dx">目标图左上角横坐标</param>
            <param name="dy">目标图左上角纵坐标</param>
            <param name="sx">源图横坐标偏移</param>
            <param name="sy">源图纵坐标偏移</param>
            <param name="sw">源图宽度</param>
            <param name="sh">源图高度</param>
        </member>
        <member name="M:Love.ImageData.Encode(Love.ImageFormat,System.Boolean,System.String)">
            <summary>
            Encodes the ImageData and optionally writes it to the save directory.
            </summary>
            <param name="format_type">The format to encode the image as.</param>
            <param name="writeToFile">Whether to write to the specified file</param>
            <param name="filename">The filename to write the file to. If null, no file will be written but the FileData will still be returned.</param>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.MapPixel(Love.ImageData.MapColorDelegate)">
            <summary>
            <para> Transform an image by applying a function to every pixel. </para>
            <para> This function is a higher-order function(https://en.wikipedia.org/wiki/Higher-order_function). It takes another function as a parameter, and calls it once for each pixel in the ImageData. </para>
            <para>The passed function is called with six parameters for each pixel in turn. The parameters are numbers that represent the x and y coordinates of the pixel and its red, green, blue and alpha values. The function should return the new red, green, blue, and alpha values for that pixel.</para>
            </summary>
            <param name="func">Function to apply to every pixel.</param>
        </member>
        <member name="M:Love.ImageData.MapPixel(Love.ImageData.MapColorDelegate,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para> Transform an image by applying a function to every pixel. </para>
            <para> This function is a higher-order function(https://en.wikipedia.org/wiki/Higher-order_function). It takes another function as a parameter, and calls it once for each pixel in the ImageData. </para>
            <para>The passed function is called with six parameters for each pixel in turn. The parameters are numbers that represent the x and y coordinates of the pixel and its red, green, blue and alpha values. The function should return the new red, green, blue, and alpha values for that pixel.</para>
            </summary>
            <param name="func">Function to apply to every pixel.</param>
            <param name="sx">The x-axis of the top-left corner of the area within the ImageData to apply the function to.</param>
            <param name="sy">The y-axis of the top-left corner of the area within the ImageData to apply the function to.</param>
            <param name="w">The width of the area within the ImageData to apply the function to.</param>
            <param name="h">The height of the area within the ImageData to apply the function to.</param>
        </member>
        <member name="M:Love.ImageData.MapPixel(Love.ImageData.MapVectorDelegate)">
            <summary>
            <para> Transform an image by applying a function to every pixel. </para>
            <para> This function is a higher-order function(https://en.wikipedia.org/wiki/Higher-order_function). It takes another function as a parameter, and calls it once for each pixel in the ImageData. </para>
            <para>The passed function is called with six parameters for each pixel in turn. The parameters are numbers that represent the x and y coordinates of the pixel and its red, green, blue and alpha values. The function should return the new red, green, blue, and alpha values for that pixel.</para>
            </summary>
            <param name="func">Function to apply to every pixel.</param>
        </member>
        <member name="M:Love.ImageData.MapPixel(Love.ImageData.MapVectorDelegate,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para> Transform an image by applying a function to every pixel. </para>
            <para> This function is a higher-order function(https://en.wikipedia.org/wiki/Higher-order_function). It takes another function as a parameter, and calls it once for each pixel in the ImageData. </para>
            <para>The passed function is called with six parameters for each pixel in turn. The parameters are numbers that represent the x and y coordinates of the pixel and its red, green, blue and alpha values. The function should return the new red, green, blue, and alpha values for that pixel.</para>
            </summary>
            <param name="func">Function to apply to every pixel.</param>
            <param name="sx">The x-axis of the top-left corner of the area within the ImageData to apply the function to.</param>
            <param name="sy">The y-axis of the top-left corner of the area within the ImageData to apply the function to.</param>
            <param name="w">The width of the area within the ImageData to apply the function to.</param>
            <param name="h">The height of the area within the ImageData to apply the function to.</param>
        </member>
        <member name="M:Love.ImageData.GetPixels(Love.Rectangle)">
            <param name="area">The area within the ImageData</param>
        </member>
        <member name="M:Love.ImageData.GetPixels(System.Int32,System.Int32,System.Int32,System.Int32)">
            <param name="x">The x-axis of the top-left corner of the area within the ImageData</param>
            <param name="y">The y-axis of the top-left corner of the area within the ImageData</param>
            <param name="w">The width of the area within the ImageData</param>
            <param name="h">The height of the area within the ImageData</param>
        </member>
        <member name="M:Love.ImageData.SetPixels(System.Int32,System.Int32,System.Int32,System.Int32,Love.Color[])">
            <param name="x">The x-axis of the top-left corner of the area within the ImageData</param>
            <param name="y">The y-axis of the top-left corner of the area within the ImageData</param>
            <param name="w">The width of the area within the ImageData</param>
            <param name="h">The height of the area within the ImageData</param>
        </member>
        <member name="M:Love.ImageData.SetPixels(Love.Rectangle,Love.Color[][])">
            <param name="area">The area within the ImageData</param>
        </member>
        <member name="M:Love.ImageData.SetPixels(System.Int32,System.Int32,System.Int32,System.Int32,Love.Color[][])">
            <param name="x">The x-axis of the top-left corner of the area within the ImageData</param>
            <param name="y">The y-axis of the top-left corner of the area within the ImageData</param>
            <param name="w">The width of the area within the ImageData, can small then the width of rawData</param>
            <param name="h">The height of the area within the ImageData, can small then the height of rawData</param>
        </member>
        <member name="M:Love.ImageData.SetPixels(Love.Rectangle,Love.Color[0:,0:])">
            <param name="area">The area within the ImageData</param>
        </member>
        <member name="M:Love.ImageData.SetPixels(System.Int32,System.Int32,System.Int32,System.Int32,Love.Color[0:,0:])">
            <param name="x">The x-axis of the top-left corner of the area within the ImageData</param>
            <param name="y">The y-axis of the top-left corner of the area within the ImageData</param>
            <param name="w">The width of the area within the ImageData, can small then the width of rawData</param>
            <param name="h">The height of the area within the ImageData, can small then the height of rawData</param>
        </member>
        <member name="M:Love.ImageData.GetPixelsFloat">
            <summary>
            get every pixel, as Float4 format
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.GetPixelsFloat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            get every pixel, as Float4 format
            </summary>
            <param name="x">The x-axis of the top-left corner of the area within the ImageData</param>
            <param name="y">The y-axis of the top-left corner of the area within the ImageData</param>
            <param name="w">The width of the area within the ImageData</param>
            <param name="h">The height of the area within the ImageData</param>
        </member>
        <member name="M:Love.ImageData.SetPixelsFloat(Love.Vector4[])">
            <summary>
            set every pixel with given data, function will convert Float4 to correct pixel format automatically
            </summary>
            <param name="data">color data to set</param>
        </member>
        <member name="M:Love.ImageData.SetPixelsFloat(System.Int32,System.Int32,System.Int32,System.Int32,Love.Vector4[])">
            <summary>
            set every pixel with given data, function will convert Float4 to correct pixel format automatically
            </summary>
            <param name="x">The x-axis of the top-left corner of the area within the ImageData</param>
            <param name="y">The y-axis of the top-left corner of the area within the ImageData</param>
            <param name="w">The width of the area within the ImageData</param>
            <param name="h">The height of the area within the ImageData</param>
            <param name="data">color data to set</param>
        </member>
        <member name="M:Love.ImageData.Encode(Love.ImageFormat)">
            <summary>
            Encodes the ImageData and optionally writes it to the save directory.
            </summary>
            <param name="format_type">The format to encode the image as.</param>
        </member>
        <member name="M:Love.ImageData.Encode(Love.ImageFormat,System.String)">
            <summary>
            Encodes the ImageData and optionally writes it to the save directory.
            </summary>
            <param name="format_type">The format to encode the image as.</param>
            <param name="filename">The filename to write the file to. If null, no file will be written but the FileData will still be returned.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Cursor.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Cursor.GetType">
            <summary>
            Gets the type of the Cursor.
            </summary>
            <returns>The type of the Cursor.</returns>
        </member>
        <member name="M:Love.Decoder.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="F:Love.Decoder.DEFAULT_BUFFER_SIZE">
            <summary>
            Indicates how many bytes of raw data should be generated at each call to Decode.
            </summary>
        </member>
        <member name="F:Love.Decoder.DEFAULT_SAMPLE_RATE">
            <summary>
            Indicates the quality of the sound.
            </summary>
        </member>
        <member name="F:Love.Decoder.DEFAULT_CHANNELS">
            <summary>
            Default is stereo.
            </summary>
        </member>
        <member name="F:Love.Decoder.DEFAULT_BIT_DEPTH">
            <summary>
            16 bit audio is the default.
            </summary>
        </member>
        <member name="M:Love.SoundData.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.VideoStream.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.BezierCurve.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.RandomGenerator.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.RandomGenerator.Random(System.Int32,System.Int32)">
            <summary>
            Get uniformly distributed pseudo-random integer within [min, max].
            </summary>
            <param name="min">The minimum possible value it should return.</param>
            <param name="max">The maximum possible value it should return.</param>
            <returns></returns>
        </member>
        <member name="M:Love.RandomGenerator.Random(System.Single,System.Single)">
            <summary>
            Get uniformly distributed pseudo-random integer within [min, max].
            </summary>
            <param name="min">The minimum possible value it should return.</param>
            <param name="max">The maximum possible value it should return.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Joystick.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Data.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Data.GetSize">
            <summary>
            Gets the Data's size in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Data.GetPointer">
            <summary>
            Gets a pointer to the Data.
            <para>Use at your own risk. Directly reading from and writing to the raw memory owned by the Data will bypass any safety checks and thread-safety the Data might normally have.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Data.GetBytes">
            <summary>
            Get file data full byte[]
            <para>This function can be slow if it is called repeatedly, such as from <see cref="M:Love.Scene.Update(System.Single)"/> or <see cref="M:Love.Scene.Draw"/> . If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.TrueTypeRasterizer.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.DroppedFile.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Stream.#ctor(System.IntPtr)">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.ColoredString.Create(System.String,Love.Vector4)">
            <summary>
            Create ColoredString from text and color
            </summary>
            <param name="text"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Love.ColoredString.Create(System.String,Love.Color)">
            <summary>
            Create ColoredString from text and color
            </summary>
            <param name="text"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Love.ColoredString.Create(System.String,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create ColoredString from text and color
            </summary>
            <param name="text"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Love.ColoredStringArray.Create(System.String)">
            <summary>
            Create white Color text
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="F:Love.NativeLibraryUtil.WindowsNativeLibraryLoader.Architecture.x64">
            <summary>
            x64 (AMD or Intel)
            </summary>
        </member>
        <member name="F:Love.NativeLibraryUtil.WindowsNativeLibraryLoader.Architecture.ARM">
             <summary>
            
             </summary>
        </member>
        <member name="F:Love.NativeLibraryUtil.WindowsNativeLibraryLoader.Architecture.ARM64">
             <summary>
            
             </summary>
        </member>
        <member name="T:Love.NativeLibraryUtil.PlatformDetecter">
            <summary>
            https://github.com/Pkcs11Interop/Pkcs11Interop/blob/3.2.0/src/Pkcs11Interop/Pkcs11Interop/Common/Platform.cs#L228-L254
            </summary>
        </member>
        <member name="F:Love.NativeLibraryUtil.PlatformDetecter._isWindows">
            <summary>
            True if runtime platform is Windows
            </summary>
        </member>
        <member name="P:Love.NativeLibraryUtil.PlatformDetecter.IsWindows">
            <summary>
            True if runtime platform is Windows
            </summary>
        </member>
        <member name="F:Love.NativeLibraryUtil.PlatformDetecter._isLinux">
            <summary>
            True if runtime platform is Linux
            </summary>
        </member>
        <member name="P:Love.NativeLibraryUtil.PlatformDetecter.IsLinux">
            <summary>
            True if runtime platform is Linux
            </summary>
        </member>
        <member name="F:Love.NativeLibraryUtil.PlatformDetecter._isMacOsX">
            <summary>
            True if runtime platform is Mac OS X
            </summary>
        </member>
        <member name="P:Love.NativeLibraryUtil.PlatformDetecter.IsMacOsX">
            <summary>
            True if runtime platform is Mac OS X
            </summary>
        </member>
    </members>
</doc>
